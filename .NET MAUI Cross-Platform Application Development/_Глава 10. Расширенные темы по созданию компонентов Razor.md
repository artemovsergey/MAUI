# Расширенные темы по созданию компонентов Razor

В разработке приложений Blazor все является компонентом. Мы научились создавать компоненты Razor
в последней главе. В этой главе мы рассмотрим более сложные темы о компонентах Razor. К
преобразовать группы списков и контекстные меню в компоненты Razor, нам нужно понять сложные темы
такие как шаблонные компоненты и проверка формы. Мы познакомим вас с этими понятиями, пока мы
создание дополнительных компонентов Razor в нашем проекте.
В этой главе мы рассмотрим следующие темы:


* Создание дополнительных компонентов Razor

* Использование шаблонных компонентов

* Встроенные компоненты Razor и проверка ввода

# Технические требования

Для тестирования и отладки исходного кода в этой главе вам необходимо установить Visual Studio 2022 на
ваш ПК или Mac. Пожалуйста, обратитесь к разделу Настройка среды разработки в Главе 1, Получение
Начал с .NET MAUI, подробнее.


Исходный код этой главы доступен в следующем репозитории GitHub:

https://github.com/PacktPublishing/.NET-MAUI-Cross-PlatformApplication-Development/tree/main/Chapter10

Исходный код можно загрузить с помощью следующей команды Git:

```
git clone -b глава 10 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development PassXYZ.Vault2
```

# Создание дополнительных компонентов Razor

Мы разработали модальные диалоговые компоненты в главе 9 «Компоненты Razor и привязка данных». В этом
главу, мы уточним наш код, чтобы удалить повторяющийся код на страницах Items и ItemDetail.
и преобразовать дублированный код в компоненты Razor. Мы создадим следующие компоненты:

* Navbar — это компонент для отображения панели навигации.

* Dropdown — это компонент для поддержки контекстного меню.

* ListView — это компонент для отображения списка элементов.

Компонент ListView является самым сложным, поэтому мы оставим его до конца этого раздела.
Давайте сначала поработаем над Navbar и Dropdown.

# Создание компонента Navbar

Давайте посмотрим на пользовательский интерфейс панели навигации на рис. 10.1. Мы видим, что панель навигации содержит кнопку «Назад».
кнопка, заголовок и кнопка «Добавить»:

![изображение](https://user-images.githubusercontent.com/26972859/231983192-19fee52b-9421-4702-8194-3e89f9a0bf28.png)

Рисунок 10.1: Панель навигации

Текущий код панели навигации отображается рядом, и этот фрагмент кода дублируется на обоих
Страницы Items и ItemDetail:

```
<div class="container">
 <div class="row">
 <div class="col-12">
 <h1>
 @if (selectedItem?.GetParentLink() != null) { ❶
 <a class="btn btn-outline-dark"
 href="@selectedItem?.GetParentLink()">
 <span class="oi oi-chevron-left"
 aria-hidden="true"></span></a> ❷
 }
 @(" " + Title) ❸
 <button type="button"
 class="btn btn-outline-dark float-end"
 data-bs-toggle="modal"
 data-bs-target="#@_dialogEditId"
 @onclick="@(() => _isNewItem=true)"> ❹
 <span class="oi oi-plus" aria-hidden="true">
 </span>
 </button>
 </h1>
 </div>
 </div>
</div>
```
В предыдущем коде ❶ кнопка «Назад» отображается при наличии родительской ссылки. ❷ Кнопка «Назад»
реализован как тег ```<a>```. ❸ Заголовок представляет собой строку и отображается как часть тега ```<h1>```. ❹
Кнопка добавления реализована в виде тега ```<button>```. Стиль Bootstrap используется для форматирования как Back, так и
добавьте кнопки.

Чтобы преобразовать предыдущий код в компонент Razor, мы можем создать новый компонент Razor в
проект PassXYZ.BlazorUI и назовите его Navbar. Navbar может отображать элементы пользовательского интерфейса в
Рисунок 10.1, который включает кнопку «Назад», заголовок и кнопку «Добавить». Чтобы разделить пользовательский интерфейс и логику, мы
создайте файл кода программной части C# Navbar.razor.cs и разметку Razor, Navbar.razor. Мы
определить параметры компонента и обработчики событий в файле кода программной части C#, как показано в листинге 10.1:

**Листинг 10.1: Navbar.razor.cs (https://epa.ms/Navbar10-1)**

```Csharp
public partial class Navbar
{
 [Parameter]
 public string? ParentLink { get; set; } ❶
 [Parameter]
 public string? DialogId { get; set; } ❷
 [Parameter]
 public string? Title { get; set; } ❸
 [Parameter]
 public EventCallback<MouseEventArgs> OnAddClick { get;
 set; } ❹
 private void OnClickClose(MouseEventArgs e) {
 OnAddClick.InvokeAsync();
 }
}
```
В Navbar определены четыре параметра компонента и обработчик событий. Мы можем установить
родительская ссылка кнопки «Назад» с параметром ParentLink ❶. Значение заголовка установлено в
параметр Заголовок ❸. Для кнопки «Добавить» нам нужно предоставить идентификатор и обработчик события для
диалоговое окно, чтобы использовались параметры DialogId ❷ и OnAddClick ❹.
Теперь давайте посмотрим на файл Razor панели навигации в листинге 10.2:

** Листинг 10.2: Navbar.razor (https://epa.ms/Navbar10-2)**

```
@namespace PassXYZ.BlazorUI
<div class="container">
 <div class="row">
 <div class="col-12">
 <h1>
 @if (ParentLink != null) { ①
 <a class="btn btn-outline-dark"
 href="@ParentLink"> ①
 <span class="oi oi-chevron-left"
 aria-hidden="true"></span>
 </a>
 }
 @(" " + Title) ③
 <button type="button"
 class="btn btn-outline-dark float-end"
 data-bs-toggle="modal"
 data-bs-target="#@DialogId" ②
 @onclick="OnClickClose"> ④
 <span class="oi oi-plus" aria-hidden="true">
 </span>
 </button>
 </h1>
 </div>
 </div>
</div>
```
Мы видим, что код очень похож на код в Items и ItemDetail. Разница в том,
что мы заменили значение жесткого кода параметрами компонента (ParentLink ①, DialogId ②,
Заголовок ③ и OnClickClose ④). С помощью этого нового компонента Navbar мы можем заменить код
в Items с помощью компонента Navbar следующим образом:

```
<Navbar ParentLink="@selectedItem?.GetParentLink()"
 Title="@Title" DialogId="@_dialogEditId"
 OnAddClick="@(() => {_isNewItem=true;})" />
```
И мы можем заменить код в ItemDetail следующим образом:

```
<Navbar ParentLink="@selectedItem?.GetParentLink()"
Title="@selectedItem?.Name" DialogId="@_dialogEditId"
OnAddClick="@(() => {_isNewField=true;})" />
```
Как мы видим, мы доработали код, удалив дублирующийся код, и новый код выглядит намного лучше.
элегантно и лаконично.
Мы сделали работу для Navbar. Теперь давайте перейдем к компоненту Dropdown.

# Создание компонента Dropdown для контекстного меню

Чтобы создать компонент, похожий на контекстное меню, мы можем повторно использовать компонент Bootstrap Dropdown.
Как видно на рис. 10.2, контекстное меню включает в себя кнопку контекстного меню и список пунктов меню.
Когда пользователи нажимают кнопку контекстного меню, отображается список пунктов меню:

![изображение](https://user-images.githubusercontent.com/26972859/231984248-0b203f6a-3c83-4d3a-a3e9-86808186ae0a.png)

Рисунок 10.2: Контекстное меню

Текущий код контекстного меню дублируется на страницах Items и ItemDetail,
которые показаны здесь:

```
<button class="opacity-50 btn btn-light dropdown-toggle"
 type="button" id="itemsContextMenu"
 data-bs-toggle="dropdown"
 aria-expanded="false"
 @onclick="@(() => listGroupItem=item)">
 <span class="oi oi-menu" aria-hidden="true"></span>
</button>
<ul class="dropdown-menu"
 aria-labelledby="itemsContextMenu">
 <li><button class="dropdown-item" data-bs-toggle="modal"
 data-bs-target="#@_dialogEditId"
 @onclick="@(() => _isNewItem=false)">
 Edit
 </button></li>
 <li><button class="dropdown-item" data-bs-toggle="modal"
 data-bs-target="#@_dialogDeleteId">
 Delete
 </button></li>
</ul>
```
Компонент Dropdown Bootstrap включает в себя кнопку и неупорядоченный список. Нам нужно определить
обработчик события кнопки для выполнения действия. В предыдущем коде мы установили переменную item в
списокГрупповойЭлемент. Для пунктов меню каждый пункт меню реализован как тег ```<button>``` и
принимает идентификатор диалога и обработчик событий в качестве параметров. При выборе пункта меню соответствующий
появится модальный диалог.
Мы можем создать два новых компонента Razor в проекте PassXYZ.BlazorUI и назвать их как
Выпадающий список и элемент меню. Мы также можем реализовать их в файле кода программной части C# (листинг 10.4).
и файл Razor (листинг 10.3) для разделения пользовательского интерфейса и логики, что мы сейчас и сделаем.
Сначала рассмотрим пользовательский интерфейс компонента Dropdown в листинге 10.3:

**Листинг 10.3: Dropdown.razor (https://epa.ms/Dropdown10-3)**

```
@namespace PassXYZ.BlazorUI
<button class="opacity-50 btn btn-light dropdown-toggle"
 type="button" id="itemDetailContextMenu"
 data-bs-toggle="dropdown"
 aria-expanded="false" @onclick="OnClick">
 <span class="oi oi-menu" aria-hidden="true"></span>
</button> ❶
<ul class="dropdown-menu"
 aria-labelledby="itemDetailContextMenu">
 @ChildContent
</ul> 
```
В компоненте Dropdown мы определяем кнопку ❶ и неупорядоченный список ❷. Событие щелчка
Кнопка определяется как обработчик события OnClick. Элементы в неупорядоченном списке отображаются как дочерние
содержимое раскрывающегося списка. Параметры компонента определяются в раскрывающемся списке C#.
Файл кода программной части razor.cs в листинге 10.4:

**Листинг 10.4: Dropdown.razor.cs (https://epa.ms/Dropdown10-4)**

```
namespace PassXYZ.BlazorUI;
public partial class Dropdown
{
 [Parameter]
 public EventCallback<MouseEventArgs> OnClick {get;set;}①
 [Parameter]
 public RenderFragment ChildContent { get; set; } ②
}
```
В Dropdown.razor.cs два параметра компонента — OnClick ① и ChildContent.
② – определены.
Компонент MenuItem может отображаться как дочернее содержимое компонента Dropdown. Мы
можно увидеть код пользовательского интерфейса MenuItem в листинге 10.5:

** Листинг 10.5: MenuItem.razor (https://epa.ms/MenuItem10-5)**

```
@namespace PassXYZ.BlazorUI
<li>
 <button class="dropdown-item" data-bs-toggle="modal"
 data-bs-target="#@Id" @onclick="OnClick">
 @ChildContent
 </button>
</li>
```
Компонент MenuItem определяет три параметра компонента — Id, OnClick и ChildContent.
Эти параметры определены в MenuItem.razor.cs в листинге 10.6.

**Листинг 10.6: MenuItem.razor.cs (https://epa.ms/MenuItem10-6)**

```
namespace PassXYZ.BlazorUI;
public partial class MenuItem
{
 [Parameter]
 public string? Id { get; set; } ❶
 [Parameter]
 public EventCallback<MouseEventArgs> OnClick {get; set;} ❷
 [Parameter]
 public RenderFragment ChildContent { get; set; } ❸
}
```
❶ Параметр Id используется для указания идентификатора диалогового окна при щелчке элемента меню. ❷ По клику
используется для регистрации обработчика события нажатия кнопки. ❸ ChildContent используется для отображения
дочерний контент, такой как название пункта меню.

❶ Параметр Id используется для указания идентификатора диалогового окна при щелчке элемента меню. ❷ По клику
используется для регистрации обработчика события нажатия кнопки. ❸ ChildContent используется для отображения
дочерний контент, такой как название пункта меню.

```xml
<Dropdown OnClick="@(() => currentItem.
Data=listGroupItem=item)">
 <MenuItem Id="@_dialogEditId"
 OnClick="@(() => _isNewItem=false)">Edit</MenuItem>
 <MenuItem Id="@_dialogDeleteId">Delete</MenuItem>
</Dropdown>
```
На странице ItemDetail контекстное меню реализовано следующим образом:

```
<Dropdown OnClick="@(() = >
 {currentField.Data=listGroupField=field;})">
 <MenuItem Id="@_dialogEditId"
 OnClick="@(() => _isNewField=false)">Edit</MenuItem>
 <MenuItem Id="@_dialogDeleteId">Delete</MenuItem>
 @if (field.IsProtected) {
<MenuItem OnClick="OnToggleShowPassword">
 @(field.IsHide ? "Show":"Hide")
</MenuItem>
 }
</Dropdown>

```
После доработки кода страниц Items и ItemDetail мы создали модальный диалог,
панель навигации и компоненты контекстного меню. Теперь код выглядит намного элегантнее и лаконичнее.
Тем не менее, у нас еще есть место для дальнейшей доработки кода. Основная логика пользовательского интерфейса как в элементах, так и в
Страницы ItemDetail представляют собой список. Мы можем доработать эту часть кода как компонент ListView. К
создать компонент ListView, нам нужно использовать расширенную функцию, называемую шаблонными компонентами.

# Использование шаблонных компонентов

Чтобы создать компонент Razor, параметры компонента являются каналами для родительского и дочернего взаимодействия.
В главе 9 «Компоненты Razor и привязка данных» мы представили вложенные компоненты. Мы упоминали
специальный параметр компонента ChildContent типа RenderFragment. Родитель
Компонент может установить содержимое дочернего компонента с помощью этого параметра. Например, содержание
для MenuItem в следующем коде можно задать строку HTML:

```
<MenuItem Id="@_dialogDeleteId">
 <strong>Delete</strong>
</MenuItem>
```
Мы можем сделать это, потому что MenuItem определяет следующий параметр компонента, как мы можем видеть в
Листинг 10.6:

```Csharp
[Parameter]
public RenderFragment ChildContent { get; set; }
```
Если мы хотим явно указать параметр ChildContent, мы также можем сделать это:

```xml
<MenuItem Id="@_dialogDeleteId">
 <ChildContent>
 <strong>Delete</strong>
 </ChildContent>
</MenuItem>
```
ChildContent — это специальный параметр компонента, который мы можем неявно использовать в языке разметки. К
используем ChildContent, мы определяем компонент, который может принимать шаблон пользовательского интерфейса RenderFragment
введите в качестве параметра компонента. Мы можем определить более одного шаблона пользовательского интерфейса в качестве параметра, когда мы
создать новый компонент. Такой компонент называется шаблонным компонентом.
Фрагмент рендеринга типа RenderFragment представляет сегмент пользовательского интерфейса для рендеринга. Там
также является универсальной версией, ```RenderFragment<TValue>```, которая принимает параметр типа. Мы можем
указать тип при вызове RenderFragment.

# Создание компонента ListView

Чтобы создать ListView, нам нужно использовать несколько шаблонов пользовательского интерфейса в качестве параметров компонента. Мы можем создать
новый компонент Razor в проекте PassXYZ.BlazorUI и назовите его ListView. Как мы это сделали
для панели навигации и контекстного меню мы разделяем пользовательский интерфейс и код в файле Razor (листинг 10.7) и
Файл кода программной части C# (листинг 10.8):

# Листинг 10.7: ListView.razor (https://epa.ms/ListView10-7)

```
@namespace PassXYZ.BlazorUI
@typeparam TItem
<div class="list-group">
 @if (Header != null) {
 @Header ❶
 }
 @if (Row != null && Items != null) {
 @foreach (var item in Items) {
 <div class="dropdown list-group-item
 list-group-item-action
 d-flex gap-1 py-2" style="border: none"
 aria-current="true">
 @Row.Invoke(item) ❷
 </div>
 }
 }
 @if (Footer != null) {
 <div class="container">
 <article>@Footer</article>
 </div> ❸
 }
</div>
```

В файле ListView Razor мы определяем три шаблона пользовательского интерфейса — заголовок ❶, строку ❷ и нижний колонтитул ❸.
Мы визуализируем верхний и нижний колонтитулы так же, как ChildContent, но параметр компонента Row
выглядит иначе. Мы визуализируем это следующим образом:

```@Row(item)```

Или мы можем отобразить это так:

```@Row.Invoke(item)```

Мы визуализируем его с аргументом элемента. Тип Row - ```RenderFragment<TValue>```, как мы
можно увидеть в листинге 10.8:

**Листинг 10.8: ListView.razor.cs (https://epa.ms/ListView10-8)**

```
namespace PassXYZ.BlazorUI;
public partial class ListView<TItem>
{
 [Parameter]
 public RenderFragment? Header { get; set; } ①
 [Parameter]
 public RenderFragment<TItem>? Row { get; set; } ②
 [Parameter]
  public IEnumerable<TItem>? Items { get; set; } ③
 [Parameter]
 public RenderFragment? Footer { get; set; } ④
}
```
Мы определяем ListView как общий тип ````ListView<TItem>``` с параметром типа TItem. в
Компонент ListView, мы можем определить заголовок представления списка, используя параметр Заголовок ① и нижний колонтитул
используя нижний колонтитул ④. ListView может быть привязан к любой коллекции данных ```IEnumerable<TItem>```
введите с помощью параметра Items ③. Параметр Row ② можно использовать для определения шаблона пользовательского интерфейса.
для отдельного элемента в цикле foreach.

# Использование компонента ListView

Теперь мы можем посмотреть на использование компонента ListView на страницах Items и ItemDetail.
Мы используем страницу ItemDetail в качестве примера здесь:

```
<ListView Items="fields"> ❶
 <Row Context="field"> ❷
 @if (field.ShowContextAction == null) {
 <span class="oi oi-pencil" aria-hidden="true"></span>
 <div class="d-flex gap-2 w-100
 justify-content-between">
 <div>
 <h6 class="mb-0">@field.Key</h6>
 <p class="mb-0">@field.Value</p>
 </div>
 </div>
 <Dropdown
 OnClick="@(() =>
 {currentField.Data=listGroupField=field;})">
 <MenuItem Id="@_dialogEditId"
 OnClick="@(() => _isNewField=false)">
 Edit
 </MenuItem>
 <MenuItem Id="@_dialogDeleteId">Delete</MenuItem>
 @if (field.IsProtected) {
 <MenuItem OnClick="OnToggleShowPassword">
 @(field.IsHide ? "Show":"Hide")
 </MenuItem>
 }
 </Dropdown>
 }
 </Row>
 <Footer>
 @((MarkupString)notes)
 </Footer>
</ListView>
```
Поскольку мы определяем Header, Row и Footer как необязательные параметры, нам не нужно указывать все
их. На странице ItemDetail мы используем Row и Footer. ❶ Нам нужно передать список полей в
Сначала параметр Items. ❷ Каждое поле в цикле foreach передается в ListView в качестве аргумента.
в строку, которая определена здесь:

```<Row Context="field">```

Значение «поле» свойства Context используется для указания аргумента для строки. Внутри пользовательского интерфейса
шаблон Row, мы отображаем ключевое значение поля и создаем контекстное меню с помощью раскрывающегося списка
и компоненты MenuItem, которые мы реализовали в предыдущем разделе.
Используя компонент ListView, мы видим, что реализация страницы ItemDetail
теперь выглядит намного лучше.
  
Мы внесли улучшения, создав собственные компоненты Razor.

В Blazor у нас есть несколько вариантов разработки пользовательского интерфейса. Мы можем использовать HTML/CSS для дизайна пользовательского интерфейса. На
Помимо HTML/CSS, мы можем создавать собственные компоненты Razor для улучшения дизайна и реализации.
Для нас также доступно множество сторонних библиотек компонентов Razor, и мы также можем использовать ASP.
NET Core встроенные компоненты Razor.
В следующем разделе мы будем поддерживать проверку данных с помощью встроенных в ASP.NET компонентов Razor.

# Встроенные компоненты и проверка

В нашем приложении мы реализуем EditorDialog как редактор ключевых значений. Когда мы создаем или редактируем элемент или
поле, мы используем его для редактирования пары данных ключ-значение. EditorDialog построен с использованием фреймворка Bootstrap.
Одна ключевая функция, отсутствующая в EditorDialog, заключается в том, что он не поддерживает проверку данных. Валидация данных
включает два слоя — слой пользовательского интерфейса и логику. Мы можем реализовать простую логику проверки данных на C#, но
пользовательский интерфейс проверки данных намного сложнее. Мы еще не сделали этого на уровне пользовательского интерфейса. В обоих

страницы Items и ItemDetail мы реализовали простую логику проверки данных. Мы можем просмотреть
логика проверки данных в методе UpdateItemAsync() страницы Items:

```Csharp
private async Task<bool> UpdateItemAsync(string key, string
value)
{
 if (listGroupItem == null) return false;
 if (string.IsNullOrEmpty(key) ||
 string.IsNullOrEmpty(value))
 return false;
 listGroupItem.Name = key;
 listGroupItem.Notes = value;
 if (_isNewItem) {…}
 else {...}
 StateHasChanged();
 return true;
}
```
В EditorDialog после завершения редактирования вызывается UpdateItemAsync() для сохранения
данные. Прежде чем продолжить, мы проверяем значение аргументов ключа и значения. Если кто-то из них
имеет значение null, мы просто возвращаем false. Здесь нет проблем с логикой программы, но мы должны уведомить
пользователей об ошибке, связанной с сохранением данных. Со встроенными компонентами ASP.NET проверка данных
поддерживается на уровне пользовательского интерфейса. Пользователь может получить мгновенную обратную связь об ошибке.

# Использование встроенных компонентов

На самом деле мы использовали встроенные компоненты в предыдущих главах. Когда мы представили маршрутизацию и
расположение компонентов Razor, мы использовали Router, RouteView, LayoutView и MainLayout
компоненты в Main.razor. Все они являются встроенными компонентами.
В этом разделе мы рассмотрим встроенные компоненты ввода, которые мы можем использовать для улучшения опыта.
компонентов редактирования с поддержкой проверки данных. В следующей таблице приведен список встроенных
входные компоненты:
  
|Компонент ввода|HTML-тег|
|:--------------|:-------|
|InputCheckbox|```<input type="checkbox">```|
|```InputDate<TValue>```|```<input type="date">```|
|InputFile|```<input type="file">```|
|```InputNumber<TValue>```|```<input type="number">```|
|```InputRadio<TValue>```|```<input type="radio">```|
|```InputRadioGroup<TValue>``` |Группа потомков ```InputRadio<TValue>```|
|```InputSelect<TValue>```|```<select>```|
|InputText|```<input>```|
|InputTextArea |```<textarea>```|
|EditForm|```<форма>```|
  
Таблица 10.1: Встроенные компоненты

Чтобы найти подробную информацию о встроенных компонентах ввода, вы можете проверить следующее
Документ Майкрософт:
  
https://learn.microsoft.com/en-us/aspnet/core/blazor/forms-and-inputcomponents?view=aspnetcore-6.0

В таблице 10.1 мы видим список компонентов ввода и компонент EditForm. встроенный
компоненты ввода — это расширенные версии соответствующих элементов HTML, перечисленных в правом столбце. Когда мы используем встроенные компоненты ввода с EditForm, EditForm может координировать
события проверки и отправки. Встроенные компоненты ввода могут проверять ввод пользователя, когда
подается форма.

# Использование компонента EditForm

Компонент EditForm представляет собой расширенную версию HTML-элемента <form>. Чтобы использовать EditForm,
мы можем обратиться к следующему коду, который показывает пустой компонент EditForm:

```
<EditForm Model="ModelData" OnSubmit="HandleSubmit"
 OnInValidSubmit="HandleInValidSubmit"
 OnValidSubmit="HandleValidSubmit">
</EditForm>
```
Или его можно использовать по-другому:

```
<EditForm EditContext="_editContext" OnSubmit="HandleSubmit"
 OnInValidSubmit="HandleInValidSubmit"
 OnValidSubmit="HandleValidSubmit">
</EditForm>
```
Мы можем передать ему данные, используя параметр Model или EditContext.

Мы можем указать экземпляр класса как модель для редактирования в EditForm. Экземпляр EditContext
будет создан на основе экземпляра модели, назначенного EditForm. EditContext используется как
каскадное значение для других компонентов в форме. Мы также можем указать экземпляр EditContext
напрямую, если мы хотим взять его под контроль.
  
Чтобы обработать результат редактирования формы, мы можем зарегистрировать следующие функции обратного вызова:

  * OnInvalidSubmit — этот обратный вызов будет вызван, когда форма будет отправлена, а EditContext недействителен.

  * OnSubmit — этот обратный вызов будет вызываться при отправке формы.

  * OnValidSubmit — этот обратный вызов будет вызываться, когда форма отправлена ​​и EditContext действителен.

  Мы будем использовать компонент EditForm и встроенные компоненты ввода для создания нового EditFormDialog.
компонент для улучшения нашего редактора ключевых значений с поддержкой проверки данных.

# Создание компонента EditFormDialog

Для поддержки проверки данных компонент EditForm должен быть привязан к модели, использующей данные.
аннотации. Для редактирования формы следует использовать встроенные компоненты ввода, чтобы расширенные
можно использовать такие функции, как проверка данных.
Во-первых, нам нужно создать класс модели KeyValueData, который можно использовать для редактирования значения ключа в
Проект PassXYZ.BlazorUI, как показано в листинге 10.9:

**Листинг 10.9: KeyValueData.cs (https://epa.ms/KeyValueData10-9)**

```
using System.ComponentModel.DataAnnotations; ❸
using KPCLib;
using PassXYZLib;
namespace PassXYZ.BlazorUI;
public class KeyValueData<T> : IKeyValue {
 [Required(ErrorMessage = "{0} cannot be empty.")]
 [Display(Name = "This field")]
 public string Key { ❶
 get {
 if (Data is Item item) { return item.Name; }
 if (Data is Field field) { return field.Key; }
 return string.Empty;
 using System.ComponentModel.DataAnnotations; ❸
using KPCLib;
using PassXYZLib;
namespace PassXYZ.BlazorUI;
public class KeyValueData<T> : IKeyValue {
 [Required(ErrorMessage = "{0} cannot be empty.")]
 [Display(Name = "This field")]
 public string Key { ❶
 get {
 if (Data is Item item) { return item.Name; }
 if (Data is Field field) { return field.Key; }
 return string.Empty;
```
Класс KeyValueData<T> используется для создания экземпляра модели для EditForm. Это общий
тип и реализует интерфейс IKeyValue, который определяет свойства, которые необходимо реализовать.
В классе KeyValueData<T> мы определяем свойства Key ❶ и Value ❷, IsChanged,
Является действительным и данные ❹. Мы видим, что мы помечаем свойства Key и Value аннотацией данных.
Атрибуты [Обязательный] и [Отображать]. Атрибут [Обязательный] указывает, что пользователь должен ввести
ценность. Атрибут [Display] определяет имя, отображаемое для свойства в сообщении об ошибке.
проверки данных, как показано на рисунке 10.3.
И [Required], и [Display] определены в System.ComponentModel.
пространство имен DataAnnotations ❸.
Класс KeyValueData<T> является универсальным классом и принимает параметр типа T для указания фактического
тип данных для редактирования. Свойство данных ❹ определяется как тип T. Мы можем передать либо Item, либо
Класс поля в качестве параметра типа для свойства Data. Свойство Key или Value привязано к
свойство экземпляра элемента или поля, хранящегося в свойстве данных

![изображение](https://user-images.githubusercontent.com/26972859/231991559-507ad884-5323-4d35-9960-924ff4ffa203.png)

Рисунок 10.3: EditFormDialog (добавление нового элемента)

На рис. 10.3 мы видим, что сообщения об ошибках будут отображаться, когда пользователи отправят форму с
пустое значение в поле ключа или значения. Чтобы включить проверку данных, нам также нужно добавить
Компонент <DataAnnotationsValidator/> в EditForm, как показано здесь:

```
<EditForm class="row gx-2 gy-3" Model="@ModelData"
 OnValidSubmit="@HandleValidSubmit">
 <DataAnnotationsValidator />
 ...
</EditForm>
```
Используя EditForm, довольно легко поддерживать проверку данных. Чтобы включить проверку данных с помощью EditForm,
Следуй этим шагам:

1. Привяжите EditForm к модели, которая использует атрибуты аннотаций данных.
2. Добавьте компонент <DataAnnotationsValidator/> в EditForm.
3. Используйте встроенные компоненты ввода для редактирования

Существует длинный список встроенных проверок, определяемых атрибутами. Вы можете узнать больше информации о
их в документации Microsoft в разделе «Дополнительная литература». Некоторые из них перечислены здесь:

• [ValidateNever]: указывает, что свойство или параметр следует исключить из проверки.
• [Сравнить]: проверяет совпадение двух свойств в модели.
• [EmailAddress]: проверяет, имеет ли свойство формат электронной почты.
• [Телефон]: проверяет, имеет ли свойство формат телефонного номера.
• [Диапазон]: проверяет, попадает ли значение свойства в указанный диапазон.
• [RegularExpression]: проверяет соответствие значения свойства указанному регулярному выражению.
• [Обязательный]: проверяет, что поле не является пустым.
• [StringLength]: проверяет, не превышает ли значение строкового свойства указанный предел длины.
• [URL]: проверяет, имеет ли свойство формат URL.

С введением встроенных компонентов мы можем создать новый компонент Razor, EditFormDialog,
в проекте PassXYZ.BlazorUI. Реализация EditFormDialog<TItem>
можно найти в листинге 10.10 и листинге 10.11:

** Листинг 10.10: EditFormDialog.razor (https://epa.ms/EditFormDialog10-10)**

```
@namespace PassXYZ.BlazorUI
@typeparam TItem
<div class="modal fade" id=@Id tabindex="-1"
 aria-labelledby="ModelLabel" aria-hidden="true">
 <div class="modal-dialog">
 <div class="modal-content">
 <div class="modal-header">
 <h5 class="modal-title" id="ModelLabel">
 @ModelData.Key</h5>
  <button type="button" class="btn-close"
 data-bs-dismiss="modal"
 aria-label="Close"></button>
 </div>
 <div class="modal-body">
 <EditForm class="row gx-2 gy-3" Model="@ModelData" ❶
 OnValidSubmit="@HandleValidSubmit">
 <DataAnnotationsValidator /> ❷
 @if (IsKeyEditingEnable) {
 <div class="form-group">
 <InputText id="Name" class="form-control" ❸
 @oninput="KeyHandler"
 placeholder=@KeyPlaceHolder
 @bind-Value="ModelData.Key" />
 <ValidationMessage For="()=>ModelData.Key"/> ❺
 </div>
 }
 @ChildContent
 <div class="form-group">
 <InputTextArea id="Value" class="form-control" ❹
 @oninput="KeyHandler"
 placeholder=@ValuePlaceHolder
 @bind-Value="ModelData.Value" />
 <ValidationMessage For="()=>ModelData.Value"/> ❺
 </div>
 <div class="col-12">
 <button type="button" class="btn btn-secondary"
 data-bs-dismiss="modal"
 @onclick="OnClickClose">
 @CloseButtonText
 </button>
 <button type="submit" class="btn btn-primary"
 data-bs-dismiss="@dataDismiss"
 @onclick="OnClickSave">
 @SaveButtonText
 </button>
  </div>
 </EditForm>
 </div>
 </div>
 </div>
</div>
```
Как видно из разметки Razor в листинге 10.10, мы создаем EditFormDialog<TItem>
компонент, использующий Bootstrap Modal. Он включает компонент EditForm ❶ в тело модального окна.
Моделью, привязанной к EditForm, является ModelData типа KeyValueData<TItem>, определенного в
Листинг 10.11. Компонент DataAnnotationsValidator ❷ определен для проверки данных.
Мы используем InputText ❸ для редактирования ключей и InputTextArea ❹ для редактирования значений. 
Компонент проверки ValidationMessage ❺ используется для определения сообщения об ошибке для проверки.
В ValidationMessage нам нужно указать поле с помощью свойства For следующим образом:

```<ValidationMessage For="() => ModelData.Key" />```

Формат сообщения об ошибке определяется с помощью свойства ErrorMessage свойства [Required].
атрибут следующим образом:

```
[Required(ErrorMessage = "{0} cannot be empty.")]
 [Display(Name = "This field")]
 public string Value { ... }
```
Как видно из листинга 10.11, параметры компонентов и функции обратного вызова для обработки событий
определены в EditFormDialog.razor.cs:

** Листинг 10.11: EditFormDialog.razor.cs (https://epa.ms/EditFormDialog10-11)**

```
namespace PassXYZ.BlazorUI;
public partial class EditFormDialog<TItem> {
 [Parameter]
 public string Id { get; set; } = default!;
 [Parameter]
 public RenderFragment ChildContent { get; set; }
 [Parameter]
 public Action? OnClose { get; set; }
 [Parameter]
 public Func<string, string, Task<bool>>? OnSaveAsync {
 get; set; }
 [Parameter]
 [NotNull]
 public string CloseButtonText { get; set; } = "Cancel";
 [Parameter]
 [NotNull]
 public string SaveButtonText { get; set; } = "Save";
 [Parameter]
 public KeyValueData<TItem> ModelData { get; set; }
 [Parameter]
 public string? KeyPlaceHolder { get; set; }
 [Parameter]
 public string? ValuePlaceHolder { get; set; }
 bool _isKeyEditingEnable = false;
 [Parameter]
 public bool IsKeyEditingEnable ...
 [Parameter]
 public EventCallback<bool>?
 IsKeyEditingEnableChanged{get; set;}
 private string dataDismiss = string.Empty;
 public EditFormDialog() {
 ModelData = new();
 }
 private void OnClickClose() {
 OnClose?.Invoke();
 }
 private void OnClickSave() {
 SetSaveButtonText();
 }
 private async Task HandleValidSubmit() {
 if (OnSaveAsync != null && ModelData.IsChanged) {
 await OnSaveAsync(ModelData.Key, ModelData.Value);
 ModelData.IsChanged = false;
 }
  }
 private void KeyHandler() {
 SetSaveButtonText(true);
 }
 private void SetSaveButtonText(bool changed = false) {
 if (ModelData == null) return;
 if (!ModelData.IsValid || changed) {
 dataDismiss = string.Empty;
 SaveButtonText = "Save";
 }
 else {
 dataDismiss = "modal";
 SaveButtonText = "Close";
 }
 }
}
```
Мы можем обратиться к параметрам компонента EditFormDialog<TItem> в таблице 10.2.

|Параметр|Описание|
|:--------|:----------|
|Id|Идентификатор диалога. Это используется Bootstrap.|
|ChildContent|Фрагменты рендеринга дочернего содержимого.|
|OnClose|Обратный вызов для кнопки «Закрыть».|
|OnSaveAsync|Обратный вызов для кнопки «Сохранить».|
|CloseButtonText|Текст кнопки «Закрыть».|
|SaveButtonText|Текст кнопки Сохранить.|
|ModelData|Данные модели привязаны к EditForm.|
|KeyPlaceHolder|Заполнитель ключа.|
|ValuePlaceHolder|Заполнитель значения|
|IsKeyEditingEnable|Включить или отключить редактирование ключей|
|IsKeyEditingEnableChanged |Обратный вызов для двух привязок IsKeyEditingEnable|

Таблица 10.2: Параметры компонента EditFormDialog<TItem>

После того, как мы создали компонент EditFormDialog<TItem>, мы выполнили всю оптимизацию
нашего кода. Давайте рассмотрим окончательный код Items (листинг 10.12) и ItemDetail (листинг
10.13) стр.:

**Листинг 10.12: Items.razor (https://epa.ms/Items10-12)**

```
@page "/group"
@page "/group/{SelectedItemId}"
@using System.Diagnostics
@using PassXYZLib
<Navbar ParentLink="@selectedItem?.GetParentLink()"
 Title="@Title" ❶
 DialogId="@_dialogEditId"
 OnAddClick="@(() =>
 {_isNewItem=true;
 currentItem.Data=listGroupItem=_newItem;
 _newItem.Name="";_newItem.Notes="";})" />
<ListView Items="items"> ❷
 <Row Context="item">
<img src="@item.GetIcon()" alt="twbs"
 width="32" height="32"
 class="rounded-circle flex-shrink-0 float-start">
<a href="@item.GetActionLink()"
 class="list-group-item ...">
 <div class="d-flex"><div>
 <h6 class="mb-0">@item.Name</h6>
 <p class="mb-0 opacity-75">@item.Description</p>
 </div></div>
 </a>
<Dropdown OnClick="@(() => ❸
 currentItem.Data=listGroupItem=item)">
 <MenuItem Id="@_dialogEditId" OnClick="@(() =>
 _isNewItem=false)">Edit</MenuItem>
 <MenuItem Id="@_dialogDeleteId">Delete</MenuItem>
 </Dropdown>
 </Row>
 </ListView>
<EditFormDialog Id="@_dialogEditId" ❹
 ModelData="@currentItem" IsKeyEditingEnable="true"
 OnSaveAsync="UpdateItemAsync" KeyPlaceHolder="Item name"
 ValuePlaceHolder="Pleae provide a description">
 @if (_isNewItem) {
<InputSelect @bind-Value="_newItem.SubType"
 class="form-select">
 <option selected value=@ItemSubType.Group>
 @ItemSubType.Group</option>
 <option value=@ItemSubType.Entry>
 @ItemSubType.Entry</option>
 <option value=@ItemSubType.PxEntry>
 @ItemSubType.PxEntry</option>
 <option value=@ItemSubType.Notes>
 @ItemSubType.Notes</option>
 </InputSelect>
 }
</EditFormDialog>
<CascadingValue Value="@_dialogDeleteId" Name="Id">
<ConfirmDialog Title=@listGroupItem.Name ❺
 OnConfirmClick="DeleteItemAsync" />
</CascadingValue>
```

В окончательном коде Items.razor мы используем Navbar ❶ для создания панели навигации. В теле
странице мы используем компонент ListView ❷ для отображения списка элементов. Для каждого элемента шаблон пользовательского интерфейса
определяется в свойстве Row. В шаблоне пользовательского интерфейса мы отображаем имя элемента, описание и контекст.
меню. В контекстном меню мы используем компонент Dropdown ❸ для поддержки редактирования или удаления
элемент. Для действий «Добавить», «Изменить» или «Удалить» EditorFormDialog ❹ или ConfirmDialog ❺
используется для выполнения соответствующих действий.
В ItemDetail.razor код похож на Items.razor:

** Листинг 10.13: ItemDetail.razor (https://epa.ms/ItemDetail10-13)**

```
@page "/entry/{SelectedItemId}"
@namespace PassXYZ.Vault.Pages
 <!-- Back button and title -->
<Navbar ParentLink="@selectedItem?.GetParentLink()" ①
 Title="@selectedItem?.Name" DialogId="@_dialogEditId"
 OnAddClick="@(() => {_isNewField=true;
 currentField.Data=listGroupField=_newField;_
 newField.Key="";_newField.Value="";})" />
<!-- List view with context menu -->
<ListView Items="fields"> ②
 <Row Context="field"> ③
 @if (field.ShowContextAction == null) {
 <span class="oi oi-pencil" aria-hidden="true"></span>
 <div class="d-flex gap-2 w-100
 justify-content-between">
 <div>
 <h6 class="mb-0">@field.Key</h6>
 <p class="mb-0">@field.Value</p>
 </div>
 </div>
 <Dropdown OnClick="@(() =>
 {currentField.Data=listGroupField=field;})">
 <MenuItem Id="@_dialogEditId" OnClick="@(() =>
 _isNewField=false)">Edit</MenuItem>
 <MenuItem Id="@_dialogDeleteId">Delete</MenuItem>
 @if (field.IsProtected) {
 <MenuItem OnClick="OnToggleShowPassword">
 @(field.IsHide ? "Show":"Hide")</MenuItem>
 }
 </Dropdown>
 }
 </Row>
 <Footer>@((MarkupString)notes)</Footer> ④
</ListView>
<!-- Editing Modal -->
<EditFormDialog Id="@_dialogEditId" ⑤
 ModelData="@currentField"
                IsKeyEditingEnable=@_isNewField
 OnSaveAsync="UpdateFieldAsync"
 KeyPlaceHolder="Field name"
 ValuePlaceHolder="Field content">
 @if (_isNewField) {
 <div class="form-check">
 <input class="form-check-input" type="checkbox"
 @bind="listGroupField.IsProtected"
 id="flexCheckDefault">
 <label class="form-check-label"
 for="flexCheckDefault">
 Password
 </label>
 </div>
 }
</EditFormDialog>
<!-- Deleting Modal -->
<CascadingValue Value="@_dialogDeleteId" Name="Id">
 <ConfirmDialog Title=@listGroupField.Key ⑥
 OnConfirmClick="DeleteFieldAsync" />
</CascadingValue>
```

Существует панель навигации с использованием панели навигации ①. Мы используем ListView ② для отображения полей записи,
которые включают шаблон строки ③ и шаблон нижнего колонтитула ④. В шаблоне Row содержимое
поле отображается, и каждая строка имеет контекстное меню. Контекстное меню включает в себя меню из трех
действия (Редактировать, Удалить и Показать). Действие Edit связано с диалоговым окном EditFormDialog.
диалоговое окно ⑤, а действие «Удалить» связано с диалоговым окном ConfirmDialog ⑥.
Теперь у нас есть работающее приложение для управления паролями, созданное с использованием пользовательского интерфейса Blazor. На этом мы заканчиваем это
главу и часть 2 этой книги.

# Краткое содержание

В этой главе мы продолжим нашу работу по оптимизации реализации нашего пользовательского интерфейса, создав больше Razor.
компоненты. Мы представили дополнительные темы, такие как шаблонные компоненты и использование универсальных типов.
в компоненте Razor. Мы также представили встроенные компоненты Blazor и использовали эти компоненты.
для поддержки проверки данных в нашем приложении. Мы разработали расширенную версию редактора значений ключей, используя
РедактироватьФорму. Поняв дополнительные темы о компонентах Razor, мы теперь можем
создавать более мощные компоненты Razor.

Мы завершили вторую часть этой книги. Мы перейдем к части 3 этой книги, чтобы познакомиться с модульными тестами.
и развертывание приложений .NET MAUI. Мы научимся реализовывать модульные тесты для .NET.
MAUI в следующей главе, и как развернуть наше приложение в разных магазинах приложений в главе 12,
Подготовка к развертыванию в магазинах приложений.
Пожалуйста, не переключайтесь!

# Дальнейшее чтение

  * Выпадающий список — это компонент Bootstrap.

  * https://getbootstrap.com/docs/5.1/components/dropdowns/

  * Modal — это модальный компонент Bootstrap.

  * https://getbootstrap.com/docs/5.1/components/modal/

  * Формы ASP.NET Core Blazor и компоненты ввода

  * https://learn.microsoft.com/en-us/aspnet/core/blazor/forms-andinput-components?view=aspnetcore-6.0











































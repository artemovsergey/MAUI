# Дизайн пользовательского интерфейса с помощью XAML

В предыдущей главе мы создали новый проект .NET MAUI под названием PassXYZ.Vault. мы начнем
улучшите его с помощью возможностей, которые мы будем осваивать в этой книге. В этой главе мы будем использовать
шаблон master-detail и XAML для разработки и создания пользовательского интерфейса нашего приложения.

В этой главе будут рассмотрены следующие темы, связанные с проектированием пользовательского интерфейса с помощью XAML:

* Как создать страницу XAML

* Базовый синтаксис XAML

* Расширение разметки XAML

* Как спроектировать пользовательский интерфейс с помощью шаблона master-detail

* Локализация приложения .NET MAUI

Расширяемый язык разметки приложений (XAML) — это язык на основе XML, который используется для
определение пользовательских интерфейсов для Windows Presentation Foundation (WPF), универсальной платформы Windows
(UWP), Xamarin.Forms и .NET MAUI. Диалекты XAML на этих платформах имеют одинаковые
синтаксисом, но различаются словарным запасом.

XAML позволяет разработчикам определять пользовательские интерфейсы на языке разметки на основе XML, а не в коде.
Можно написать все наши пользовательские интерфейсы в коде, но дизайн пользовательского интерфейса с помощью XAML будет
быть более кратким и более визуально последовательным. XAML не может содержать код. Это недостаток,
но это также и преимущество, поскольку заставляет разработчика отделить логику кода от пользовательского интерфейса.
дизайн. XAML хорошо подходит для шаблона Model-View-ViewModel (MVVM), который мы изучим
о позже в этой книге.

# Технические требования

Для тестирования и отладки исходного кода в этой главе вам необходимо установить Visual Studio 2022 на
ваш ПК или Mac. Пожалуйста, обратитесь к разделу Настройка среды разработки в Главе 1, Получение
Начал с .NET MAUI, подробнее.
Исходный код для этой главы доступен в следующем репозитории GitHub:
https://github.com/PacktPublishing/.NET-MAUI-Cross-PlatformApplication-Development/tree/main/Chapter03

# Создание XAML-страницы

Прежде чем мы изучим синтаксис XAML, давайте узнаем, как создать страницу XAML в Visual Studio и с помощью
командная строка дотнет.
Чтобы создать страницу XAML с помощью Visual Studio, мы можем щелкнуть правой кнопкой мыши узел проекта. После выберите Добавить
> Новый элемент…; мы увидим то, что показано на рисунке 3.1:

![изображение](https://user-images.githubusercontent.com/26972859/231754789-552047a2-6e00-4a53-ba64-d6b597870a74.png)

Рисунок 3.1: Добавление страницы XAML

На этом экране выберите «Страница содержимого» из шаблонов и нажмите «Добавить». Это создаст пару файлов
– файл XAML и файл кода программной части C#.

Мы можем сделать то же самое с помощью команды dotnet.

Чтобы найти все шаблоны .NET MAUI, мы можем использовать команду dotnet, например, в консоли PowerShell:

```
dotnet new --list | findstr -i maui
.NET MAUI App maui [C#] MAUI/...
.NET MAUI Blazor App maui-blazor [C#] MAUI/...
.NET MAUI Class Library mauilib [C#] MAUI/...
.NET MAUI ContentPage (C#) maui-page-csharp [C#] MAUI/...
.NET MAUI ContentPage (XAML) maui-page-xaml [C#] MAUI/...
.NET MAUI ContentView (C#) maui-view-csharp [C#] MAUI/...
.NET MAUI ContentView (XAML) maui-view-xaml [C#] MAUI/...
.NET MAUI ResourceDictionary (XAML) maui-dict-xaml [C#] MAUI/...

```

Из предыдущего вывода видно, что краткое имя страницы содержимого XAML:
maui-страница-xaml. Мы можем создать страницу XAML с помощью следующей команды:

```
dotnet new maui-page-xaml -n ItemsPage
The template ".NET MAUI ContentPage (XAML)" was created
successfully.
Processing post-creation actions…
The post action 84c0da21-51c8-4541-9940-6ca19af04ee6 is not
supported.
Description: Opens NewPage1.xaml in the editor.
```
Два файла с именами ```ItemsPage.xaml``` и ``ItemsPage.xaml.cs``` будут созданы
предшествующая команда.

# XAML-синтаксис

Поскольку XAML — это язык на основе XML, нам необходимо понимать основной синтаксис XML. XML или
Файл XAML включает в себя иерархию элементов. Каждый элемент может иметь связанные с ним атрибуты.
Давайте рассмотрим App.xaml в проекте, который мы создали в главе 2 «Создание нашего первого .NET MAUI».
Приложение, например:

**Листинг 3.1: App.xaml (https://epa.ms/App3-1)**

```xml
<?xml version = "1.0" encoding = "UTF-8" ?>
<Application xmlns="http://schemas.microsoft.com
 /dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/
 winfx/2009/xaml"
 xmlns:local="clr-namespace:PassXYZ.Vault"
 x:Class="PassXYZ.Vault.App">
 <Application.Resources>
 <ResourceDictionary...>
 </Application.Resources>
</Application>
```
Как показано в листинге 3.1, у нас есть элемент Application и связанные с ним атрибуты x:Class.
и xmlns:{префикс}. Давайте проанализируем этот пример, чтобы понять элементы и атрибуты XML.

# Элемент

Синтаксис элемента включает начальный и конечный теги, такие как тег приложения:

```xml
<Application></Application>
```
Для пустого элемента конечный тег можно опустить, добавив косую черту в конце начального.
тег, например:

```<Application />```

Когда мы упоминаем элемент XML, мы можем использовать в качестве терминов элемент, узел и тег. Когда мы говорим
элемент, мы имеем в виду начальный тег и конечный тег этого элемента вместе. Когда мы говорим тег,
мы имеем в виду либо начальный, либо конечный тег элемента. Когда мы говорим узел, мы имеем в виду
элемент и все его внутреннее содержимое, включая все дочерние элементы.

Документ XAML состоит из множества вложенных элементов. Есть только один верхний элемент, который
называется корневым элементом. В .NET MAUI или ```Xamarin.Forms``` корневым элементом обычно является ```Application```,
```ContentPage```, ```Shell``` или ```ResourceDictionary```.
Для каждого файла XAML у нас обычно есть соответствующий файл кода программной части C#. Давайте рассмотрим файл кода программной части в листинге 3.2:

**Листинг 3.2: App.xaml.cs (https://epa.ms/App3-2)**

```Csharp
using PassXYZ.Vault.Services;
using PassXYZ.Vault.Views;
namespace PassXYZ.Vault;
public partial class App : Application { ➊
 public App() {
 InitializeComponent(); ➋
 Routing.RegisterRoute(nameof(ItemDetailPage),
 typeof(ItemDetailPage));
 Routing.RegisterRoute(nameof(NewItemPage),
 typeof(NewItemPage));
 DependencyService.Register<MockDataStore>();
 MainPage = new AppShell();
 }
 private async void OnMenuItemClicked(System.Object
 sender, System.EventArgs e) {
 await Shell.Current.GoToAsync("//LoginPage");
 }
}
I
```
В XAML элементы обычно представляют фактические классы C#, экземпляры которых создаются для объектов во время выполнения.
Вместе файлы XAML и кода программной части определяют полный класс. Например, App.xaml (список
3.1) и App.xaml.cs (листинг 3.2) определяют класс App, который является подклассом Application.
➊ Класс App, полное имя которого PassXYZ.Vault.App, совпадает с классом, определенным в
XAML-файл с использованием атрибута x:Class:

```
x:Class="PassXYZ.Vault.App"
```

➋ В конструкторе класса App вызывается метод InitializeComponent() для загрузки
XAML и проанализируйте его. На этом этапе создаются элементы пользовательского интерфейса, определенные в файле XAML. Мы можем получить доступ
эти элементы пользовательского интерфейса по имени, определенному атрибутом x:Name, как мы вскоре увидим.

# Атрибут

Элемент может иметь несколько уникальных атрибутов. Атрибут предоставляет дополнительную информацию о
XML-элементы. XML-атрибут — это пара «имя-значение», прикрепленная к элементу. В XAML элемент
представляет класс C#, а атрибуты представляют членов этого класса:

```xml
<Button x:Name="loginButton" VerticalOptions="Center" IsEnabled="True" Text="Login"/>
```
Как мы видим, четыре атрибута — x:Name, VerticalOptions, IsEnabled и Text — являются
определено для элемента Button. Чтобы определить атрибут, нам нужно указать имя атрибута и
значение со знаком равенства. Нам нужно поместить значение атрибута в двойные или одинарные кавычки. Например,
IsEnabled — это имя атрибута, а «True» — это значение атрибута.
В этом примере атрибут x:Name является специальным. Это не относится к члену Button
класс, но он ссылается на переменную, содержащую экземпляр класса Button. Без х:Имя
будет создан анонимный экземпляр класса Button. С атрибутом x:Name
объявленный, мы можем обратиться к экземпляру класса Button, используя переменную loginButton в
файл кода программной части.

# Пространства имен XML и пространства имен XAML

В XML или XAML мы можем объявлять пространства имен точно так же, как в C#. Пространства имен помогают группировать элементы
и атрибуты, чтобы избежать конфликтов имен, когда одно и то же имя используется в другой области. Пространства имен
можно определить с помощью атрибута xmlns со следующим синтаксисом:

```xmlns:prefix="identifier"```

Определение пространства имен XAML состоит из двух компонентов: префикса и идентификатора. И префикс, и
идентификатор может быть любой строкой, разрешенной пространствами имен W3C в спецификации XML 1.0. Если
префикс опущен, пространство имен является пространством имен по умолчанию. В листинге 3.1 следующее пространство имен
по умолчанию:

```xmlns="http://schemas.microsoft.com/dotnet/2021/maui"```

Это пространство имен по умолчанию позволяет нам обращаться к классам .NET MAUI без префикса, например ```ContentPage```,
Этикетка или кнопка.

Для объявления пространства имен используйте префикс x, например:

``xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"```

Объявление пространства имен xmlns:x указывает элементы и атрибуты, присущие XAML.
Это пространство имен является одним из наиболее важных, которые мы будем использовать в дизайне пользовательского интерфейса с помощью XAML. К
понять, как его использовать, мы можем создать страницу контента с той же структурой, используя как C#, так и XAML.
Чтобы создать страницу содержимого в XAML, мы можем использовать команду dotnet, как делали это ранее:

```
dotnet new maui-page-xaml -n NewPage1
The template ".NET MAUI ContentPage (XAML)" was created
successfully.
Processing post-creation actions...
The post action 84c0da21-51c8-4541-9940-6ca19af04ee6 is not
supported.
Description: Opens NewPage1.xaml in the editor.

```

Предыдущая команда создает файл XAML (NewPage1.xaml) и файл кода программной части C#.
(NewPage1.xaml.cs). Мы можем обновить файл XAML следующим образом. Поскольку мы ничего не добавляем
логики, в этом примере мы можем игнорировать файл кода программной части (NewPage1.xaml.cs):

**NewPage1.xaml**

```xml
<ContentPage
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 x:Class="MauiApp1.NewPage1" ❶
 Title="NewPage1">
 <StackLayout x:Name="layout"> ➋
 <Label Text="Welcome to .NET MAUI!"
 VerticalOptions="Center"
 HorizontalOptions="Center" />
<BoxView HeightRequest="150" WidthRequest="150"
 HorizontalOptions="Center">
 <BoxView.Color>
 <Color x:FactoryMethod="FromRgba"> ➌
 <x:Arguments> ➍
 <x:Int32>192</x:Int32> ❺
 <x:Int32>75</x:Int32>
 <x:Int32>150</x:Int32>
 <x:Int32>128</x:Int32>
 </x:Arguments>
 </Color>
 </BoxView.Color>
 </BoxView>
 </StackLayout>
</ContentPage>
```

**NewPage1.xaml.cs**

```Csharp
namespace MauiApp1;
public partial class NewPage1 : ContentPage {
 public NewPage1() {
 InitializeComponent();
 }
}
```
Мы также можем сгенерировать страницу содержимого только в коде C#. Давайте создадим страницу контента, используя
следующая команда:

```Csharp
dotnet new maui-page-csharp -n NewPage1
The template ".NET MAUI ContentPage (C#)" was created
successfully.
Processing post-creation actions...
The post action 84c0da21-51c8-4541-9940-6ca19af04ee6 is not
supported.
Description: Opens NewPage1.cs in the editor.
```
Предыдущая команда создает страницу содержимого в C#-файле NewPage1.cs. Мы можем реализовать
та же логика в С#, например:

**NewPage1.cs**

```Csharp
namespace MauiApp1;
public class NewPage1 : ContentPage { ➀
 public NewPage1() {
 var layout = new StackLayout ➁
 {
 Children = {
 new Label { Text = "Welcome to .NET MAUI!" },
 new BoxView {
 HeightRequest = 150,
 WidthRequest = 150,
 HorizontalOptions = LayoutOptions.Center,
 Color = Color.FromRgba(192, 75, 150, 128) ➂
 }
 }
 };
 Content = layout;
 }
}
```
Здесь мы дважды создали одну и ту же страницу содержимого (NewPage1) как в XAML, так и в C#. XAML не может
содержат программную логику, но его можно использовать для объявления элементов пользовательского интерфейса и размещения логики
в файле кода программной части C#. Внутри NewPage1 мы создали страницу содержимого, содержащую Label и
Элементы BoxView. В версии XAML мы использовали атрибуты, определенные в пространстве имен xmlns:x.
чтобы указать элементы пользовательского интерфейса:
* ❶ Страница содержимого с именем NewPage1 создается в XAML. Атрибут x:Class указывает
имя класса, то есть NewPage1. В файле кода программной части C# частичный класс NewPage1
определено. В конструкторе вызывается метод InitializeComponent() для загрузки
пользовательский интерфейс, определенный в XAML.

* ➀ Мы можем создать ту же страницу содержимого, NewPage1, используя C# непосредственно как производный класс
страницы содержимого.
Мы определили StackLayout на странице содержимого, и имя переменной, относящееся к нему, — это макет.
в версиях XAML и C#:

* ➋ В XAML x:Name указывает имя переменной StackLayout.

* ➁ В C# мы можем объявить переменную как layout.

* ➌ x:FactoryMethod указывает фабричный метод, который можно использовать для инициализации объекта.

* ➂ В коде C# мы можем вызвать функцию Color.FromRgba() напрямую, но мы должны использовать
атрибут x:FactoryMethod в XAML, чтобы сделать то же самое.

* ➍ x:Arguments используется для указания аргументов при вызове Color.FromRgba() в XAML.

* ❺ x:Int используется для указания целочисленных аргументов. Для других типов данных мы можем использовать x:Double,
xChar или x:Boolean.

```xmlns:local="clr-namespace:PassXYZ.Vault"```

Чтобы объявить пространство имен CLR, мы можем использовать clr-namespace: или using:. Если пространство имен CLR
определена в другой сборке, Assembly= используется для указания сборки, содержащей
указанное пространство имен CLR. Значением является имя сборки без расширения файла. В нашем
случае оно было опущено, поскольку пространство имен PassXYZ.Vault находится в той же сборке, что и наша
код приложения.
Позже в этой главе мы увидим больше вариантов использования пространств имен.

## Расширения разметки XAML

Несмотря на то, что мы можем инициализировать экземпляры класса, используя элементы XAML, и устанавливать члены класса, используя
Атрибуты XAML, мы можем установить их только как предопределенные константы в документе XAML.
Чтобы повысить мощность и гибкость XAML, позволяя устанавливать атрибуты элементов из множества
источников, мы можем использовать расширения разметки XAML. С расширениями разметки XAML мы можем установить
атрибут значений, определенных где-то еще, или результат, обработанный кодом во время выполнения.
Расширения разметки XAML можно указать в фигурных скобках, как показано здесь:

```xml
<Button Margin="0,10,0,0" Text="Learn more"
 Command="{Binding OpenWebCommand}"
 BackgroundColor="{DynamicResource PrimaryColor}"
 TextColor="White" />
```
В предыдущем коде для атрибутов BackgroundColor и Command было задано значение
расширения разметки. Для BackgroundColor установлено значение DynamicResource, а для команды
задан метод OpenWebCommand, определенный в модели представления.
В следующих нескольких главах мы будем использовать расширения разметки для поддержки привязки данных и ResourceDictionary.
Мы узнаем больше о расширениях разметки, когда будем их использовать позже. Пожалуйста, обратитесь к следующему
Документация Microsoft, чтобы узнать больше об этом: https://learn.microsoft.
com/en-us/dotnet/maui/xaml/markup-extensions/consume.
Теперь, когда мы изучили основы XAML, мы можем использовать его для работы над дизайном пользовательского интерфейса.

# Основной дизайн пользовательского интерфейса

Мы получили базовые знания о XAML в предыдущих разделах. Теперь давайте проведем некоторое время
изучаем приложение, которое мы собираемся разработать.
Шаблон master-detail обычно используется в дизайне пользовательского интерфейса. Можно найти множество примеров
в часто используемых приложениях. Например, в почтовом приложении Windows список сообщений электронной почты отображается в
основной вид, а также сведения о выбранном электронном письме:

![изображение](https://user-images.githubusercontent.com/26972859/231760460-4e03aca0-7eb4-4c38-8a58-6927bb9bd13c.png)

Рисунок 3.2: Почта в Windows

На рис. 3.2 в конструкции есть три панели. Левая панель выглядит как панель навигации. Когда
мы выбираем папку из левой панели, список писем отображается в средней панели. В настоящее время
выбранный адрес электронной почты отображается на правой панели.

**Примечание:**

Ящики навигации обеспечивают доступ к пунктам назначения и функциям приложения, таким как меню в
среда рабочего стола. Обычно он выдвигается слева и запускается нажатием значка.
в верхнем левом углу экрана. Он отображает список вариантов для навигации и широко используется
в дизайне мобильных и веб-интерфейсов. Xamarin.Forms или .NET MAUI Shell использует навигацию
ящики в качестве методов навигации верхнего уровня.

Первоначальный дизайн пользовательского интерфейса KeePass, показанный на рис. 3.3, также использует три панели (левую, правую и нижнюю) на
главная страница. Левая панель представляет собой классическое древовидное представление, которое действует как панель навигации. Правая панель
используется для отображения списка записей паролей. Нижняя панель используется для отображения сведений о записи:

![изображение](https://user-images.githubusercontent.com/26972859/231760871-93e44fd3-fe9a-4ff9-86cf-feebcc8758dd.png)

Рисунок 3.3: Дизайн пользовательского интерфейса KeePass

Шаблон master-detail хорошо работает с широким диапазоном типов устройств и размеров дисплеев.
Учитывая различные размеры дисплея, можно использовать два популярных режима:

* Side-by-side (Бок о бок)

* Stacked (С накоплением)

# Side-by-side

Когда у нас много горизонтального пространства с большим дисплеем, подход «бок о бок» обычно является оптимальным.
хороший выбор. Хорошими примерами являются приложение Mail на рис. 3.2 и приложение KeePass на рис. 3.3. В этом
режиме мы можем видеть как основной вид, так и подробный вид одновременно.

# Stacked

Когда мы используем мобильное устройство, у нас обычно меньше размер экрана, а вертикальное пространство больше.
чем горизонтальный. В этом случае более предпочтительным является многоуровневый подход.
В многоуровневом режиме основной вид получает полноэкранное пространство. Затем, когда выбор сделан, деталь
view получает полноэкранное пространство:

![изображение](https://user-images.githubusercontent.com/26972859/231761104-5a333eb2-40a8-4919-84cc-18bce6af8565.png)

Рисунок 3.4: PassXYZ.Vault

На рисунке 3.4 мы можем видеть, как мы можем перемещаться по нашему приложению с точки зрения пользователя. У нас есть список
всплывающие элементы, которые мы можем выбрать:

* About

* Browse

* Logout

Когда мы выбираем «Обзор», мы видим список элементов на главной странице (ItemsPage). На этом
странице, если мы выберем элемент, мы перейдем на страницу сведений об элементе (ItemDetailPage). Если мы хотим
выбрать другой элемент, мы должны вернуться на главную страницу и выбрать другой элемент.
Мы обсудим всплывающие элементы в главе 5 «Введение в оболочку и навигацию». В этом разделе мы будем
просмотрите реализацию ItemsPage и ItemDetailPage. Однако, прежде чем мы углубимся в
детали, давайте изучим макет, который является контейнером элементов пользовательского интерфейса.

# Элементы управления в .NET MAUI

Пользовательский интерфейс приложения .NET MAUI создается с помощью элементов управления. Эти элементы управления можно классифицировать
как страницы, макеты и представления.

Страница — это элемент пользовательского интерфейса верхнего уровня, который обычно занимает все экраны или окна. Мы
в начале представил, как создавать страницы с помощью шаблона Visual Studio или команды dotnet
этой главы. Каждая страница обычно содержит по крайней мере один элемент макета, который используется для организации
дизайн элементов управления на странице.

Представления — это объекты пользовательского интерфейса для представления, редактирования или запуска команд в дизайне пользовательского интерфейса. Пожалуйста
обратитесь к следующему документу Microsoft об элементах управления в .NET MAUI: https://learn.
microsoft.com/en-us/dotnet/maui/user-interface/controls/.

Мы представим макеты в следующем разделе. В этом разделе мы рассмотрим некоторые элементы управления, которые
часто использоваться в этой книге. Пожалуйста, обратитесь к предыдущей ссылке для более подробной информации.

**Label**

Метка используется для отображения однострочного или многострочного текста. Он может отображать текст в определенном формате, например
как цвет, пространство, оформление текста и даже текст HTML. Для создания ярлыка мы можем использовать самый простой
формат, например:

```<Label Text="Привет, мир" />```

**Image**

В дизайне пользовательского интерфейса мы обычно используем значки для украшения других элементов управления или отображения изображений в качестве
фоны. Элемент управления Image может отображать изображение из локального файла, URI, встроенного
ресурс или поток. В следующем коде показан пример создания элемента управления Image в
самая простая форма:

```<Image Source="dotnet_bot.png" />```

**Editor**

В нашем приложении пользователям необходимо ввести или отредактировать одну строку текста или несколько строк текста. У нас есть два
для этой цели: Editor и Entry.

Редактор можно использовать для ввода или редактирования нескольких строк текста. Ниже приведен пример
Управление редактором:

```<Editor Placeholder="Введите здесь свое описание" />```

**Entry**

Ввод можно использовать для ввода или редактирования одной строки текста. Чтобы создать страницу входа, мы можем использовать Entry
управления для ввода имени пользователя и пароля. Когда пользователи взаимодействуют с записью, поведение
клавиатуру можно настроить с помощью свойства Keyboard. Когда пользователи вводят свои пароли,
свойство IsPassword можно настроить так, чтобы оно отражало типичное поведение на странице входа. Следующее
пример ввода пароля:

```<Entry Placeholder="Введите пароль" Keyboard="Text" IsPassword="True" />```

**ListView**

В дизайне пользовательского интерфейса распространенным вариантом использования является отображение набора данных. В .NET MAUI
для отображения набора данных можно использовать несколько элементов управления, таких как CollectionView, ListView,
и КарусельВью. В нашем приложении мы будем использовать ListView для отображения записей паролей, групп и
содержание записи. Мы представим использование ListView, когда представим ItemsPage.

# Layouts в .NET MAUI

Для разработки элементов пользовательского интерфейса в представлении или на странице мы обычно используем элемент управления макетом в качестве контейнера для
определить формат презентации. Есть несколько макетов, которые являются основными для .NET MAUI.

# StackLayout

StackLayout упорядочивает элементы в одномерный стек по горизонтали или по вертикали. Это
часто используется как родительский макет, который содержит другие дочерние макеты. Ориентация по умолчанию — вертикальная.
Однако мы не должны использовать StackLayout для создания макета, похожего на таблицу, с помощью вложенных
StackLayout горизонтально и вертикально. В следующем коде показан пример плохой практики:

```xml
<StackLayout>
 <StackLayout Orientation="Horizontal">
 <Label Text="Name:" />
 <Entry Placeholder="Enter your name" />
 </StackLayout>
 <StackLayout Orientation="Horizontal">
 <Label Text="Age:" />
 <Entry Placeholder="Enter your age" />
  </StackLayout>
 <StackLayout Orientation="Horizontal">
 <Label Text="Address:" />
 <Entry Placeholder="Enter your address" />
 </StackLayout>
</StackLayout>
```
В предыдущем коде мы использовали StackLayout в качестве родительского макета, где ориентация по умолчанию
вертикальный. Затем мы вложили несколько элементов управления StackLayout с горизонтальной ориентацией для создания
форма для заполнения. Для этого мы должны использовать элемент управления Grid.
StackLayout — часто используемый элемент управления макетом. Существует два подтипа StackLayout, которые
помогите нам напрямую спроектировать макет по горизонтали или вертикали

**HorizontalStackLayout**

HorizontalStackLayout — это одномерный горизонтальный стек. Например, мы можем сгенерировать
такой ряд:

```xml
 <HorizontalStackLayout>
 <Label Text="Name:" />
 <Entry Placeholder="Enter your name" />
 </HorizontalStackLayout>
```
**VerticalStackLayout**

VerticalStackLayout is a one-dimensional vertical stack. For example, we can display an error
message after a form is submitted with an error like so:

```xml
<VerticalStackLayout>
 <Label Text="The Form Is Invalid" />
 <Button Text="OK"/>
</VerticalStackLayout>
```

**Grid**

Сетка организует элементы в строки и столбцы. Мы можем указать строки и столбцы с помощью
Свойства ```RowDefinitions``` и ```ColumnDefinitions```. В предыдущем примере мы создали
форма, в которой пользователь может ввести свое имя, возраст и адрес, используя вложенный ```StackLayout```. Мы можем
сделайте это в макете сетки следующим образом:

```xml
<Grid>
 <Grid.RowDefinitions>
  <RowDefinition Height="50" />
 <RowDefinition Height="50" />
 <RowDefinition Height="50" />
 </Grid.RowDefinitions>
 <Grid.ColumnDefinitions>
 <ColumnDefinition Width="Auto" />
 <ColumnDefinition />
 </Grid.ColumnDefinitions>
 <Label Text="Name:" />
 <Entry Grid.Column="1"
 Placeholder="Enter your name" />
 <Label Grid.Row="1" Text="Age:" />
 <Entry Grid.Row="1" Grid.Column="1"
 Placeholder="Enter your age" />
 <Label Grid.Row="2" Text="Address:" />
 <Entry Grid.Row="2"
 Grid.Column="1"
 Placeholder="Enter your address" />
</Grid>
```
В предыдущем примере мы создали макет сетки с двумя столбцами и тремя строками.

# FlexLayout

FlexLayout похож на StackLayout тем, что отображает дочерние элементы либо горизонтально,
или вертикально в стопке. Разница в том, что FlexLayout также может обернуть своих дочерних элементов, если их слишком много.
много, чтобы поместиться в одну строку или столбец. В качестве примера мы можем создать FlexLayout с пятью метками.
в ряд. Если мы укажем свойство Direction как Row, эти метки будут отображаться в одной строке.
Мы также можем указать свойство Wrap, которое может привести к переносу элементов на следующую строку, если есть
слишком много элементов, чтобы поместиться в ряд:

```xml
<FlexLayout Direction="Row" Wrap="Wrap">
 <Label Text="Элемент 1" Padding="10"/>
 <Label Text="Элемент 2" Padding="10"/>
 <Label Text="Элемент 3" Padding="10"/>
 <Label Text="Элемент 4" Placeholder="10"/>
 <Label Text="Элемент 5" Placeholder="10"/>
 </FlexLayout>
```

# AbsoluteLayout

AbsoluteLayout — это тип макета, который мы можем использовать для позиционирования элементов по осям X, Y, ширине и высоте.
Позиции X и Y относятся к верхнему левому углу родительского элемента. Ширина и высота есть
касается размера дочернего элемента.

В следующем примере мы создаем элемент управления BoxView в макете (0, 0) с шириной
и высота равна 10:

```xml
<AbsoluteLayout Margin="20">
 <BoxView Color="Silver"
 AbsoluteLayout.LayoutBounds="0, 0, 10, 10" />
</AbsoluteLayout>
```
# Навигация в дизайне пользовательского интерфейса master-detail

Как показано на рис. 3.4, в нашей навигации мы используем многоуровневый шаблон master-detail. Eсть
всплывающее меню для отображения списка страниц. В списке страниц страница типа ItemsPage используется для
отобразить список введенных паролей. Когда пользователи нажимают на запись, отображаются сведения о вводе пароля.
показано в ItemDetailPage.

Давайте рассмотрим реализацию ItemsPage и ItemDetailPage.

# ItemDetailPage

В нашем приложении ItemDetailPage является страницей подробностей шаблона master-detail и показывает содержимое
элемента. В ItemDetailPage мы просто представляем модель данных Item. Выглядит очень просто на
момент; мы будем улучшать его постепенно на протяжении всей книги:

**Листинг 3.3: Item.cs (https://epa.ms/Item3-3)**

```xml
using System;
namespace PassXYZ.Vault.Models {
 public class Item {
 public string Id { get; set; }
 public string Text { get; set; }
 public string Description { get; set; }
 }
}
```

Как показано в листинге 3.3, класс Item включает три свойства: ID, Text и Description.
Экземпляр Item загружается функцией LoadItemId() в ItemDetailViewModel, как
показано здесь. Мы обсудим шаблон MVVM в следующей главе:

```Csharp
public async void LoadItemId(string itemId) {
 try {
 var item = await DataStore.GetItemAsync
 (itemId);
 Id = item.Id;
 Text = item.Text;
 Description = item.Description;
 }
 catch (Exception) {
 Debug.WriteLine("Failed to Load Item");
 }
 }
```
После загрузки данных мы можем представить данные пользователю в ItemDetailPage.xaml,
как показано в листинге 3.4:

**Листинг 3.4: ItemDetailPage.xaml (https://epa.ms/ItemDetailPage3-4)**

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com
 /dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com
 /winfx/2009/xaml"
 x:Class="PassXYZ.Vault.Views.ItemDetailPage"
 Title="{Binding Title}">
 <StackLayout Spacing="20" Padding="15">
 <Label Text="Text:" FontSize="Medium" />
 <Label Text="{Binding Text}" FontSize="Small"/>
 <Label Text="Description:" FontSize="Medium" />
 <Label Text="{Binding Description}"
 FontSize="Small"/>
 </StackLayout>
</ContentPage>
```

В листинге 3.4 представлен XAML-файл ItemDetailPage. Страница содержимого сведений об элементе включает
экземпляр StackLayout и четыре экземпляра Label.

В StackLayout ориентация по умолчанию — вертикальная, поэтому элементы управления Label организованы вертикально.
на странице сведений об элементе (см. рис. 3.4). И текст, и описание связаны с моделью.
данные в модели представления через привязку данных. Мы представим привязку данных в следующей главе.

**ItemsPage**

ItemsPage — это главная страница шаблона master-detail в нашем приложении. Он отображает список элементов, которые
мы можем исследовать.

В листинге 3.5 показана реализация ItemsPage. Для отображения списка элементов используется элемент управления ListView.
использовал. ListView — это элемент управления, используемый для отображения прокручиваемого вертикального списка выбираемых элементов данных:

**Листинг 3.5: ItemsPage.xaml (https://epa.ms/ItemsPage3-5)**

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com
 /dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com
 /winfx/2009/xaml"
 x:Class="PassXYZ.Vault.Views.ItemsPage" ➊
 Title="{Binding Title}"
 xmlns:local="clr-namespace:
 PassXYZ.Vault.ViewModels" ❺
 xmlns:model="clr-namespace:PassXYZ.
 Vault.Models" ❻
 x:DataType="local:ItemsViewModel" ➋
 x:Name="BrowseItemsPage"> ➌
 <ContentPage.ToolbarItems...>
 <StackLayout>
 <ListView x:Name="ItemsListView" ➍
 ItemsSource="{Binding Items}"
 VerticalOptions="FillAndExpand"
 HasUnevenRows="False"
 RowHeight="84"
 RefreshCommand="{Binding LoadItemsCommand}"
 IsPullToRefreshEnabled="true"
 IsRefreshing="{Binding IsBusy,
 Mode=OneWay}"
 CachingStrategy="RetainElement"
 ItemSelected="OnItemSelected">
 <ListView.ItemTemplate>
 <DataTemplate...>
 </ListView.ItemTemplate>
 </ListView>
 </StackLayout>
</ContentPage>
```
Рассмотрим этот код более подробно:

➊ x:Class: используется для определения имени класса частичного класса между разметкой и файлом отделенного кода. PassXYZ.Vault.Views.ItemsPage — это имя класса, определенное здесь.

➌ x:Name: в то время как x:Class определяет имя класса в XAML, x:Name определяет имя экземпляра.
Мы можем обратиться к имени экземпляра BrowseItemsPage в файле кода программной части.

➋ x:DataType: когда мы устанавливаем x:DataType в соответствующий тип, определенный в модели представления,
можно включить скомпилированную привязку, что может значительно повысить производительность. Модель просмотра
здесь мы имеем в виду ItemsViewModel.
Помимо стандартного пространства имен, мы определили еще два пространства имен, чтобы мы могли обращаться к объектам
в представлении модель ❺ и модель ❻. Мы обсудим модель представления и модель в следующей главе.

➍ Мы определяем элемент управления ListView для отображения списка элементов. Есть много свойств в
Элемент управления ListView. Следующие свойства — это те, которые мы должны определить, чтобы использовать элемент управления ListView:

• ItemsSource типа Ienumerable определяет коллекцию отображаемых элементов.
Он привязывается к элементам, которые определены в модели представления.

• ItemTemplate типа DataTemplate указывает шаблон, применяемый к каждому элементу.
в коллекции элементов для отображения.

В листинге 3.5 DataTemplate свернут. Если мы расширим его, мы увидим следующий фрагмент кода.

Это реализация по умолчанию из шаблона Visual Studio. Внешний вид этих данных
шаблон недостаточно хорош, но мы можем его улучшить:

```xml
<DataTemplate>
 <ViewCell>
 <StackLayout Padding="10" x:DataType="model:Item">
 <Label Text="{Binding Text}"
 LineBreakMode="NoWrap"
 Style="{DynamicResource ListItemTextStyle}"
 FontSize="16" />
 <Label Text="{Binding Description}"
 LineBreakMode="NoWrap"
 Style="{DynamicResource
 ListItemDetailTextStyle}"
 FontSize="13" />
 </StackLayout>
 </ViewCell>
</DataTemplate>
```
Эта реализация DataTemplate включает ViewCell, состоящий из StackLayout с
два элемента управления Label. Мы можем видеть предварительный просмотр на рисунке 3.4.

Реализация DataTemplate должна ссылаться на класс Cell для отображения элементов. Есть встроенные
ячейки, которые можно использовать следующим образом:

• TextCell, который отображает основной и дополнительный текст в отдельных строках.

• ImageCell, который отображает изображение с основным и дополнительным текстом в отдельных строках.

• SwitchCell, который отображает текст и переключатель, который можно включить или выключить.

• EntryCell, отображающий метку и редактируемый текст.

• ViewCell — пользовательская ячейка, внешний вид которой определяется представлением. Этот тип клеток
следует использовать, когда вы хотите полностью определить внешний вид каждого элемента в ListView.
Как правило, SwitchCell и EntryCell используются только в TableView и не используются в
списокView.

Предварительный просмотр ViewCell в предыдущем фрагменте кода выглядит не очень хорошо. Это нелегко
различать текст и описание. В KeePass мы обычно прикрепляем к паролю иконку
вход. Мы можем улучшить его с помощью нового шаблона данных, например:

```xml
<DataTemplate>
 <ViewCell>
 <Grid Padding="10" x:DataType="model:Item" > ①
 <Grid.RowDefinitions> ②
 <RowDefinition Height="32" />
 <RowDefinition Height="32" />
 </Grid.RowDefinitions>
 <Grid.ColumnDefinitions>
 <ColumnDefinition Width="Auto" />
 <ColumnDefinition Width="Auto" />
 </Grid.ColumnDefinitions>
 <Grid Grid.RowSpan="2" Padding="10"> ③
 <Grid.ColumnDefinitions>
 <ColumnDefinition Width="32" />
 </Grid.ColumnDefinitions>
 <Image Grid.Column="0" Source="passxyz_logo.png"
 HorizontalOptions="Fill" VerticalOptions="Fill" />
 </Grid>
 <Label Text="{Binding Text}" Grid.Column="1"
 LineBreakMode="NoWrap" MaxLines="1"
 Style="{DynamicResource ListItemTextStyle}"
 FontAttributes="Bold" FontSize="Small" />
 <Label Text="{Binding Description}"
 Grid.Row="1" Grid.Column="1"
 LineBreakMode="TailTruncation" MaxLines="1"
 Style="{DynamicResource ListItemDetailTextStyle}"
 FontSize="Small" />
 </Grid>
 </ViewCell>
</DataTemplate>
```
Рассмотрим этот код более подробно:

• Чтобы ViewCell выглядел лучше, мы заменили класс layout из StackLayout.
к сетке. Сетка — это макет, который организует дочерние элементы в строки и столбцы.

• ② Поскольку мы хотим отобразить две строки со значком слева, мы создали сетку с двумя
столбцы и две строки, как показано здесь:

![изображение](https://user-images.githubusercontent.com/26972859/231764190-9a9ae4cc-b123-46be-b4cb-b81e76de60e1.png)

Рисунок 3.5: Схема записи или группы

Мы можем использовать разные стили шрифта для текста и описания, чтобы пользователи могли легко их различать.
их с визуальными эффектами.

③ Чтобы отобразить значок в центре первых двух столбцов, мы объединили две строки в
Управление сеткой. Мы можем использовать присоединенное свойство Grid.RowSpan для объединения строк.

Grid можно использовать как родительский макет, который содержит другие дочерние макеты. Чтобы сделать значок определенным
size и в центре объединенной ячейки мы можем использовать другую сетку в качестве родителя элемента управления Image.

Эта дочерняя сетка содержит только одну строку и один столбец определенного размера.

В элементе управления Image мы можем использовать изображение по умолчанию (passxyz_logo.png) из ресурса. Он может
быть настроены после того, как мы представим нашу модель в следующей главе.

Мы можем видеть улучшенный предварительный просмотр на рис. 3.6:

![изображение](https://user-images.githubusercontent.com/26972859/231764546-b81ccb06-ebcc-46d8-be24-c8a968475d39.png)

Рисунок 3.6: Улучшенная страница Items

Благодаря этому мы изучили основы проектирования пользовательского интерфейса с использованием XAML. Одна распространенная проблема в
дизайн пользовательского интерфейса поддерживает несколько языков. В оставшейся части этой главы мы узнаем
как поддерживать несколько языков в дизайне пользовательского интерфейса XAML.

# Поддержка нескольких языков – локализация

Для поддержки нескольких языков мы можем использовать встроенный в .NET механизм локализации приложений. В
файл XAML, мы можем использовать расширение разметки x:Static, чтобы использовать строку, определенную в файлах ресурсов.

## Создание файла .resx

Файлы ресурсов — это XML-файлы с расширением .resx, которые во время компиляции компилируются в двоичные файлы ресурсов.
процесс сборки. Файл ресурсов можно добавить, щелкнув правой кнопкой мыши узел проекта и выбрав Добавить.
> Новый элемент... > Файл ресурсов, как показано на рис. 3.7:

![изображение](https://user-images.githubusercontent.com/26972859/231766183-fb932f72-f272-45e4-8864-35c65a089856.png)

Рисунок 3.7: Создание файла ресурсов

Мы можем создать файл ресурсов Resources.resx в папке Properties.
Для поддержки разных культур мы можем добавить дополнительные файлы ресурсов с культурной информацией как часть
имени файла ресурсов:

* Resources.resx: файл ресурсов для языка и региональных параметров по умолчанию, для которого мы установим значение en-US.
(американский английский) позже

* Resources.zh-Hans.resx: файл ресурсов для культуры zh-Hans, который
упрощенный китайский

* Resources.zh-Hant.resx: файл ресурсов для культуры zh-Hant, который
традиционный китайский

После создания файла ресурсов в файл проекта будет добавлена ​​следующая группа элементов:

```xml
<ItemGroup>
 <Compile Update="Properties\Resources.Designer.cs">
 <DesignTime>True</DesignTime>
 <AutoGen>True</AutoGen>
 <DependentUpon>Resources.resx</DependentUpon>
 </Compile>
</ItemGroup>
<ItemGroup>
 <EmbeddedResource Update="Properties\Resources.resx">
 <Generator>ResXFileCodeGenerator</Generator>
 <LastGenOutput>Resources.Designer.cs</LastGenOutput>
 </EmbeddedResource>
</ItemGroup>
```
Чтобы отредактировать файл ресурсов, мы можем щелкнуть файл ресурсов и отредактировать его в редакторе ресурсов, как показано на
Рисунок 3.8:

![изображение](https://user-images.githubusercontent.com/26972859/231766499-cbd73e84-3425-4cea-bced-1edf5894c637.png)

Рисунок 3.8: Редактор ресурсов

Файл ресурсов включает в себя список пар ключ-значение для разных языков:

* Поле Name — это строковое имя, на которое мы можем ссылаться в файлах XAML или C#.

* Поле «Значение» содержит строку для конкретного языка, которая будет использоваться в соответствии с системой.
языковые настройки

* Поле «Комментарий» используется только как примечание для пары «ключ-значение».

Чтобы указать язык по умолчанию, нам нужно установить значение NeutralLanguage в <PropertyGroup> в файле проекта, как показано здесь:

```xml
<PropertyGroup>
 …
 <NeutralLanguage>en-US</NeutralLanguage>
…
</PropertyGroup>
```
В нашем проекте мы будем использовать английский язык США в качестве культуры по умолчанию, поэтому для параметра NeutralLanguage установлено значение en-US.

# Локализация текста

После настройки файлов ресурсов мы можем использовать локализованное содержимое в нашем файле XAML или файлах C#. Мы
теперь в нашем проекте пять страниц контента. Давайте изменим AboutPage с поддержкой локализации, как
показано в листинге 3.6:

** Листинг 3.6: AboutPage.xaml (https://epa.ms/AboutPage3-6)**

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com
 /dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 x:Class="PassXYZ.Vault.Views.AboutPage"
 xmlns:res="clr-namespace:PassXYZ.Vault.Properties" ➊
 Title="{Binding Title}">
 <ContentPage.Resources…>
 <ScrollView>
 <StackLayout Margin="20">
 <Grid Padding="10"...>
 <StackLayout Padding="10" >
 <Label HorizontalOptions="Center"
 Text="{x:Static res:Resources.Appname}" ➋
 FontAttributes="Bold" FontSize="22" />
 <Label x:Name="AppVersion" HorizontalOptions
 ="Center"
 FontSize="Small" />
 <Grid HorizontalOptions="Center"...>
 <StackLayout...>
 </StackLayout>
 </StackLayout>
 </ScrollView>
</ContentPage>
```
Текст локализуется с помощью сгенерированного класса Resources. Этот класс назван на основе ресурса по умолчанию
имя файла. В листинге 3.6 AboutPage.xaml мы добавили новое пространство имен ➊ для класса Resources:

```xml
xmlns:res ="clr-namespace:PassXYZ.Vault.Properties "   
```
В элементе управления Label ➋, чтобы отобразить имя нашего приложения, мы можем обратиться к строке ресурса, используя
расширение разметки x:Static XAML, например:

```xml
<Label HorizontalOptions="Center"
 Text="{x:Static res:Resources.Appname}"
 FontAttributes="Bold" FontSize="22" />
```
В листинге 3.6 мы свернули большую часть исходного кода для краткости. Пожалуйста, обратитесь к короткому URL-адресу этого
репозиторий GitHub книги для просмотра полного исходного кода.
Мы можем использовать локализованный текст как в XAML, так и в C#. Чтобы использовать строку ресурса в C#, мы можем посмотреть на
Свойство title в листинге 3.6. Свойство Title страницы AboutPage связано с заголовком.
свойство в классе AboutViewModel. Давайте посмотрим, как мы можем использовать строку ресурса в листинге 3.7:

** Листинг 3.7: AboutViewModel.cs (https://epa.ms/AboutViewModel3-7)**

```Csharp
using System;
using System.Windows.Input;
using Microsoft.Maui.Essentials;
using Microsoft.Maui.Controls;
using PassXYZ.Vault.Properties; ①
namespace PassXYZ.Vault.ViewModels {
 public class AboutViewModel : BaseViewModel {
 public AboutViewModel() {
 Title = Properties.Resources.About; ②
 OpenWebCommand = new Command(async () => await
 Browser.OpenAsync(Properties.Resources.about_url));
 }
 public ICommand OpenWebCommand { get; }
 public string GetStoreName()...
 public DateTime GetStoreModifiedTime()...
 }
}
```
Как показано в листинге 3.7, ① мы сначала добавили пространство имен PassXYZ.Vault.Properties. ② Мы
ссылайтесь на строку ресурса как Properties.Resources.About.
После того, как мы обновим AboutPage с поддержкой локализации, мы сможем протестировать его на поддерживаемых языках,
как показано на рисунке 3.9:

![изображение](https://user-images.githubusercontent.com/26972859/231767258-66d9a3b9-5267-45eb-aa10-d752bae972d6.png)

Рисунок 3.9: AboutPage на разных языках

В AboutPage многие строки ресурсов используются для локализации. В листинге 3.6 и листинге 3.7 мы
свернута большая часть кода; вы можете обратиться к короткому URL-адресу репозитория GitHub этой книги для ознакомления
исходный код онлайн.

# Краткое содержание

В этой главе мы узнали о синтаксисе XAML. Мы использовали полученные знания, чтобы улучшить
внешний вид ItemsPage. Мы продолжим улучшать пользовательский интерфейс других страниц на протяжении
эта книга. Для поддержки нескольких языков мы научились поддерживать локализацию в .NET. Мы создали
Файлы ресурсов .resx для языков и региональных параметров US-en, zh-Hans и zh-Hant и использовали разметку XAML.
расширение для включения многоязычной поддержки. Наконец, мы использовали AboutPage в качестве примера, чтобы объяснить
как использовать локализованный текст как в XAML, так и в C#.
   
В следующей главе мы продолжим улучшать наше приложение, представив MVVM и привязку данных.

дальнейшее чтение

   * Документация по пользовательскому интерфейсу многоплатформенного приложения .NET.

   * https://learn.microsoft.com/en-us/dotnet/maui/

   * XAML — .NET MAUI

   * https://learn.microsoft.com/en-us/dotnet/maui/xaml/

   * Расширения разметки XAML

   * https://learn.microsoft.com/en-us/dotnet/maui/xaml/fundamentals/
markup-extensions

   * KeePass — менеджер паролей с открытым исходным кодом

   * https://keepass.info/

































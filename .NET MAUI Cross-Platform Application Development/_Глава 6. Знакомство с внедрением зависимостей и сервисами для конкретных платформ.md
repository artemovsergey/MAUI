# Знакомство с внедрением зависимостей и сервисами для конкретных платформ

В предыдущей главе мы представили навигацию и оболочку в пользовательском интерфейсе многоплатформенного приложения .NET (.NET MAUI),
и мы завершили навигационный дизайн нашего приложения. Мы улучшили два интерфейса, IDataStore
и IUserService, чтобы отделить модель от представления и модели представления. В текущем коде мы
использовал класс DependencyService для разделения реализаций интерфейса. В этой главе,
мы усовершенствуем наш дизайн, используя внедрение зависимостей (DI), чтобы заменить DependencyService
сорт. Существует встроенная служба для поддержки внедрения зависимостей в .NET MAUI. С помощью DI мы можем уточнить наши
проектируйте и отделяйте зависимости более элегантным способом.

В этой главе мы рассмотрим следующие темы:

* Краткий обзор принципов проектирования

* Использование цифрового входа

* Подключение к базе данных

DI - это метод реализации принципа проектирования инверсии зависимостей или инверсии зависимостей.
Принцип (ДИП). DIP — это один из принципов проектирования SOLID, и мы узнаем, как использовать SOLID.
принципы дизайна в нашем дизайне. У нас будет краткий обзор принципов проектирования SOLID на
начале этой главы, прежде чем мы погрузимся в DI.

# Технические требования

Для тестирования и отладки исходного кода в этой главе вам необходимо установить Visual Studio 2022 на
ваш ПК. См. раздел «Настройка среды разработки» в Главе 1 «Начало работы с
.NET MAUI, для получения дополнительной информации.

Исходный код для этой главы доступен в следующем репозитории GitHub:
https://github.com/PacktPublishing/.NET-MAUI-Cross-PlatformApplication-Development/tree/main/Chapter06
Исходный код можно загрузить с помощью следующей команды Git:

```
git clone -b chapter06 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development PassXYZ.Vault2
```
# Краткий обзор принципов проектирования

Принципы проектирования — это рекомендации высокого уровня по соображениям дизайна. Они могут дать фундаментальное
советы для вас, чтобы принять лучшее дизайнерское решение. Существуют общие принципы проектирования, которые могут
использоваться не только для разработки программного обеспечения, но и применимы к другим проектным работам.
Давайте рассмотрим некоторые общие принципы проектирования, прежде чем мы перейдем к наиболее часто используемым принципам проектирования.
(SOLID) в разработке программного обеспечения.

# Изучение типов принципов проектирования

Принципы дизайна могут быть огромной темой. Так что, вместо подробного описания, здесь я поделюсь своим
опыт применения принципов дизайна в разработке, предоставив вам быстрый обзор дизайна
принципов, используемых в этой книге. Мы начнем с принципов высокого уровня, таких как DRY, KISS, YAGNI и
так далее, а затем мы переходим к тем, которые в основном используются в разработке программного обеспечения. Большинство
широко используемые в объектно-ориентированном программировании (ООП) принципы проектирования SOLID.

# Не повторяйся (СУХОЙ)

Как часто говорят, не изобретайте велосипед; мы должны попытаться повторно использовать существующие компоненты, а не
переделывать то, что уже есть.

# Будь проще, глупый (KISS)

Мы должны выбрать простой и прямой подход, а не прибегать к ненужной сложности.
в дизайне.

# Тебе это не понадобится (ЯГНИ)

Мы должны реализовывать функциональность, когда это требуется. В разработке программного обеспечения наблюдается тенденция
для будущего дизайна. Это может создать что-то, что на самом деле не нужно, и увеличить
сложность решения.

# Принципы проектирования SOLID

Принципы проектирования SOLID используются при разработке программного обеспечения. Это рекомендации высокого уровня
для многих шаблонов проектирования. SOLID — это аббревиатура следующих пяти принципов:

* Принцип единой ответственности (SRP) — у класса должна быть только одна обязанность. Как разработчик,
у вас есть одна и только одна причина изменить класс. Учитывая этот принцип построения,
реализация проще для понимания и более эффективна при изменении требований.

* Принцип открытости/закрытости (OCP) — классы должны быть открыты для расширения, но закрыты для модификации.
Основная идея этого принципа состоит в том, чтобы не допустить поломки существующего кода при реализации.
новые возможности.

* Принцип замещения Лискова (LSP) — если объект родительского типа может использоваться в контексте,
объект дочернего типа должен иметь возможность использоваться таким же образом, ничего не ломая.

* Принцип разделения интерфейсов (ISP) — дизайн не должен реализовывать интерфейс,
он не использует, и класс не должен зависеть от методов, которые он не намерен использовать.
осуществлять. Мы должны проектировать лаконичные и простые интерфейсы, а не большие и сложные.

* Принцип инверсии зависимостей (DIP) — этот принцип делает упор на отделение программного обеспечения
модули. Модули высокого уровня не должны напрямую зависеть от модулей низкого уровня. Оба должны
зависят от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть
на абстракциях.

Принципы дизайна — это рекомендации, помогающие нам принимать лучшие дизайнерские решения. Однако от нас зависит
решать, что делать в фактической реализации, а не в принципах проектирования.
Использование принципов дизайна

Теперь, когда мы поговорили о различных принципах проектирования, позвольте мне поделиться своими уроками, извлеченными, когда
с использованием принципов дизайна.

В модели нашего приложения я повторно использовал KeePassLib от Доминика Райхла. Когда я портировал его на .NET
Standard я изменил иерархию наследования, как показано на рис. 6.1:

![изображение](https://user-images.githubusercontent.com/26972859/231832205-e68ca92c-915b-4871-9bb8-6bb08aaa91e1.png)

Рисунок 6.1: Диаграмма классов Item, PwEntry и PwGroup

Я создал абстрактный родительский класс Item для группы (PwGroup) и записи (PwEntry). Это выглядит
как это изменение ломает OCP в SOLID. Причина, по которой я сделал это таким образом, связана с уроком, который я
изучены в предыдущей реализации.
Итак, ранее я не реализовывал KPCLib таким образом до версии 1.2.3. В то время я использовал PwGroup
и PwEntry напрямую, поэтому мне приходилось обрабатывать группы и записи отдельно. Вы можете себе представить увеличение
сложность в ItemsPage и ItemsViewModel. Самый важный побочный эффект в том, что я не мог
четко разделите модель и просмотрите модель. В модели представления мне пришлось обрабатывать множество деталей, используя
KeePassLib напрямую. После введения абстрактного родительского класса Item я могу скрыть большую часть
детальная реализация в сервисах (IDataStore и IUserService) и PassXYZLib. Нет
код, который зависит от KeePassLib, больше присутствует в представлении и модели представления. Мысль
На это изменение больше повлияли KISS, а не просто приверженность OCP. Результат состоит в том, что
общая архитектура выглядит намного лучше, если мы рассмотрим другие принципы SOLID, такие как LSP и SRP.
Я хочу поделиться здесь тем, что мы можем найти конфликты между различными принципами проектирования в
фактическая работа. Мы должны принимать решения, а не просто придерживаться принципов дизайна. Лучшее
проектное решение обычно исходит из уроков, извлеченных из предыдущих случаев отказа.
Теперь, возвращаясь к нашей основной теме, мы поговорим об улучшении дизайна с помощью одного из методов SOLID.
принципы — инверсия зависимостей. В принципах проектирования SOLID инверсия зависимостей подчеркивает
разделение программных модулей, а также рекомендации о том, как это сделать. Ключевая идея, стоящая за
мы должны стараться полагаться на абстракции, когда это возможно. В реальной реализации DI
метод, который мы часто используем, чтобы применить идею инверсии зависимости.

# Использование прямого внедрения

DI — это один из инструментов, которые мы можем использовать в .NET MAUI. На самом деле это не что-то новое, и это было
активно используется в серверных платформах, таких как ASP.NET Core или Java Spring Framework. ДИ - это
метод достижения инверсии зависимостей (DIP). Это может помочь отделить использование объекта
от его создания, чтобы нам не приходилось зависеть от объекта, который мы используем напрямую. В нашем приложении после того, как мы
отделить реализацию интерфейса IDataStore, мы можем начать с фиктивной реализации
сначала и заменить его фактической реализацией позже.
В .NET MAUI Microsoft.Extensions.DependencyInjection — или MS.DI, как мы сокращаем
имя в этой главе — это встроенная служба, которую мы можем использовать напрямую.
В мире .NET существует множество контейнеров внедрения зависимостей, отличных от MS.DI. Они могут быть более мощными
и гибче, чем MS.DI, например контейнер DI Autofac или контейнер DI Simple Injector, и
скоро. Тогда почему мы выбираем MS.DI вместо других мощных и гибких контейнеров внедрения зависимостей? Мы тут
возможно, захочется еще раз подумать о принципах KISS и YAGNI. Мы не должны выбирать более мощный
решение, предполагая, что мы можем использовать некоторые функции в будущем. Самое простое и легкое решение это
использовать то, что у нас уже есть, без какого-либо дополнительного эффекта. С MS.DI нам не нужно привлекать никаких дополнительных
зависимости. Независимо от того, хотим мы его использовать или нет, он уже есть в конфигурации.
.NET MAUI. Мы можем просто добавить несколько строк кода, чтобы сделать наш дизайн лучше. Для других контейнеров DI,
может лучше представить будущее, но мы должны ввести дополнительные зависимости и сделать
необходимая конфигурация в нашем коде, прежде чем мы сможем их действительно использовать. Если вы работаете над комплексом
системы, вы можете оценить доступные контейнеры DI и выбрать правильный для
ваша система. В нашем случае PassXYZ.Vault — относительно простое приложение, и мы не получим прямой выгоды.
из расширенных функций DI, предоставляемых Autofac или Simple Injector. Предоставляемые функции
от MS.DI достаточно для нашей реализации.
Прежде чем мы перейдем к теме DI, давайте сначала посмотрим на нашу текущую реализацию. Вместо использования DI,
мы используем DependencyService из Xamarin.Forms в нашем приложении, чтобы разделить интерфейс и его
выполнение. В этой главе мы уточним наш код, заменив DependencyService на DI.

# Служба зависимостей

В главе 2 «Создание нашего первого приложения .NET MAUI» мы создали наше приложение на основе шаблона Xamarin.Forms.
и перенес его на .NET MAUI. Все, что работает в Xamarin.Forms, может работать и в .NET MAUI.
включая службу зависимостей.
DependencyService — это локатор служб, который позволяет приложениям Xamarin.Forms вызывать собственные
функциональность из общего кода, но его также можно использовать для выполнения роли контейнера внедрения зависимостей в простых случаях использования.
Модуль, который мы хотим отделить в нашем приложении, — это уровень модели, который является сторонней библиотекой.
от Кипасс. Как видно из диаграммы пакетов на рис. 6.2, наша система включает в себя три отдельных
сборки: KPCLib, PassXYZLib и PassXYZ.Vault:

![изображение](https://user-images.githubusercontent.com/26972859/231832524-56f7ccd7-7d65-404e-91a3-da69a899f42d.png)

Рисунок 6.2: Схема упаковки

Пакет KPCLib включает два пространства имен: KeePassLib и KPCLib. PassXYZLib — это
пакет для расширения функциональности пакета KPCLib с реализацией, специфичной для .NET MAUI.
PassXYZ.Vault — это наше приложение, которое напрямую зависит от пакета PassXYZLib и зависит
в пакете KPCLib косвенно. По принципу DI мы хотим создать зависимости
на абстракциях, а не на реальных реализациях. Мы создали два интерфейса, IDataStore и
IUserService, который мы можем использовать для отделения от реальных реализаций.
Использование DependencyService включает два шага — регистрацию и разрешение. Давайте посмотрим на это в
Подробнее:
1. Регистрация услуги
Нам нужно сначала зарегистрировать интерфейсы IDataStore и IUserService, прежде чем мы сможем использовать
их. В текущем коде они регистрируются в конструкторе класса App, как показано здесь:

```Csharp
DependencyService.Register<MockDataStore>();
DependencyService.Register<UserService>();
```
Мы можем использовать метод Register() службы зависимостей для регистрации реализации.
услуг. Классы MockDataStore и UserService реализуют IDataStore и
Интерфейсы IUserService. MockDataStore не является фактической реализацией, и он используется
только для целей тестирования. Позже в этой главе мы заменим его фактической реализацией.
Это одно из преимуществ, которое мы можем увидеть после отделения от фактической реализации.

2. Разрешение услуги
Чтобы устранить зависимость в нашем коде, мы определили общедоступное свойство DataStore типа
IDataStore в классе BaseViewModel, как показано здесь:

```Csharp
public static IDataStore<Item> DataStore =>
 DependencyService.Get<IDataStore<Item>>();
```
Мы можем использовать метод Get() службы DependencyService для устранения зависимости. С
BaseViewModel является родительским классом всех других моделей представлений, мы можем получить доступ к IDataStore.
интерфейс во всех моделях просмотра с этой настройкой.
Для интерфейса IUserService мы создали одноэлементный класс LoginUser и определили
Публичное свойство UserService в классе LoginUser, как показано здесь:
```Csharp
public static IUserService<User> UserService => DependencyService.Get<IUserService<User>>();
```

Это текущая реализация DependencyService в нашем приложении. Давайте заменим его на DI
поддерживается в MS.DI.

# Использование встроенного сервиса MS.DI DI

Использование MS.DI в качестве службы DI аналогично использованию DependencyService, который включает в себя два
шаги — регистрация и разрешение. Мы можем использовать класс ServiceCollection для регистрации
и класс ServiceProvider для разрешения, как показано на рис. 6.3:

![изображение](https://user-images.githubusercontent.com/26972859/231832981-8c00d2f4-4332-4648-8e15-d6f6b592ad72.png)

Рисунок 6.3: Использование MS.DI

Если мы хотим использовать DI для разрешения службы IDataStore, мы можем использовать следующие шаги:
блок кода:

```Csharp
// Registration
var services = new ServiceCollection(); ❶
services.AddSingleton <IDataStore<Item>, MockDataStore>();❷
// Resolution
ServiceProvider provider =
 services.BuildServiceProvider(validateScopes: true); ❸
IDataStore<Item> dataStore =
 provider.GetRequiredService<IDataStore<Item>>(); ❹
```
❶Сначала нам нужно создать экземпляр класса ServiceCollection. СервисКоллекция
реализует интерфейс IServiceCollection.
❷ Сам интерфейс IServiceCollection не определяет какой-либо метод напрямую. Есть набор
методы расширения, определенные в MS.DI. Мы можем использовать метод расширения AddSingleton() для регистрации
конкретный класс MockDataStore для абстракции IDataStore. AddSingleton()
Метод может использовать общий тип для определения интерфейса и реализации. Есть несколько
доступны перегруженные версии метода расширения AddSingleton().
❸ Для разрешения объектов мы можем получить экземпляр ServiceProvider, вызвав метод
Метод расширения BuildServiceProvider() для IServiceCollection. 
Класс ServiceProvider реализует интерфейс IServiceProvider. IServiceProvider
Интерфейс определен в пространстве имен System и определяет только один метод GetService().
Остальные методы являются методами расширения, определенными в файле Microsoft.Extensions.
Пространство имен DependencyInjection, как мы можем видеть на рисунке 6.3.
❹ Получив экземпляр ServiceProvider, мы можем разрешить интерфейс IDataStore.
используя метод расширения GetRequiredService().

Несмотря на то, что MS.DI является облегченной DI-службой, она предоставляет достаточно возможностей для приложений .NET MAUI,
как указано здесь:

  * Пожизненное управление экземплярами

  * Внедрение конструктора, методов и свойств

  Давайте рассмотрим эти функции в следующих разделах.

## Управление сроком службы

  Мы можем управлять временем жизни экземпляров, настроив ServiceCollection.

  Чтобы настроить ServiceCollection, мы можем использовать следующие три метода расширения:

  * AddSingleton — этот метод создает один экземпляр на протяжении всего жизненного цикла приложения.
Он создает экземпляр в первый раз и повторно использует его в следующих вызовах.

  * AddTransient — этот метод создает экземпляр для каждого вызова. Время жизни экземпляра
зависит от объема логики программирования.
 
  * AddScoped — время жизни экземпляра, разрешенного этим методом, находится в пределах определенной области.
по дизайну. Он создает один экземпляр и повторно использует один и тот же экземпляр в пределах определенной области.
В ASP.NET мы можем определить область действия как сеанс каждого HTTP-запроса.
Чтобы объяснить управление жизненным циклом MS.DI, мы можем вместе просмотреть следующий фрагмент кода.
с рисунком 6.4:

```Csharp
var services = new ServiceCollection();
services.AddSingleton< IUserService<User>, UserService>();❶
services.AddScoped<IDataStore<Item>, DataStore>(); ❶
services.AddTransient<ItemsViewModel>(); ❶
ServiceProvider rootContainer =
 services.BuildServiceProvider(validateScopes: true); ❷
var userService =
 rootContainer.GetRequiredService<IUserService<User>>();
IServiceScope scope1 = rootContainer.CreateScope(); ❸
 IDataStore<Item> dataStore1 =
 scope1.ServiceProvider.GetRequiredService<IDataStore<Item>>
 ();
IServiceScope scope2 = rootContainer.CreateScope(); ❸
IDataStore<Item> dataStore2 = Scope2.ServiceProvider.
 GetRequiredService<IDataStore<Item>>
 ();
```
В предыдущем коде ❶ мы зарегистрировали IUserService как объект Singleton, IDataStore
как объект Scoped и ItemsViewModel как объект Transient.

После регистрации ❷ мы создали экземпляр ServiceProvider и сохранили его в корневом контейнере.
переменная. ❸ Мы создали две области, область 1 и область 2, используя корневой контейнер. Мы можем
просмотрите управление жизненным циклом созданных объектов на рис. 6.4:

![изображение](https://user-images.githubusercontent.com/26972859/231833570-391b041a-d9ba-4f91-84d2-9d808907326c.png)

Рисунок 6.4: Управление временем жизни в MS.DI

userService создается как объект Singleton, поэтому существует только один экземпляр, и экземпляр имеет
тот же срок службы, что и само приложение. Две области видимости scope1 и scope2 имеют свои
собственные жизни, которые определяются нашим дизайном. Объекты Scoped, dataStore1 и dataStore2,
имеют то же время жизни, что и область действия, к которой они принадлежат. Экземпляры ItemViewModel
Преходящие объекты.
Для каждого из этих трех методов, AddSingleton(), AddScoped() и AddTransient(), несколько
перегруженные версии определяются для удовлетворения различных требований в конфигурации ServiceCollection.
В нашем приложении у нас есть две версии реализации интерфейса IDataStore:
1. DataStore — это фактическая реализация
2. MockDataStore — используется для тестирования.

Используя MS.DI, мы можем использовать MockDataStore в сборке Debug и использовать DataStore в сборке.
Выпустить сборку. Эту конфигурацию можно реализовать, как показано в следующем фрагменте кода:

```Csharp
bool isDebug = false;
var services = new ServiceCollection();
services.AddSingleton<DataStore, DataStore>();
services.AddSingleton<MockDataStore, MockDataStore>();
services.AddSingleton<IDataStore<Item>>(c => {
 if (isDebug)
 {
 return c.GetRequiredService<MockDataStore>();
 }
 else
 {
 return c.GetRequiredService<DataStore>();
 }
});
```

В предыдущем фрагменте кода мы можем настроить конкретные классы и DataStore, MockDataStore,
и интерфейсы IDataStore для различных конфигураций сборки. В конфигурации IDataStore,
мы можем использовать делегата для разрешения объекта. Переменная isDebug может быть установлена ​​с помощью конфигурации сборки.
чтобы для него можно было установить значение true/false в зависимости от того, является ли это отладочной или выпускной сборкой.
Настройка внедрения зависимостей в .NET MAUI
MS.DI реализован как часть версии .NET, поэтому он доступен для всех типов приложений в .NET.
5 или более поздние выпуски. Мы можем реализовать DI, используя ServiceCollection и ServiceProvider,
как мы представили в предыдущем разделе. Однако есть гораздо более простой способ использования MS.DI в .NET.
МАУИ. DI интегрирован как часть конфигурации универсального хоста .NET, поэтому нам не нужно создавать
экземпляр ServiceCollection самостоятельно. Мы можем использовать предварительно настроенный сервис DI напрямую
без дополнительной работы.
Чтобы понять предварительно настроенную службу DI в .NET MAUI, мы можем рассмотреть приложение .NET MAUI.
снова запустите процесс, используя рисунок 6.5. Рисунок 6.5 включает в себя как диаграмму классов, так и диаграмму последовательности.
из задействованных классов:

![изображение](https://user-images.githubusercontent.com/26972859/231833825-7bfccde8-0f92-4377-9d36-93c3d2e41faf.png)

В верхней части рисунка 6.5 мы видим, что в запуске приложения .NET MAUI участвуют четыре класса:
1. Точка входа платформы. Точка входа приложения .NET MAUI находится в коде, зависящем от платформы.
Для проекта .NET MAUI он находится в папке Platforms. Определены разные классы
для разных платформ, как видно из таблицы 6.1. На рис. 6.5 мы используем приложение Maui.
Версия Android в качестве примера:

|Платформа|Класс точки входа|
|:-------|:----------------|
|Android|МауиПриложение|
|iOS/macOS|MauiUIApplicationDelegate|
|Windows|MauiWinUIApplication|

Таблица 6.1: Точки входа на разных платформах

Как мы видим, все классы точек входа реализуют интерфейс IPlatformApplication.
в следующем фрагменте кода:

```Csharp
public interface IPlatformApplication
{
 static IPlatformApplication? Current { get; set; }
 IServiceProvider Services { get; }
 IApplication Application { get; }
}
```
IServiceProvider определен как часть этого интерфейса, поэтому мы можем использовать его напрямую для разрешения
Объекты DI после инициализации приложения.

MauiProgram ❶ — как видно из кода реализации MauiProgram
показано далее, каждое приложение .NET MAUI должно определять статический класс MauiProgram и создавать
метод CreateMauiApp(). Метод CreateMauiApp() вызывается
следующую функцию переопределения, которая определена во всех точках входа платформы. Возвращаемое значение
экземпляр MauiApp:

```Csharp
protected override MauiApp CreateMauiApp() => MauiProgram.CreateMauiApp();
```
MauiApp ❷ — внутри функции CreateMauiApp() создается экземпляр MauiAppBuilder путем
вызов MauiApp.CreateBuilder().

MauiAppBuilder ❸ — MauiAppBuilder включает в себя атрибут Services
Тип интерфейса IServiceCollection. Мы можем использовать его для настройки DI для приложения .NET MAUI.

Из предыдущего анализа процесса запуска приложения .NET MAUI мы видим, что оба
IServiceCollection и IServiceProvider были инициализированы во время запуска
процесс, поэтому мы можем использовать их напрямую без дополнительной настройки.

Мы можем обратиться к следующему фрагменту кода при анализе процесса запуска. Мы зарегистрировали два
абстракции, IDataStore и IUserService, а также класс LoginUser. Все они являются одноэлементными объектами:

```Csharp
public static class MauiProgram { ❶
 public static MauiApp CreateMauiApp() { ❷
 var builder = MauiApp.CreateBuilder(); ❸
 builder
 .UseMauiApp<App>()
 .ConfigureFonts(fonts => {
 fonts.AddFont("fa-regular-400.ttf",
 "FontAwesomeRegular");
 fonts.AddFont("fa-solid-900.ttf",
 "FontAwesomeSolid");
 fonts.AddFont("fa-brands-400.ttf",
 "FontAwesomeBrands");
 fonts.AddFont("OpenSans-Regular.ttf",
 "OpenSansRegular");
 fonts.AddFont("OpenSans-SemiBold.ttf",
 "OpenSansSemiBold");
 });
 builder.Services.AddSingleton<IDataStore<Item>,
 DataStore>();
builder.Services.AddSingleton<IUserService<User>,
 UserService>();
 builder.Services.AddSingleton<LoginUser, LoginUser>();
 return builder.Build();
 }
}
```
После того, как мы настроили интерфейсы и класс, мы можем использовать их в нашей реализации. Мы можем использовать
интерфейс IServiceProvider для разрешения объектов. Когда мы реализуем DI, есть три способа
внедрения зависимостей. Мы можем использовать внедрение конструктора, внедрение метода или внедрение свойства.
Давайте посмотрим, как мы можем это сделать, используя наиболее распространенные методы в следующих двух разделах.

# Внедрение конструктора

При внедрении конструктора зависимости, необходимые для класса, предоставляются в качестве аргументов для
конструктор. Мы можем разрешать зависимости с помощью конструктора. Для этого требуется зарегистрированный
зависимость иметь конструктор без параметров. В нашем коде класс LoginUser зависит от
Интерфейс IuserService. Конкретным классом, реализующим IUserService, является UserService,
который определяет конструктор без параметров. Мы можем определить конструктор LoginUser следующим образом:

```Csharp
private IUserService<User> _userService;
public LoginUser(IUserService<User> userService)
{
_userService = userService ?? throw new
 ArgumentNullException(nameof(userService));
 _userService.CurrentUser = this;
}
```
В конструкторе LoginUser мы указываем зависимость как параметр userService. В этом
В этом случае MS.DI разрешит IUserService как настроенный для нас конкретный класс UserService.

# Внедрение свойства

Есть много случаев, когда мы не сможем использовать внедрение конструктора. В этих случаях мы можем
разрешить зависимости через IServiceProvider.
В приложении .NET MAUI среда размещения создает интерфейс IServiceProvider.
для нас, как мы можем видеть на рисунке 6.5. Мы можем использовать интерфейс IPlatformApplication, определенный в
точки входа для конкретной платформы для получения интерфейса IServiceProvider, как показано в листинге 6.1:

**Листинг 6.1: ServiceHelper.cs (https://epa.ms/ServiceHelper6-1)**

```Csharp
namespace PassXYZ.Vault.Services;
public static class ServiceHelper
{
 public static TService GetService<TService>()
 => Current.GetService<TService>(); ❷
 public static IServiceProvider Current => ❶
#if WINDOWS10_0_17763_0_OR_GREATER
 MauiWinUIApplication.Current.Services;
#elif ANDROID
 MauiApplication.Current.Services;
#elif IOS || MACCATALYST
 MauiUIApplicationDelegate.Current.Services;
#else
 null;
#endif
}
```
❶ В классе ServiceHelper мы определяем статическую переменную Current, чтобы сохранить ссылку на
IServiceProvider, который находится в интерфейсе IPlatformApplication на платформе.
точки входа.
❷ Определен статический метод GetService(), который вызывает метод GetService()
IServiceProvider.

```Csharp
Сервисный помощник
Для реализации ServiceHelper я сослался на проект MauiApp-DI GitHub.
Спасибо за образец кода Джеймса Монтеманьо на GitHub!
https://github.com/jamesmontemagno/MauiApp-DI
```
Мы можем обновить наш исходный код, чтобы заменить службу зависимостей на DI с помощью
СервисПомощник. В BaseViewModel.cs мы заменили DependencyService на DI, т.к.
показано далее.
Итак, мы заменили следующий код:
  
```Csharp
public static IDataStore<Item> DataStore => DependencyService.Get<IDataStore<Item>>();
```
Вот на что мы заменили:

```Csharp
public static IDataStore<Item> DataStore => ServiceHelper.GetService<IDataStore<Item>>();
```

Вы можете почувствовать, что предыдущий код внедрения свойства не выглядит элегантным по сравнению с конструктором.
инъекция. Я не нашел лучшего способа сделать это в .NET MAUI. Однако в следующей части
В этой книге, когда мы представляем приложение Blazor Hybrid, мы можем разрешить внедрение свойств с помощью C#
атрибут. Чтобы разрешить интерфейс IDataStore в Blazor, мы можем сделать это гораздо проще:
показано здесь:

```Csharp
[Inject]
public IDataStore<Item> DataStore { get; set; } = default!;

```
Мы можем использовать атрибут [Inject] C# для неявного разрешения зависимости без вызова
Метод GetService() для ServiceHelper явно.
Когда мы перейдем от службы зависимостей к DI, мы создадим еще один конкретный класс для
Интерфейс IDataStore. Этот класс будет обрабатывать операции CRUD базы данных паролей.

# Подключение к базе данных

База паролей представляет собой локальную базу данных в формате KeePass 2.x. Внутри базы данные паролей
хранится в виде групп и записей. В пространстве имен KeePassLib определен класс PwDatabase.
для управления операциями с базой данных. Мы можем обратиться к диаграмме классов на рис. 6.6, чтобы понять
связь между PwDatabase, PwGroup и PwEntry:

![изображение](https://user-images.githubusercontent.com/26972859/231835206-6017c155-681c-49b7-bce1-4a5f89e6fba0.png)

Рисунок 6.6: Диаграмма классов базы данных KeePass

В PwDatabase определено свойство RootGroup типа PwGroup. Он содержит все группы и записи
хранится в базе данных. Мы можем перемещаться по структуре данных базы данных KeePass из RootGroup.
к конкретной записи. В PwEntry определен набор стандартных полей, как показано на рис. 6.7:

![изображение](https://user-images.githubusercontent.com/26972859/231835346-b1a3cf68-d9c9-4fb3-ae9a-618dd4e615f2.png)

Рисунок 6.7: Группа, запись и поле

Если у нас есть список записей, включающий только стандартные поля, этот список выглядит как таблица. На рис. 6.7
Текущая группа включает пять записей (GitHub, Google, Facebook, Instagram и Chase Bank) и
подгруппа (Облако). Слева есть скриншот ItemsPage, на котором показаны элементы в
текущая группа. Если был выбран элемент Google, он будет отображаться как запись на снимке экрана.
с правой стороны. Пользователи могут добавлять в запись дополнительные поля, поэтому база данных KeePass не
реляционная база данных — она больше похожа на базу данных «ключ-значение». Каждая пара ключ-значение представляет собой поле, например
Поле URL.
Для использования PwDatabase в нашем приложении определяется производный класс PxDatabase. Добавлена ​​PxDatabase
дополнительные свойства и методы, такие как CurrentGroup, DeleteGroup(), DeleteEntry(),
и так далее.
Чтобы получить доступ к базе данных, мы можем открыть файл базы данных и выполнить над ним операции CRUD. С тех пор, как мы
создаете кросс-платформенное приложение, неудобно обрабатывать файл базы данных непосредственно в конце
пользователи. В PassXYZ.Vault вместо файла данных используется концепция пользователя. В PassXYZLib пользователь
класс определен для инкапсуляции базовых файловых операций.
Для доступа к базе данных мы определили инициализацию базы данных и операции CRUDL в IDataStore.
и интерфейсы IUserService. Используются конкретные классы DataStore и UserService.
для реализации этих двух интерфейсов.

# Инициализация базы данных
  
Инициализация базы данных является частью процесса входа в систему, поэтому определен следующий метод входа в систему.
в интерфейсе IUserService:

```Task<bool> LoginAsync(T user);```;
  
В классе UserService LoginAsync() определен как асинхронный метод, как мы видим здесь:

```Csharp
public async Task<bool> LoginAsync(User user) {
 if (user == null) {
Debug.Assert(false); throw new ArgumentNullException("user");
 }
 return await Task.Run(() => { ❶
 if (string.IsNullOrEmpty(user.Password)) { return false; }
 db.Open(user); ❷
 if (db.IsOpen) {
 db.CurrentGroup = db.RootGroup;
 }
 return db.IsOpen;
 });
}
```
В LoginAsync() ❶ отдельная задача используется для обработки операции открытия базы данных. 
Вызывается метод Open() ❷ PxDatabase, и экземпляр класса User передается в
Метод Open() в качестве аргумента.

# Выполнение CRUD-операций

Работа с данными базы данных KeePass аналогична операциям CRUD в реляционной базе данных.
Как только мы войдем в систему и подключимся к базе данных, мы сможем получить доступ к нашим данным пароля. Первым шагом является получение
список предметов. После входа в систему из корневой группы извлекается первый список. Существует свойство только для чтения,
RootGroup ①, которая определена в интерфейсе IDataStore, как видно из следующего кода.
фрагмент. Позже, когда пользователь переходит к другой группе, используется свойство CurrentGroup ②.
чтобы сохранить текущее местоположение в навигации:

**Листинг 6.2: IDataStore.cs (https://epa.ms/IDataStore6-2)**

```Csharp
public interface IDataStore<T> {
 #region DS_misc
 T CurrentGroup { get; set; } ②
 string CurrentPath { get; }
 T RootGroup { get; } ①
 bool IsOpen { get; }
 string GetStoreName();
 DateTime GetStoreModifiedTime();
 Task<bool> MergeAsync(string path);
 ObservableCollection<PxIcon> GetCustomIcons(...);
 Task<bool> DeleteCustomIconAsync(PxIcon icon);
 ImageSource GetBuiltInImage(PxIcon icon);
 #endregion
 DS_Item ...
}
```

# Добавление элемента

Первая операция в CRUD — это операция создания или добавления. Мы можем добавить элемент, который может быть записью или
группу в текущую группу. Пользовательский интерфейс для операции добавления представляет собой элемент панели инструментов в ItemsPage,
как показано здесь:

```Csharp
<ContentPage.ToolbarItems>
 <ToolbarItem Text="{x:Static resources:Resources.action_id_add}" Command="{Binding AddItemCommand}">
 <ToolbarItem.IconImageSource>
 <FontImageSource FontFamily="FontAwesomeSolid"
 Glyph="{x:Static styles:FontAwesomeSolid.Plus}"
 Color="{DynamicResource SecondaryColor}"
 Size="16" />
 </ToolbarItem.IconImageSource>
 </ToolbarItem>
</ContentPage.ToolbarItems>
```
Мы видим значок элемента панели инструментов, показанный в верхнем правом углу ItemsPage на рисунке 6.8:

![изображение](https://user-images.githubusercontent.com/26972859/231835897-4c0bcfd6-f1fa-4bc4-acd1-e8f88a6351f3.png)

 Рисунок 6.8: Добавление элемента

---
При нажатии кнопки «Добавить» вызывается команда AddItemCommand, определенная в
ItemsViewModel через привязку данных.
Команда AddItemCommand вызывает следующий метод OnAddItem() в модели представления:
---

**Листинг 6.3: ItemsViewModel.cs (https://epa.ms/ItemsViewModel6-3)**

```Csharp
private async void OnAddItem(object obj) {
 string[] templates = {
Properties.Resources.item_subtype_group,
Properties.Resources.item_subtype_entry,
Properties.Resources.item_subtype_notes,
Properties.Resources.item_subtype_pxentry
 };
 var template = await Shell.Current.DisplayActionSheet(
Properties.Resources.pt_id_choosetemplate,
Properties.Resources.action_id_cancel, null,
 templates); ❶
 ItemSubType type = ItemSubType.None;
 if (template == Properties.Resources.item_subtype_entry) {
type = ItemSubType.Entry;
 } else if (template == Properties.Resources.item
 _subtype_pxentry){
type = ItemSubType.PxEntry;
 } else if (template == Properties.Resources.
 item_subtype_group) {
type = ItemSubType.Group;
 } else if (template == Properties.Resources.item
 _subtype_notes) {
type = ItemSubType.Notes;
 } else if (template == Properties.Resources.action
 _id_cancel) {
type = ItemSubType.None;
 } else {
type = ItemSubType.None;
 }
 if (type != ItemSubType.None) {
var itemType = new Dictionary<string, object> ❷
{
 { "Type", type }
};
await Shell.Current.GoToAsync(nameof(NewItemPage),
 itemType); ❸
 }
}
```
❶ В этой функции OnAddItem() отображается ActionSheet, чтобы пользователь мог выбрать тип элемента.
Тип элемента может быть группой или записью.
❷ Получив тип элемента, мы можем создать словарь с типом элемента и именем запроса.
параметр. Мы храним этот объект словаря в переменной itemType.
❸ Эту переменную itemType можно передать в NewItemPage в качестве параметра запроса. В главе 5,
Знакомясь с оболочкой и навигацией, мы узнали, как передать строковое значение в качестве параметра запроса в
страница в навигации Shell. Здесь мы можем передать объект в качестве параметра запроса на страницу после того, как завершим его.
в словаре.
Чтобы добавить новый элемент, пользовательский интерфейс определяется в NewItemPage, а логика обрабатывается в
NewItemViewModel. Давайте рассмотрим реализацию NewItemViewModel в листинге 6.4:

**Листинг 6.4: NewItemViewModel.cs (https://epa.ms/NewItemViewModel6-4)**

```Csharp
using KPCLib;
using PassXYZLib;
namespace PassXYZ.Vault.ViewModels;
[QueryProperty(nameof(Type), nameof(Type))] ①
public class NewItemViewModel : BaseViewModel {
private string text;
private string description;
private ItemSubType _type = ItemSubType.Group;
public NewItemViewModel() {
 SaveCommand = new Command(OnSave, ValidateSave);
 CancelCommand = new Command(OnCancel);
 this.PropertyChanged +=
 (_, __) => SaveCommand.ChangeCanExecute();
 Title = "New Item";
}
private void SetTitle(ItemSubType type)...
private bool ValidateSave()...
public ItemSubType Type { ②
 get => _type;
 set {
 _ = SetProperty(ref _type, value);
 SetTitle(_type);
 }
 }
public string Text...
public string Description...
public Command SaveCommand { get; }
public Command CancelCommand { get; }
private async void OnCancel() {
 await Shell.Current.GoToAsyc(".."); }
private async void OnSave() {
 Item? newItem = DataStore.CreateNewItem(_type); ③
 if (newItem != null) {
 newItem.Name = Text;
 newItem.Notes = Description;
 await DataStore.AddItemAsync(newItem); ④
 }
 await Shell.Current.GoToAsyc("..");
}
}
```
Дизайн NewItemPage очень прост. Он включает в себя два элемента управления, Entry и Editor (используется для
редактировать название и примечания к элементу). Ввод используется для ввода или редактирования одной строки текста, а Редактор
используется для редактирования нескольких строк текста. В модели представления NewItemViewModel мы можем
посмотрите, как добавить новый элемент, как показано ниже:
① Параметр запроса определяется атрибутом QueryPropertyAttribute. ② Свойство Тип
объявленный как ItemSubType, используется для получения параметра запроса. Полученный тип элемента сохраняется
в резервной переменной _type. В NewItemPage определены два элемента панели инструментов, а действия
привязаны к методам OnSave и OnCancel в модели представления.
После того, как пользователь введет имя и примечания в пользовательском интерфейсе и нажмет кнопку «Сохранить», ③ появится новый
Экземпляр элемента создается с помощью фабричного метода CreateNewItem(), который определен в
Интерфейс IDataStore. ④ После заполнения нового экземпляра элемента из пользовательского ввода мы можем добавить
этот новый элемент в базу данных, вызвав метод AddItemAsync().
Теперь мы реализовали операцию добавления, давайте реализуем остальные операции с данными в
следующий раздел.
Редактирование или удаление элемента
В операциях CRUD нам не нужен существующий элемент для выполнения операции создания, но нам нужно
иметь экземпляр существующего элемента для выполнения операций обновления и удаления.
Для операции чтения, если элемент представляет собой группу, мы реализуем ее, отправив параметр запроса ItemId.
на ItemsPage и найти группу в установщике ItemId в представлении ItemsViewModel
модель. Если элемент является записью, мы отправляем параметр запроса ItemId в ItemDetailPage и находим
запись в установщике ItemId в ItemDetailViewModel.
Для операций обновления/редактирования и удаления мы можем использовать контекстные действия. С контекстными действиями мы
может воздействовать на элемент в ListView. Контекстные действия выглядят по-разному на iOS, Android и
Windows, как мы видим на рис. 6.9:

![изображение](https://user-images.githubusercontent.com/26972859/231836373-2ab7120b-a569-4f35-b13d-3458d0b87fe4.png)

Рисунок 6.9: Контекстные действия

На платформе iOS вы можете выполнить действие над элементом, сдвинув его влево. В системе Android
вы можете долго нажимать на элемент, и контекстное меню действий отображается в правом верхнем углу окна.
экран. В Windows вы можете быть знакомы с правым щелчком мыши, чтобы увидеть контекстное меню действий.
В нашем приложении мы реализуем контекстное меню действий в ItemsPage. В ItemsPage мы определяем контекст
действия в ViewCell следующим образом:

```xml
<ListView.ItemTemplate>
 <DataTemplate>
 <ViewCell>
 <ViewCell.ContextActions>
 <MenuItem Clicked="OnMenuEdit" ❶
 CommandParameter="{Binding .}"
 Text="{x:Static resources:Resources.
 action_id_edit}" />
 <MenuItem Clicked="OnMenuDeleteAsync" ❷
 CommandParameter="{Binding .}"
 Text="{x:Static resources:Resources.
 action_id_delete}"
 IsDestructive="True" />
 </ViewCell.ContextActions>
 <Grid Padding="10" x:DataType="model:Item" ...>
 </ViewCell>
 </DataTemplate>
</ListView.ItemTemplate>
```
Мы определяем два пункта меню для редактирования и удаления контекстных действий. Два обработчика событий, ❶ OnMenuEdit
и ❷ OnMenuDeleteAsync назначаются событию Clicked. Мы можем просмотреть исходный код
обработчиков событий здесь:

```Csharp
private void OnMenuEdit(object sender, EventArgs e) {
 var mi = (MenuItem)sender;
 if (mi.CommandParameter is Item item) {
 _viewModel.Update(item); ❶
 }
}
private async void OnMenuDeleteAsync(object sender,
 EventArgs e) {
 var mi = (MenuItem)sender;
 if (mi.CommandParameter is Item item) {
 await _viewModel.DeletedAsync(item); ❷
 }
}
```
Обработчики событий OnMenuEdit и OnMenuDeleteAsync вызывают функции ❶ Update() и ❷
DeleteAsync() в модели представления. Давайте рассмотрим исходный код этих функций в
модель представления ItemsViewModel следующим образом:

```Csharp
public async void Update(Item item) {
 if (item == null) { return; }
 await Shell.Current.Navigation.PushAsync(new
 FieldEditPage(async (string k, string v, bool
 isProtected) => { ❶
 item.Name = k;
 item.Notes = v;
 await DataStore.UpdateItemAsync(item); ❷
 }, item.Name, item.Notes, true));
}
public async Task DeletedAsync(Item item) {
 if (item == null) { return; }
 if (Items.Remove(item)) {
 _ = await DataStore.DeleteItemAsync(item.Id); ❸
 }
 else { return; }
}
```
В ItemsViewModel для редактирования или обновления элемента ❶ мы используем страницу содержимого FieldEditPage для
выполнить редактирование. Когда мы вызываем конструктор FieldEditPage, анонимная функция
передается как параметр. Когда пользователь завершит редактирование в FieldEditPage, эта функция
вызываться. В этой функции ❷ мы вызываем метод UpdateItemAsync() хранилища IDataStore.
Интерфейс для обновления элемента.
Операция удаления довольно проста. Мы можем просто вызвать метод ❸ DeleteItemAsync() объекта
Интерфейс IDataStore для удаления элемента.
После того, как мы реализуем операции CRUD, наше приложение имеет большинство желаемых функций менеджера паролей.
приложение. Мы можем создать новую базу данных, зарегистрировав нового пользователя. После того, как у нас есть новая база данных, мы можем войти
для доступа к нашим данным. После того, как мы создадим записи и группы, мы также можем редактировать или удалять их.
Для приложения менеджера паролей есть более желательные функции, такие как сканирование отпечатков пальцев, одноразовый
пароль и так далее. Большинство из этих желаемых функций уже включены в PassXYZ.Vault.
1.xx версии. Я продолжу перенос функций из 1.xx в выпуски .NET MAUI (2.xx), когда
зависимости доступны для .NET MAUI.

---
Особенности устройства
Мы можем получить доступ к функциям устройства, используя класс в пространстве имен Microsoft.Maui.Devices.
Реализация функций устройства возникла из Xamarin.Essentials, а затем была изменена.
на Maui.Essentials в предварительных версиях .NET MAUI. В конце концов он стал Microsoft.
Maui.Devices в выпусках GA. Не все функции устройства можно найти в Microsoft.Maui.
Устройства, такие как сканирование отпечатков пальцев. Для поддержки сканирования отпечатков пальцев в .NET MAUI я
нужно дождаться библиотеки, такой как Plugin.Fingerprint, доступной в .NET MAUI, чтобы включить
это в PassXYZ.Vault.
---

# Краткое содержание

В этой главе мы начали с введения принципов проектирования. После этого мы представили SOLID
принципов дизайна, и я поделился уроками, извлеченными при разработке нашего приложения. Один из самых важных ТВЕРДЫХ
принципами является принцип инверсии зависимостей (DIP). Внедрение зависимостей (DI) — это метод
применять DIP в реальной реализации. В нашем приложении мы используем встроенную службу DI .NET MAUI для
отделить зависимости, чтобы мы могли отделить реализацию службы от интерфейса.
Со всеми знаниями, которые мы собрали о .NET MAUI, мы завершили реализацию нашего приложения.
заменив MockDataStore фактической реализацией. Мы внедрили CRUD-операции
поверх этой новой службы IDataStore. Теперь у нас есть полнофункциональное приложение для управления паролями.
На текущей версии приложения менеджера паролей мы завершаем часть 1 этой книги.
Во второй части книги мы рассмотрим гибридное приложение Blazor в .NET MAUI. Это новая возможность
которого нет в Xamarin.Forms. Благодаря поддержке Blazor мы можем создать современный интерфейс.
методы разработки для разработки .NET MAUI.

# Дальнейшее чтение

  * Autofac — это контейнер инверсии управления (IoC) для .NET Core, ASP.NET Core, .NET4.5.1+ и других:
https://autofac.org/

  * Simple Injector — это контейнер внедрения зависимостей, который может поддерживать .NET 4.5 и .NET Standard:
https://simpleinjector.org/










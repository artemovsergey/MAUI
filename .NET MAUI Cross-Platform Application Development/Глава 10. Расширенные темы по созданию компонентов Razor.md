# Расширенные темы по созданию компонентов Razor

В разработке приложений Blazor все является компонентом. Мы научились создавать компоненты Razor
в последней главе. В этой главе мы рассмотрим более сложные темы о компонентах Razor. К
преобразовать группы списков и контекстные меню в компоненты Razor, нам нужно понять сложные темы
такие как шаблонные компоненты и проверка формы. Мы познакомим вас с этими понятиями, пока мы
создание дополнительных компонентов Razor в нашем проекте.
В этой главе мы рассмотрим следующие темы:


* Создание дополнительных компонентов Razor

* Использование шаблонных компонентов

* Встроенные компоненты Razor и проверка ввода

# Технические требования

Для тестирования и отладки исходного кода в этой главе вам необходимо установить Visual Studio 2022 на
ваш ПК или Mac. Пожалуйста, обратитесь к разделу Настройка среды разработки в Главе 1, Получение
Начал с .NET MAUI, подробнее.


Исходный код этой главы доступен в следующем репозитории GitHub:

https://github.com/PacktPublishing/.NET-MAUI-Cross-PlatformApplication-Development/tree/main/Chapter10

Исходный код можно загрузить с помощью следующей команды Git:

```
git clone -b глава 10 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development PassXYZ.Vault2
```

# Создание дополнительных компонентов Razor

Мы разработали модальные диалоговые компоненты в главе 9 «Компоненты Razor и привязка данных». В этом
главу, мы уточним наш код, чтобы удалить повторяющийся код на страницах Items и ItemDetail.
и преобразовать дублированный код в компоненты Razor. Мы создадим следующие компоненты:

* Navbar — это компонент для отображения панели навигации.

* Выпадающий список — это компонент для поддержки контекстного меню.

* ListView — это компонент для отображения списка элементов.

Компонент ListView является самым сложным, поэтому мы оставим его до конца этого раздела.
Давайте сначала поработаем над Navbar и Dropdown.

# Создание компонента Navbar

Давайте посмотрим на пользовательский интерфейс панели навигации на рис. 10.1. Мы видим, что панель навигации содержит кнопку «Назад».
кнопка, заголовок и кнопка «Добавить»:

![изображение](https://user-images.githubusercontent.com/26972859/231983192-19fee52b-9421-4702-8194-3e89f9a0bf28.png)

Рисунок 10.1: Панель навигации

Текущий код панели навигации отображается рядом, и этот фрагмент кода дублируется на обоих
Страницы Items и ItemDetail:

```
<div класс="контейнер">
 <дел класс = "строка">
 <див класс="кол-12">
 <h1>
@if (selectedItem?.GetParentLink() != null) { ❶
 <a class="btn btn-outline-dark"
 href="@selectedItem?.GetParentLink()">
 <span class="oi oi-chevron-left"
 ария-скрытый="true"></span></a> ❷
 }
 @(" " + Название) ❸
 <тип кнопки="кнопка"
 class="btn btn-outline-dark float-end"
 data-bs-toggle = "модальный"
 data-bs-target="#@_dialogEditId"
 @onclick="@(() => _isNewItem=true)"> ❹
 <span class="oi oi-plus" aria-hidden="true">
 </span>
 </кнопка>
 </h1>
 </div>
 </div>
</div>
```
В предыдущем коде ❶ кнопка «Назад» отображается при наличии родительской ссылки. ❷ Кнопка «Назад»
реализован как тег ```<a>```. ❸ Заголовок представляет собой строку и отображается как часть тега ```<h1>```. ❹
Кнопка добавления реализована в виде тега ```<button>```. Стиль Bootstrap используется для форматирования как Back, так и

Добавьте кнопки.

Чтобы преобразовать предыдущий код в компонент Razor, мы можем создать новый компонент Razor в
проект PassXYZ.BlazorUI и назовите его Navbar. Navbar может отображать элементы пользовательского интерфейса в
Рисунок 10.1, который включает кнопку «Назад», заголовок и кнопку «Добавить». Чтобы разделить пользовательский интерфейс и логику, мы
создайте файл кода программной части C# Navbar.razor.cs и разметку Razor, Navbar.razor. Мы
определить параметры компонента и обработчики событий в файле кода программной части C#, как показано в листинге 10.1:

**Листинг 10.1: Navbar.razor.cs (https://epa.ms/Navbar10-1)**

```Csharp
общедоступный частичный класс Navbar
{
 [Параметр]
 публичная строка? Родительская ссылка {получить; набор; } ❶
 [Параметр]
публичная строка? DialogId { получить; набор; } ❷
 [Параметр]
 публичная строка? Название {получить; набор; } ❸
 [Параметр]
 public EventCallback<MouseEventArgs> OnAddClick { get;
 набор; } ❹
 частное недействительное OnClickClose (MouseEventArgs e) {
 OnAddClick.InvokeAsync();
 }
}
```
В Navbar определены четыре параметра компонента и обработчик событий. Мы можем установить
родительская ссылка кнопки «Назад» с параметром ParentLink ❶. Значение заголовка установлено в
параметр Заголовок ❸. Для кнопки «Добавить» нам нужно предоставить идентификатор и обработчик события для
диалоговое окно, чтобы использовались параметры DialogId ❷ и OnAddClick ❹.
Теперь давайте посмотрим на файл Razor панели навигации в листинге 10.2:

** Листинг 10.2: Navbar.razor (https://epa.ms/Navbar10-2)**

```
@namespace PassXYZ.BlazorUI
<div класс="контейнер">
 <дел класс = "строка">
 <див класс="кол-12">
 <h1>
 @if (Родительская ссылка != ноль) { ①
 <a class="btn btn-outline-dark"
 href="@ParentLink"> ①
 <span class="oi oi-chevron-left"
 ария-скрытый="true"></span>
 </a>
 }
 @(" " + Название) ③
 <тип кнопки="кнопка"
 class="btn btn-outline-dark float-end"
 data-bs-toggle = "модальный"
 data-bs-target="#@DialogId" ②
 @onclick="OnClickClose"> ④
 <span class="oi oi-plus" aria-hidden="true">
 </span>
 </кнопка>
 </h1>
 </div>
 </div>
</div>
```
Мы видим, что код очень похож на код в Items и ItemDetail. Разница в том,
что мы заменили значение жесткого кода параметрами компонента (ParentLink ①, DialogId ②,
Заголовок ③ и OnClickClose ④). С помощью этого нового компонента Navbar мы можем заменить код
в Items с помощью компонента Navbar следующим образом:

```
<Navbar ParentLink="@selectedItem?.GetParentLink()"
 Title="@Title" DialogId="@_dialogEditId"
 OnAddClick="@(() => {_isNewItem=true;})" />
```
И мы можем заменить код в ItemDetail следующим образом:

```
<Navbar ParentLink="@selectedItem?.GetParentLink()"
Title="@selectedItem?.Name" DialogId="@_dialogEditId"
OnAddClick="@(() => {_isNewField=true;})" />
```
Как мы видим, мы доработали код, удалив дублирующийся код, и новый код выглядит намного лучше.
элегантно и лаконично.
Мы сделали работу для Navbar. Теперь давайте перейдем к компоненту Dropdown.

# Создание компонента Dropdown для контекстного меню

Чтобы создать компонент, похожий на контекстное меню, мы можем повторно использовать компонент Bootstrap Dropdown.
Как видно на рис. 10.2, контекстное меню включает в себя кнопку контекстного меню и список пунктов меню.
Когда пользователи нажимают кнопку контекстного меню, отображается список пунктов меню:

![изображение](https://user-images.githubusercontent.com/26972859/231984248-0b203f6a-3c83-4d3a-a3e9-86808186ae0a.png)

Рисунок 10.2: Контекстное меню

Текущий код контекстного меню дублируется на страницах Items и ItemDetail,
которые показаны здесь:

```
<button class="opacity-50 btn btn-light dropdown-toggle"
 тип = «кнопка» id = «itemsContextMenu»
 данные-bs-toggle="раскрывающийся список"
 ария-расширенная = "ложь"
 @onclick="@(() => listGroupItem=элемент)">
 <span class="oi oi-menu" aria-hidden="true"></span>
</кнопка>
<ul class="выпадающее меню"
 aria-labeledby="itemsContextMenu">
 <li><button class="dropdown-item" data-bs-toggle="modal"
 data-bs-target="#@_dialogEditId"
 @onclick="@(() => _isNewItem=false)">
 Редактировать
 </кнопка></li>
 <li><button class="dropdown-item" data-bs-toggle="modal"
 data-bs-target="#@_dialogDeleteId">
 Удалить
 </кнопка></li>
</ul>
```
Компонент Dropdown Bootstrap включает в себя кнопку и неупорядоченный список. Нам нужно определить
обработчик события кнопки для выполнения действия. В предыдущем коде мы установили переменную item в
списокГрупповойЭлемент. Для пунктов меню каждый пункт меню реализован как тег ```<button>``` и
принимает идентификатор диалога и обработчик событий в качестве параметров. При выборе пункта меню соответствующий
появится модальный диалог.
Мы можем создать два новых компонента Razor в проекте PassXYZ.BlazorUI и назвать их как
Выпадающий список и элемент меню. Мы также можем реализовать их в файле кода программной части C# (листинг 10.4).
и файл Razor (листинг 10.3) для разделения пользовательского интерфейса и логики, что мы сейчас и сделаем.
Сначала рассмотрим пользовательский интерфейс компонента Dropdown в листинге 10.3:

**Листинг 10.3: Dropdown.razor (https://epa.ms/Dropdown10-3)**

```
@namespace PassXYZ.BlazorUI
<button class="opacity-50 btn btn-light dropdown-toggle"
 тип = «кнопка» id = «itemDetailContextMenu»
 данные-bs-toggle="раскрывающийся список"
 aria-expanded="false" @onclick="OnClick">
 <span class="oi oi-menu" aria-hidden="true"></span>
</кнопка> ❶
<ul class="выпадающее меню"
 aria-labeledby="itemDetailContextMenu">
 @ChildContent
</ul> ❷
```
В компоненте Dropdown мы определяем кнопку ❶ и неупорядоченный список ❷. Событие щелчка
Кнопка определяется как обработчик события OnClick. Элементы в неупорядоченном списке отображаются как дочерние
содержимое раскрывающегося списка. Параметры компонента определяются в раскрывающемся списке C#.
Файл кода программной части razor.cs в листинге 10.4:

**Листинг 10.4: Dropdown.razor.cs (https://epa.ms/Dropdown10-4)**

```
пространство имен PassXYZ.BlazorUI;
раскрывающийся список общедоступного частичного класса
{
 [Параметр]
 public EventCallback<MouseEventArgs> OnClick {get;set;}①
 [Параметр]
общественность RenderFragment ChildContent { получить; набор; } ②
}
```
В Dropdown.razor.cs два параметра компонента — OnClick ① и ChildContent.
② – определены.
Компонент MenuItem может отображаться как дочернее содержимое компонента Dropdown. Мы
можно увидеть код пользовательского интерфейса MenuItem в листинге 10.5:

** Листинг 10.5: MenuItem.razor (https://epa.ms/MenuItem10-5)**

```
@namespace PassXYZ.BlazorUI
<li>
 <button class="dropdown-item" data-bs-toggle="modal"
 data-bs-target="#@Id" @onclick="OnClick">
 @ChildContent
 </кнопка>
</li>
```
Компонент MenuItem определяет три параметра компонента — Id, OnClick и ChildContent.
Эти параметры определены в MenuItem.razor.cs в листинге 10.6.

**Листинг 10.6: MenuItem.razor.cs (https://epa.ms/MenuItem10-6)**

```
пространство имен PassXYZ.BlazorUI;
общедоступный частичный класс MenuItem
{
 [Параметр]
 публичная строка? идентификатор {получить; набор; } ❶
 [Параметр]
 public EventCallback<MouseEventArgs> OnClick {get; установить;} ❷
 [Параметр]
 общественность RenderFragment ChildContent { получить; набор; } ❸
}
```
❶ Параметр Id используется для указания идентификатора диалогового окна при щелчке элемента меню. ❷ По клику
используется для регистрации обработчика события нажатия кнопки. ❸ ChildContent используется для отображения
дочерний контент, такой как название пункта меню.

❶ Параметр Id используется для указания идентификатора диалогового окна при щелчке элемента меню. ❷ По клику
используется для регистрации обработчика события нажатия кнопки. ❸ ChildContent используется для отображения
дочерний контент, такой как название пункта меню.

```xml
<Dropdown OnClick="@(() => currentItem.
Данные=listGroupItem=элемент)">
 <MenuItemId="@_dialogEditId"
 OnClick="@(() => _isNewItem=false)">Изменить</MenuItem>
 <MenuItem Id="@_dialogDeleteId">Удалить</MenuItem>
</ выпадающий>
```
На странице ItemDetail контекстное меню реализовано следующим образом:

```
<Выпадающий список по клику="@(() = >
 {currentField.Data=listGroupField=поле;})">
 <MenuItemId="@_dialogEditId"
 OnClick="@(() => _isNewField=false)">Изменить</MenuItem>
 <MenuItem Id="@_dialogDeleteId">Удалить</MenuItem>
 @if (field.IsProtected) {
<MenuItem OnClick="OnToggleShowPassword">
 @(field.IsHide ? "Показать":"Скрыть")
</элемент меню>
 }
</ выпадающий>
```
После доработки кода страниц Items и ItemDetail мы создали модальный диалог,
панель навигации и компоненты контекстного меню. Теперь код выглядит намного элегантнее и лаконичнее.
Тем не менее, у нас еще есть место для дальнейшей доработки кода. Основная логика пользовательского интерфейса как в элементах, так и в
Страницы ItemDetail представляют собой список. Мы можем доработать эту часть кода как компонент ListView. К
создать компонент ListView, нам нужно использовать расширенную функцию, называемую шаблонными компонентами.

# Использование шаблонных компонентов

Чтобы создать компонент Razor, параметры компонента являются каналами для родительского и дочернего взаимодействия.
В главе 9 «Компоненты Razor и привязка данных» мы представили вложенные компоненты. Мы упоминали
специальный параметр компонента ChildContent типа RenderFragment. Родитель
Компонент может установить содержимое дочернего компонента с помощью этого параметра. Например, содержание
для MenuItem в следующем коде можно задать строку HTML:

```
<MenuItemId="@_dialogDeleteId">
 <strong>Удалить</strong>
</элемент меню>
```
Мы можем сделать это, потому что MenuItem определяет следующий параметр компонента, как мы можем видеть в
Листинг 10.6:

```Csharp
[Параметр]
общественность RenderFragment ChildContent { получить; набор; }
```
Если мы хотим явно указать параметр ChildContent, мы также можем сделать это:

```xml
<MenuItemId="@_dialogDeleteId">
 <дочернее содержимое>
 <strong>Удалить</strong>
 </ChildContent>
</элемент меню>
```
ChildContent — это специальный параметр компонента, который мы можем неявно использовать в языке разметки. К
используем ChildContent, мы определяем компонент, который может принимать шаблон пользовательского интерфейса RenderFragment
введите в качестве параметра компонента. Мы можем определить более одного шаблона пользовательского интерфейса в качестве параметра, когда мы
создать новый компонент. Такой компонент называется шаблонным компонентом.
Фрагмент рендеринга типа RenderFragment представляет сегмент пользовательского интерфейса для рендеринга. Там
также является универсальной версией, ```RenderFragment<TValue>```, которая принимает параметр типа. Мы можем
указать тип при вызове RenderFragment.

# Создание компонента ListView

Чтобы создать ListView, нам нужно использовать несколько шаблонов пользовательского интерфейса в качестве параметров компонента. Мы можем создать
новый компонент Razor в проекте PassXYZ.BlazorUI и назовите его ListView. Как мы это сделали
для панели навигации и контекстного меню мы разделяем пользовательский интерфейс и код в файле Razor (листинг 10.7) и
Файл кода программной части C# (листинг 10.8):

# Листинг 10.7: ListView.razor (https://epa.ms/ListView10-7)

```
@namespace PassXYZ.BlazorUI
@типпарам TItem
<div class="список-группа">
 @if (Заголовок!= null) {
 @Заголовок ❶
 }
 @if (Строка != null && Items != null) {
 @foreach (элемент var в элементах) {
<div class="выпадающий список-группа-элемент
 список-группа-элемент-действие
 d-flex gap-1 py-2" style="border: none"
 ария-текущая = "истина">
 @Row.Invoke(предмет) ❷
 </div>
 }
 }
 @if (Нижний колонтитул!= ноль) {
 <div класс="контейнер">
 <статья>@Footer</статья>
 </дел> ❸
 }
</div>
```

В файле ListView Razor мы определяем три шаблона пользовательского интерфейса — заголовок ❶, строку ❷ и нижний колонтитул ❸.
Мы визуализируем верхний и нижний колонтитулы так же, как ChildContent, но параметр компонента Row
выглядит иначе. Мы визуализируем это следующим образом:

```@Row(item)```

Или мы можем отобразить это так:

```@Row.Invoke(item)```

Мы визуализируем его с аргументом элемента. Тип Row - ```RenderFragment<TValue>```, как мы
можно увидеть в листинге 10.8:

**Листинг 10.8: ListView.razor.cs (https://epa.ms/ListView10-8)**

```
пространство имен PassXYZ.BlazorUI;
общедоступный частичный класс ListView<TItem>
{
 [Параметр]
 публичный RenderFragment? Заголовок {получить; набор; } ①
 [Параметр]
 общедоступный RenderFragment<TItem>? Строка {получить; набор; } ②
 [Параметр]
 общедоступный IEnumerable<TItem>? Предметы {получить; набор; } ③
 [Параметр]
 публичный RenderFragment? Нижний колонтитул { получить; набор; } ④
}
```
Мы определяем ListView как общий тип ````ListView<TItem>``` с параметром типа TItem. в
Компонент ListView, мы можем определить заголовок представления списка, используя параметр Заголовок ① и нижний колонтитул
используя нижний колонтитул ④. ListView может быть привязан к любой коллекции данных ```IEnumerable<TItem>```
введите с помощью параметра Items ③. Параметр Row ② можно использовать для определения шаблона пользовательского интерфейса.
для отдельного элемента в цикле foreach.

# Использование компонента ListView

Теперь мы можем посмотреть на использование компонента ListView на страницах Items и ItemDetail.
Мы используем страницу ItemDetail в качестве примера здесь:

```
<элементы ListView="поля"> ❶
 <Строка Context="поле"> ❷
 @if (field.ShowContextAction == ноль) {
 <span class="oi oi-pencil" aria-hidden="true"></span>
 <div class="d-flex зазор-2 w-100
 выровнять-содержание-между">
 <дел>
 <h6 class="mb-0">@field.Key</h6>
 <p class="mb-0">@field.Value</p>
 </div>
 </div>
 <Раскрывающийся список
 OnClick="@(() =>
 {currentField.Data=listGroupField=поле;})">
 <MenuItemId="@_dialogEditId"
 OnClick="@(() => _isNewField=false)">
 Редактировать
 </элемент меню>
 <MenuItem Id="@_dialogDeleteId">Удалить</MenuItem>
 @if (field.IsProtected) {
 <MenuItem OnClick="OnToggleShowPassword">
 @(field.IsHide ? "Показать":"Скрыть")
 </элемент меню>
 }
 </ выпадающий>
 }
 </строка>
 <Нижний колонтитул>
 @((MarkupString)примечания)
 </нижний колонтитул>
</ListView>
```
Поскольку мы определяем Header, Row и Footer как необязательные параметры, нам не нужно указывать все
их. На странице ItemDetail мы используем Row и Footer. ❶ Нам нужно передать список полей в
Сначала параметр Items. ❷ Каждое поле в цикле foreach передается в ListView в качестве аргумента.
в строку, которая определена здесь:

```<Row Context="field">```

Значение «поле» свойства Context используется для указания аргумента для строки. Внутри пользовательского интерфейса
шаблон Row, мы отображаем ключевое значение поля и создаем контекстное меню с помощью раскрывающегося списка
и компоненты MenuItem, которые мы реализовали в предыдущем разделе.
Используя компонент ListView, мы видим, что реализация страницы ItemDetail
теперь выглядит намного лучше.
  
Мы внесли улучшения, создав собственные компоненты Razor.

В Blazor у нас есть несколько вариантов разработки пользовательского интерфейса. Мы можем использовать HTML/CSS для дизайна пользовательского интерфейса. На
Помимо HTML/CSS, мы можем создавать собственные компоненты Razor для улучшения дизайна и реализации.
Для нас также доступно множество сторонних библиотек компонентов Razor, и мы также можем использовать ASP.
NET Core встроенные компоненты Razor.
В следующем разделе мы будем поддерживать проверку данных с помощью встроенных в ASP.NET компонентов Razor.

# Встроенные компоненты и проверка

В нашем приложении мы реализуем EditorDialog как редактор ключевых значений. Когда мы создаем или редактируем элемент или
поле, мы используем его для редактирования пары данных ключ-значение. EditorDialog построен с использованием фреймворка Bootstrap.
Одна ключевая функция, отсутствующая в EditorDialog, заключается в том, что он не поддерживает проверку данных. Валидация данных
включает два слоя — слой пользовательского интерфейса и логику. Мы можем реализовать простую логику проверки данных на C#, но
пользовательский интерфейс проверки данных намного сложнее. Мы еще не сделали этого на уровне пользовательского интерфейса. В обоих

страницы Items и ItemDetail мы реализовали простую логику проверки данных. Мы можем просмотреть
логика проверки данных в методе UpdateItemAsync() страницы Items:

```Csharp
частная асинхронная задача<bool> UpdateItemAsync(строковый ключ, строка
ценить)
{
 если (listGroupItem == null) вернуть false;
 если (строка.IsNullOrEmpty(ключ) ||
 строка.IsNullOrEmpty(значение))
 вернуть ложь;
 listGroupItem.Name = ключ;
 listGroupItem.Notes = значение;
 если (_isNewItem) {…}
 еще {...}
 СостояниеИзменено();
 вернуть истину;
}
```
В EditorDialog после завершения редактирования вызывается UpdateItemAsync() для сохранения
данные. Прежде чем продолжить, мы проверяем значение аргументов ключа и значения. Если кто-то из них
имеет значение null, мы просто возвращаем false. Здесь нет проблем с логикой программы, но мы должны уведомить
пользователей об ошибке, связанной с сохранением данных. Со встроенными компонентами ASP.NET проверка данных
поддерживается на уровне пользовательского интерфейса. Пользователь может получить мгновенную обратную связь об ошибке.

# Использование встроенных компонентов

На самом деле мы использовали встроенные компоненты в предыдущих главах. Когда мы представили маршрутизацию и
расположение компонентов Razor, мы использовали Router, RouteView, LayoutView и MainLayout
компоненты в Main.razor. Все они являются встроенными компонентами.
В этом разделе мы рассмотрим встроенные компоненты ввода, которые мы можем использовать для улучшения опыта.
компонентов редактирования с поддержкой проверки данных. В следующей таблице приведен список встроенных
входные компоненты:
  
|Компонент ввода|HTML-тег|
|:--------------|:-------|
|InputCheckbox|```<input type="checkbox">```|
|```InputDate<TValue>```|```<input type="date">```|
|InputFile|```<input type="file">```|
|```InputNumber<TValue>```|```<input type="number">```|
|```InputRadio<TValue>```|```<input type="radio">```|
|```InputRadioGroup<TValue>``` |Группа потомков ```InputRadio<TValue>```|
|```InputSelect<TValue>```|```<select>```|
|InputText|```<input>```|
|InputTextArea |```<textarea>```|
|EditForm|```<форма>```|
  
Таблица 10.1: Встроенные компоненты

Чтобы найти подробную информацию о встроенных компонентах ввода, вы можете проверить следующее
Документ Майкрософт:
  
https://learn.microsoft.com/en-us/aspnet/core/blazor/forms-and-inputcomponents?view=aspnetcore-6.0

В таблице 10.1 мы видим список компонентов ввода и компонент EditForm. встроенный
компоненты ввода — это расширенные версии соответствующих элементов HTML, перечисленных в правом столбце. Когда мы используем встроенные компоненты ввода с EditForm, EditForm может координировать
события проверки и отправки. Встроенные компоненты ввода могут проверять ввод пользователя, когда
подается форма.

# Использование компонента EditForm

Компонент EditForm представляет собой расширенную версию HTML-элемента <form>. Чтобы использовать EditForm,
мы можем обратиться к следующему коду, который показывает пустой компонент EditForm:

```
<EditForm Model="ModelData" OnSubmit="HandleSubmit"
OnInValidSubmit="HandleInValidSubmit"
OnValidSubmit="HandleValidSubmit">
</EditForm>
```
Или его можно использовать по-другому:

```
<EditForm EditContext="_editContext" OnSubmit="HandleSubmit"
 OnInValidSubmit="HandleInValidSubmit"
 OnValidSubmit="HandleValidSubmit">
</EditForm>
```
Мы можем передать ему данные, используя параметр Model или EditContext.

Мы можем указать экземпляр класса как модель для редактирования в EditForm. Экземпляр EditContext
будет создан на основе экземпляра модели, назначенного EditForm. EditContext используется как
каскадное значение для других компонентов в форме. Мы также можем указать экземпляр EditContext
напрямую, если мы хотим взять его под контроль.
  
Чтобы обработать результат редактирования формы, мы можем зарегистрировать следующие функции обратного вызова:

  * OnInvalidSubmit — этот обратный вызов будет вызван, когда форма будет отправлена, а EditContext недействителен.

  * OnSubmit — этот обратный вызов будет вызываться при отправке формы.

  * OnValidSubmit — этот обратный вызов будет вызываться, когда форма отправлена ​​и EditContext действителен.

  Мы будем использовать компонент EditForm и встроенные компоненты ввода для создания нового EditFormDialog.
компонент для улучшения нашего редактора ключевых значений с поддержкой проверки данных.

# Создание компонента EditFormDialog

Для поддержки проверки данных компонент EditForm должен быть привязан к модели, использующей данные.
аннотации. Для редактирования формы следует использовать встроенные компоненты ввода, чтобы расширенные
можно использовать такие функции, как проверка данных.
Во-первых, нам нужно создать класс модели KeyValueData, который можно использовать для редактирования значения ключа в
Проект PassXYZ.BlazorUI, как показано в листинге 10.9:

**Листинг 10.9: KeyValueData.cs (https://epa.ms/KeyValueData10-9)**

```
использование System.ComponentModel.DataAnnotations; ❸
с помощью KPCLib;
используя PassXYZLib;
пространство имен PassXYZ.BlazorUI;
открытый класс KeyValueData<T>: IKeyValue {
 [Требуется (ErrorMessage = "{0} не может быть пустым")]
 [Отображение (Имя = "Это поле")]
 общедоступная строка Ключ { ❶
 получать {
 если (Данные — элемент Item) { return item.Name; }
 если (данные - поле поля) { return field.Key; }
 возвращаемая строка. Пусто;
}
 набор {
 если (Данные — элемент Item) { item.Name = value;
 Изменено = Истина; }
 если (данные — поле поля) { field.Key = value;
 Изменено = Истина; }
 }
 }
 [Требуется (ErrorMessage = "{0} не может быть пустым")]
 [Отображение (Имя = "Это поле")]
 общедоступная строка Значение { ❷
 получать {
 если (данные - элемент элемента) { return item.Notes; }
 если (данные - поле поля) { return field.EditValue; }
 возвращаемая строка. Пусто;
 }
 набор {
 если (Данные — элемент Item) { item.Notes = value;
 Изменено = Истина; }
 если (данные - поле поля) { field.EditValue = значение;
 Изменено = Истина; }
 }
 }
 общественное логическое значение IsChanged {получить; набор; } = ложь;
 общественное логическое значение IsValid {
 получать {
 вернуть !(string.IsNullOrEmpty(Key) ||
 строка.IsNullOrEmpty(Значение));
 }
 }
 общественный Т? Данные {получить; набор; } ❹
 общедоступные KeyValueData () {
 if (Данные — элемент Item) { item = new NewItem(); }
 если (данные — это поле поля) { field = new NewField(); }
 }
```
Класс KeyValueData<T> используется для создания экземпляра модели для EditForm. Это общий
тип и реализует интерфейс IKeyValue, который определяет свойства, которые необходимо реализовать.
В классе KeyValueData<T> мы определяем свойства Key ❶ и Value ❷, IsChanged,
Является действительным и данные ❹. Мы видим, что мы помечаем свойства Key и Value аннотацией данных.
Атрибуты [Обязательный] и [Отображать]. Атрибут [Обязательный] указывает, что пользователь должен ввести
ценность. Атрибут [Display] определяет имя, отображаемое для свойства в сообщении об ошибке.
проверки данных, как показано на рисунке 10.3.
И [Required], и [Display] определены в System.ComponentModel.
пространство имен DataAnnotations ❸.
Класс KeyValueData<T> является универсальным классом и принимает параметр типа T для указания фактического
тип данных для редактирования. Свойство данных ❹ определяется как тип T. Мы можем передать либо Item, либо
Класс поля в качестве параметра типа для свойства Data. Свойство Key или Value привязано к
свойство экземпляра элемента или поля, хранящегося в свойстве данных

![изображение](https://user-images.githubusercontent.com/26972859/231991559-507ad884-5323-4d35-9960-924ff4ffa203.png)

Рисунок 10.3: EditFormDialog (добавление нового элемента)

На рис. 10.3 мы видим, что сообщения об ошибках будут отображаться, когда пользователи отправят форму с
пустое значение в поле ключа или значения. Чтобы включить проверку данных, нам также нужно добавить
Компонент <DataAnnotationsValidator/> в EditForm, как показано здесь:

```
<EditForm class="строка gx-2 gy-3" Модель="@ModelData"
 Онвалидсубмит="@HandleValidSubmit">
 <DataAnnotationsValidator/>
 ...
</EditForm>
```
Используя EditForm, довольно легко поддерживать проверку данных. Чтобы включить проверку данных с помощью EditForm,
Следуй этим шагам:

1. Привяжите EditForm к модели, которая использует атрибуты аннотаций данных.
2. Добавьте компонент <DataAnnotationsValidator/> в EditForm.
3. Используйте встроенные компоненты ввода для редактирования

Существует длинный список встроенных проверок, определяемых атрибутами. Вы можете узнать больше информации о
их в документации Microsoft в разделе «Дополнительная литература». Некоторые из них перечислены здесь:

• [ValidateNever]: указывает, что свойство или параметр следует исключить из проверки.
• [Сравнить]: проверяет совпадение двух свойств в модели.
• [EmailAddress]: проверяет, имеет ли свойство формат электронной почты.
• [Телефон]: проверяет, имеет ли свойство формат телефонного номера.
• [Диапазон]: проверяет, попадает ли значение свойства в указанный диапазон.
• [RegularExpression]: проверяет соответствие значения свойства указанному регулярному выражению.
• [Обязательный]: проверяет, что поле не является пустым.
• [StringLength]: проверяет, не превышает ли значение строкового свойства указанный предел длины.
• [URL]: проверяет, имеет ли свойство формат URL.

С введением встроенных компонентов мы можем создать новый компонент Razor, EditFormDialog,
в проекте PassXYZ.BlazorUI. Реализация EditFormDialog<TItem>
можно найти в листинге 10.10 и листинге 10.11:

** Листинг 10.10: EditFormDialog.razor (https://epa.ms/EditFormDialog10-10)**

```
@namespace PassXYZ.BlazorUI
@типпарам TItem
<div class="modal fade" id=@Id tabindex="-1"
 aria-labeledby="ModelLabel" aria-hidden="true">
 <div class="модальный диалог">
 <div class="modal-content">
 <div class="modal-header">
 <h5 class="modal-title" id="ModelLabel">
 @ModelData.Key</h5>
<button type="button" class="btn-close"
 data-bs-dismiss="модальный"
 aria-label="Закрыть"></кнопка>
 </div>
 <div class="modal-body">
 <EditForm class="row gx-2 gy-3" Model="@ModelData" ❶
 Онвалидсубмит="@HandleValidSubmit">
 <DataAnnotationsValidator /> ❷
 @if (IsKeyEditingEnable) {
 <div class="form-group">
 <InputText id="Name" class="form-control" ❸
 @oninput="Обработчик ключей"
 заполнитель=@KeyPlaceHolder
 @bind-Value="ModelData.Key" />
 <ValidationMessage For="()=>ModelData.Key"/> ❺
 </div>
 }
 @ChildContent
 <div class="form-group">
 <InputTextArea id="Value" class="form-control" ❹
 @oninput="Обработчик ключей"
 заполнитель=@ValuePlaceHolder
 @bind-Value="ModelData.Value" />
 <ValidationMessage For="()=>ModelData.Value"/> ❺
 </div>
 <див класс="кол-12">
 <button type="button" class="btn btn-secondary"
 data-bs-dismiss="модальный"
 @onclick="OnClickClose">
 @CloseButtonText
 </кнопка>
 <button type="submit" class="btn btn-primary"
 данные-bs-dismiss="@dataDismiss"
 @onclick="OnClickSave">
 @SaveButtonText
 </кнопка>
</div>
 </EditForm>
 </div>
 </div>
 </div>
</div>
```
Как видно из разметки Razor в листинге 10.10, мы создаем EditFormDialog<TItem>
компонент, использующий Bootstrap Modal. Он включает компонент EditForm ❶ в тело модального окна.
Моделью, привязанной к EditForm, является ModelData типа KeyValueData<TItem>, определенного в
Листинг 10.11. Компонент DataAnnotationsValidator ❷ определен для проверки данных.
Мы используем InputText ❸ для редактирования ключей и InputTextArea ❹ для редактирования значений. 
Компонент проверки ValidationMessage ❺ используется для определения сообщения об ошибке для проверки.
В ValidationMessage нам нужно указать поле с помощью свойства For следующим образом:

```<ValidationMessage For="() => ModelData.Key" />```

Формат сообщения об ошибке определяется с помощью свойства ErrorMessage свойства [Required].
атрибут следующим образом:

```
[Требуется (ErrorMessage = "{0} не может быть пустым")]
 [Отображение (Имя = "Это поле")]
 общедоступная строка Значение { ... }
```
Как видно из листинга 10.11, параметры компонентов и функции обратного вызова для обработки событий
определены в EditFormDialog.razor.cs:

** Листинг 10.11: EditFormDialog.razor.cs (https://epa.ms/EditFormDialog10-11)**

```
пространство имен PassXYZ.BlazorUI;
общедоступный частичный класс EditFormDialog<TItem> {
 [Параметр]
 общедоступный идентификатор строки {получить; набор; } = по умолчанию!;
 [Параметр]
 общественность RenderFragment ChildContent { получить; набор; }
 [Параметр]
 публичное действие? При закрытии {получить; набор; }
 [Параметр]
public Func<string, string, Task<bool>>? OnSaveAsync {
 получать; набор; }
 [Параметр]
 [Не ноль]
 общедоступная строка CloseButtonText { получить; набор; } = "Отмена";
 [Параметр]
 [Не ноль]
 публичная строка SaveButtonText { получить; набор; } = "Сохранить";
 [Параметр]
 public KeyValueData<TItem> ModelData { get; набор; }
 [Параметр]
 публичная строка? KeyPlaceHolder { получить; набор; }
 [Параметр]
 публичная строка? ValuePlaceHolder { получить; набор; }
 bool _isKeyEditingEnable = ложь;
 [Параметр]
 общественное логическое значение IsKeyEditingEnable ...
 [Параметр]
 общедоступный EventCallback<bool>?
 IsKeyEditingEnableChanged{получить; набор;}
 приватная строка dataDismiss = string.Empty;
 общественный EditFormDialog () {
 Данные модели = новые();
 }
 частный недействительным OnClickClose () {
 При закрытии?.Вызвать();
 }
 частное недействительное OnClickSave () {
 Установить ТекстКнопкиСохранить();
 }
 частная асинхронная задача HandleValidSubmit() {
 если (OnSaveAsync != null && ModelData.IsChanged) {
 await OnSaveAsync(ModelData.Key, ModelData.Value);
 ModelData.IsChanged = ложь;
 }

 частный недействительный KeyHandler () {
 SetSaveButtonText (истина);
 }
 private void SetSaveButtonText (логическое значение изменено = false) {
 если (ModelData == null) вернуть;
 если (!ModelData.IsValid || изменено) {
 dataDismiss = строка.Пусто;
 SaveButtonText = "Сохранить";
 }
 еще {
 dataDismiss = "модальный";
 SaveButtonText = "Закрыть";
 }
 }
}
```
Мы можем обратиться к параметрам компонента EditFormDialog<TItem> в таблице 10.2.

|Параметр|Описание|
|:--------|:----------|
|Id|Идентификатор диалога. Это используется Bootstrap.|
|ChildContent|Фрагменты рендеринга дочернего содержимого.|
|OnClose|Обратный вызов для кнопки «Закрыть».|
|OnSaveAsync|Обратный вызов для кнопки «Сохранить».|
|CloseButtonText|Текст кнопки «Закрыть».|
|SaveButtonText|Текст кнопки Сохранить.|
|ModelData|Данные модели привязаны к EditForm.|
|KeyPlaceHolder|Заполнитель ключа.|
|ValuePlaceHolder|Заполнитель значения|
|IsKeyEditingEnable|Включить или отключить редактирование ключей|
|IsKeyEditingEnableChanged |Обратный вызов для двух привязок IsKeyEditingEnable|

Таблица 10.2: Параметры компонента EditFormDialog<TItem>

После того, как мы создали компонент EditFormDialog<TItem>, мы выполнили всю оптимизацию
нашего кода. Давайте рассмотрим окончательный код Items (листинг 10.12) и ItemDetail (листинг
10.13) стр.:

** Листинг 10.12: Items.razor (https://epa.ms/Items10-12)**

```
@страница "/группа"
@page "/group/{SelectedItemId}"
@использование System.Diagnostics
@используя PassXYZLib
<Navbar ParentLink="@selectedItem?.GetParentLink()"
 Заголовок="@Заголовок" ❶
 DialogId="@_dialogEditId"
 OnAddClick="@(() =>
 {_isNewItem=истина;
 currentItem.Data=listGroupItem=_newItem;
 _newItem.Name="";_newItem.Notes="";})" />
<элементы ListView="элементы"> ❷
 <Строка Контекст="элемент">
<img src="@item.GetIcon()" alt="twbs"
 ширина = "32" высота = "32"
 class="rounded-circle flex-shrink-0 float-start">
<a href="@item.GetActionLink()"
 class="элемент-группы-списка...">
 <div class="d-flex"><div>
 <h6 class="mb-0">@item.Name</h6>
 <p class="mb-0 opacity-75">@item.Description</p>
 </дел></дел>
 </a>
<Выпадающий список по клику="@(() => ❸
 currentItem.Data=listGroupItem=элемент)">
 <MenuItemId="@_dialogEditId" OnClick="@(() =>
 _isNewItem=false)">Изменить</MenuItem>
 <MenuItem Id="@_dialogDeleteId">Удалить</MenuItem>
 </ выпадающий>
 </строка>
</ListView>
<EditFormDialogId="@_dialogEditId" ❹
 ModelData="@currentItem" IsKeyEditingEnable="true"
 OnSaveAsync="UpdateItemAsync" KeyPlaceHolder="Имя элемента"
 ValuePlaceHolder="Пожалуйста, дайте описание">
 @if (_isNewItem) {
<InputSelect @bind-Value="_newItem.SubType"
 класс = "выбор формы">
 <option selected value=@ItemSubType.Group>
 @ItemSubType.Group</option>
 <option value=@ItemSubType.Entry>
 @ItemSubType.Entry</option>
 <option value=@ItemSubType.PxEntry>
 @ItemSubType.PxEntry</option>
 <option value=@ItemSubType.Notes>
 @ItemSubType.Примечания</option>
 </InputSelect>
 }
</EditFormDialog>
<CascadingValue Value="@_dialogDeleteId" Name="Id">
<ConfirmDialog Title=@listGroupItem.Name ❺
 OnConfirmClick="DeleteItemAsync" />
</CascadingValue>
```

В окончательном коде Items.razor мы используем Navbar ❶ для создания панели навигации. В теле
странице мы используем компонент ListView ❷ для отображения списка элементов. Для каждого элемента шаблон пользовательского интерфейса
определяется в свойстве Row. В шаблоне пользовательского интерфейса мы отображаем имя элемента, описание и контекст.
меню. В контекстном меню мы используем компонент Dropdown ❸ для поддержки редактирования или удаления
элемент. Для действий «Добавить», «Изменить» или «Удалить» EditorFormDialog ❹ или ConfirmDialog ❺
используется для выполнения соответствующих действий.
В ItemDetail.razor код похож на Items.razor:

** Листинг 10.13: ItemDetail.razor (https://epa.ms/ItemDetail10-13)**

```
@page "/entry/{SelectedItemId}"
@namespace PassXYZ.Vault.Pages

```
<!-- Кнопка "Назад" и заголовок -->
<Navbar ParentLink="@selectedItem?.GetParentLink()" ①
 Title="@selectedItem?.Name" DialogId="@_dialogEditId"
 OnAddClick="@(() => {_isNewField=true;
 currentField.Data=listGroupField=_newField;_
 newField.Key="";_newField.Value="";})" />
<!-- Список с контекстным меню -->
<Элементы ListView="поля"> ②
 <Строка Context="поле"> ③
 @if (field.ShowContextAction == ноль) {
 <span class="oi oi-pencil" aria-hidden="true"></span>
 <div class="d-flex зазор-2 w-100
 выровнять-содержание-между">
 <дел>
 <h6 class="mb-0">@field.Key</h6>
 <p class="mb-0">@field.Value</p>
 </div>
 </div>
 <Выпадающий список по клику="@(() =>
 {currentField.Data=listGroupField=поле;})">
 <MenuItemId="@_dialogEditId" OnClick="@(() =>
 _isNewField=false)">Изменить</MenuItem>
 <MenuItem Id="@_dialogDeleteId">Удалить</MenuItem>
 @if (field.IsProtected) {
 <MenuItem OnClick="OnToggleShowPassword">
 @(field.IsHide ? "Показать":"Скрыть")</MenuItem>
 }
 </ выпадающий>
 }
 </строка>
 <Footer>@((MarkupString)примечания)</Footer> ④
</ListView>
<!-- Модальное окно редактирования -->
<EditFormDialogId="@_dialogEditId" ⑤
 МодельДата="@currentField"
IsKeyEditingEnable=@_isNewField
 OnSaveAsync="UpdateFieldAsync"
 KeyPlaceHolder="Имя поля"
 ValuePlaceHolder="Содержимое поля">
 @if (_isNewField) {
 <div class="форма-проверка">
 <input class="form-check-input" type="checkbox"
 @bind="listGroupField.IsProtected"
 id="flexCheckDefault">
 <label class="form-check-label"
 for="flexCheckDefault">
 Пароль
 </метка>
 </div>
 }
</EditFormDialog>
<!-- Удаление модального окна -->
<CascadingValue Value="@_dialogDeleteId" Name="Id">
 <ConfirmDialog Title=@listGroupField.Key ⑥
 OnConfirmClick="DeleteFieldAsync" />
</CascadingValue>
```
Существует панель навигации с использованием панели навигации ①. Мы используем ListView ② для отображения полей записи,
которые включают шаблон строки ③ и шаблон нижнего колонтитула ④. В шаблоне Row содержимое
поле отображается, и каждая строка имеет контекстное меню. Контекстное меню включает в себя меню из трех
действия (Редактировать, Удалить и Показать). Действие Edit связано с диалоговым окном EditFormDialog.
диалоговое окно ⑤, а действие «Удалить» связано с диалоговым окном ConfirmDialog ⑥.
Теперь у нас есть работающее приложение для управления паролями, созданное с использованием пользовательского интерфейса Blazor. На этом мы заканчиваем это
главу и часть 2 этой книги.

# Краткое содержание

В этой главе мы продолжим нашу работу по оптимизации реализации нашего пользовательского интерфейса, создав больше Razor.
компоненты. Мы представили дополнительные темы, такие как шаблонные компоненты и использование универсальных типов.
в компоненте Razor. Мы также представили встроенные компоненты Blazor и использовали эти компоненты.
для поддержки проверки данных в нашем приложении. Мы разработали расширенную версию редактора значений ключей, используя
РедактироватьФорму. Поняв дополнительные темы о компонентах Razor, мы теперь можем
создавать более мощные компоненты Razor.

Мы завершили вторую часть этой книги. Мы перейдем к части 3 этой книги, чтобы познакомиться с модульными тестами.
и развертывание приложений .NET MAUI. Мы научимся реализовывать модульные тесты для .NET.
MAUI в следующей главе, и как развернуть наше приложение в разных магазинах приложений в главе 12,
Подготовка к развертыванию в магазинах приложений.
Пожалуйста, не переключайтесь!

# Дальнейшее чтение

  * Выпадающий список — это компонент Bootstrap.

  * https://getbootstrap.com/docs/5.1/components/dropdowns/

  * Modal — это модальный компонент Bootstrap.

  * https://getbootstrap.com/docs/5.1/components/modal/

  * Формы ASP.NET Core Blazor и компоненты ввода

  * https://learn.microsoft.com/en-us/aspnet/core/blazor/forms-andinput-components?view=aspnetcore-6.0











































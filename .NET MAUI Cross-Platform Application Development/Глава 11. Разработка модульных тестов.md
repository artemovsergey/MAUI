# Разработка модульных тестов

Тестирование является важным способом обеспечения качества программного обеспечения в современной разработке программного обеспечения. Есть
различные типы тестирования, связанные с жизненным циклом разработки программного обеспечения, такие как модульное тестирование, интеграция
тестирование и системное тестирование. Модульное тестирование используется для тестирования программных модулей или компонентов в изолированной среде.
среда. Обычно этим занимаются разработчики. Благодаря хорошо спланированной стратегии модульного тестирования программирование
проблемы могут быть обнаружены на самой ранней стадии жизненного цикла разработки программного обеспечения, поэтому модульное тестирование является
наиболее эффективный и экономичный подход к обеспечению качества вашего программного обеспечения. В приложении .NET MAUI
разработки мы можем повторно использовать существующие фреймворки или библиотеки модульных тестов в экосистеме .NET. Используя
среду тестирования или библиотеку, мы можем ускорить разработку модульного теста. Хорошая тестовая среда
обычно предназначен для легкой интеграции с непрерывной интеграцией (CI) и непрерывным развертыванием
(CD) среда. В этой главе мы познакомим вас с настройкой модульного тестирования и запуском модульных тестов.
как часть жизненного цикла разработки приложения .NET MAUI.
В этой главе мы рассмотрим следующие темы:


• Модульное тестирование в .NET

• Тестирование компонентов Razor с помощью bUnit

# Технические требования

Для тестирования и отладки исходного кода в этой главе вам необходимо установить Visual Studio 2022 на
ваш ПК или Mac. Пожалуйста, обратитесь к разделу Настройка среды разработки в Главе 1, Получение
Начал с .NET MAUI, подробнее.

Исходный код для этой главы доступен в следующем репозитории GitHub:

https://github.com/PacktPublishing/.NET-MAUI-Cross-PlatformApplication-Development/tree/main/Chapter11

Исходный код можно загрузить с помощью следующей команды Git:

```
git clone -b Chapter11 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development PassXYZ.Vault2
```

# Модульное тестирование в .NET

Для разработки сценариев модульного тестирования мы обычно используем среду модульного тестирования для повышения эффективности. Есть несколько
Платформы модульного тестирования, доступные в среде .NET, следующие:

* Microsoft Test Framework (MSTest) поставляется вместе с Visual Studio. Начальный
версия MSTest (V1) не была продуктом с открытым исходным кодом. Первый релиз был отправлен с
Visual Studio 2005. Пожалуйста, обратитесь к книге Ларса Microsoft Visual Studio 2005 Unleashed.
Пауэрса и Майка Снелла, чтобы найти дополнительную информацию о MSTest (V1). Позже Microsoft сделала
новый выпуск MSTest (V2) с открытым исходным кодом и размещенный на GitHub. Первый выпуск MSTest (V2)
был доступен примерно в 2017 году.

* NUnit — это среда тестирования с открытым исходным кодом, перенесенная из JUnit. Это был первый модульный тест
фреймворк для .NET. Самые ранние выпуски были размещены на SourceForge в 2004 году. Пожалуйста, обратитесь к
примечание к выпуску версии 2.0 в разделе «Дополнительная литература». Самые последние выпуски были
переехал на GitHub.

* xUnit — более современная и расширяемая структура, разработанная Джимом Ньюкирком и Брэдом Уилсоном.
Они были создателями NUnit и внесли множество улучшений в эту новую тестовую среду.
по сравнению с NUnit. Пожалуйста, обратитесь к блогу Джима. Почему мы создали xUnit 1.0? узнать больше
информация об улучшениях. Первая стабильная версия xUnit была доступна примерно в 2015 году.
Все они достаточно популярны и могут быть выбраны исходя из требований проекта. В этой главе,
мы будем использовать xUnit для разработки модульных тестов, так как это более новая платформа со многими улучшениями.
по сравнению с NUnit.

Независимо от того, какую среду модульного тестирования вы выберете, процесс разработки модульного тестирования очень похож.
Содержимое этой главы может помочь вам, если вы используете в своем проекте другой фреймворк. Единица
тестовые случаи могут выполняться только для кросс-платформенной целевой платформы, а не для конкретной платформы
рамки. В этой книге мы используем .NET 6.0, поэтому целевой средой модульного тестирования является net6.0.
net6.0-android или net6.0-ios.
Чтобы разработать модульный тест для .NET MAUI, мы представим разработку тестового примера для приложений на основе XAML и Blazor. В обоих случаях мы будем использовать в дизайне паттерн MVVM. Единица
тестовые случаи на уровне модели одинаковы для обоих, но тестирование в представлении и модели представления
достаточно разный. Для приложения на основе XAML довольно сложно разработать модульные тестовые примеры для представления.
и модель представления. Чтобы протестировать модель представления, мы должны разрешить зависимости XAML.
компоненты. Например, в XAML-версии нашего приложения нам нужно вызывать методы навигации Shell.
в модели представления, как показано в следующем коде:

```
ожидание Shell.Current.GoToAsync(
 $"{nameof(ItemsPage)}?{nameof(ItemsViewModel.ItemId)}={item.Id}");
```
Для разрешения зависимостей в Xamarin.Forms есть проект с открытым исходным кодом Xamarin.Forms.
Макеты, которые могут помочь имитировать компоненты Xamarin.Forms. Нам также нужно что-то похожее на
разработать модульные тестовые примеры для модели представления в приложениях .NET MAUI XAML, но я не могу найти эквивалент
в данный момент. Существует также собственная среда тестирования пользовательского интерфейса, Xamarin.UITest, которая
для Android и iOS, но этот фреймворк пока нельзя использовать в .NET MAUI. Тем не менее, Xamarin.
UITest не является кросс-платформенным решением, поэтому мы не будем обсуждать его в этой книге.
Для приложения Blazor Hybrid у нас есть хорошая тестовая библиотека bUnit, которую можно использовать для тестирования компонентов Razor.
Мы можем разработать модульные тестовые случаи для представления, модели представления и слоев модели для приложений Blazor.
В этой главе мы сначала разработаем модульные тесты для уровня модели, что является общим для XAML
и Блазор. После этого мы представим разработку модульных тестов для приложений Blazor с использованием bUnit. bUnit
библиотека тестирования, которую можно использовать со всеми тремя платформами тестирования (xUnit, NUnit и MSTest).

# Настройка проекта модульного тестирования

Чтобы запачкать руки, давайте создадим проект модульного тестирования. Мы можем создать проект xUnit, используя либо
Visual Studio или командная строка .NET:

1. Чтобы начать работу с Visual Studio, мы можем добавить новый проект в наше текущее решение, как показано на
Рисунок 11.1:

![изображение](https://user-images.githubusercontent.com/26972859/232018770-8c5900cb-f1de-4623-aa29-2c01cc7b34cb.png)

Рисунок 11.1 – Создание проекта xUnit

2. Мы можем ввести xunit в поле поиска и выбрать тестовый проект xUnit для C#.

3. На следующем экране мы можем назвать проект PassXYZ.Vault.Tests и нажать «Далее».

4. После этого выберите фреймворк .NET 6.0 и нажмите «Создать».

Чтобы создать проект с помощью командной строки, мы можем сначала создать папку и использовать команду .NET для создания проекта следующим образом:

```
mkdir PassXYZ.Vault.Tests
cd PassXYZ.Vault.Tests
дотнет новый xunit
дотнет-тест
```

После того, как мы создали проект, мы можем использовать команду dotnet test для запуска тестовых случаев.
Тестовый случай по умолчанию в шаблоне будет выполнен. Мы добавим тестовые примеры в этот тестовый проект. 
тестовые цели — это компоненты проектов PassXYZ.Vault и PassXYZ.BlazorUI,
поэтому нам нужно добавить эти два проекта в качестве эталонных проектов. Целевая структура PassXYZ.
BlazorUI — это net6.0, поэтому мы можем добавить его напрямую. Однако целевые платформы PassXYZ.
Vault зависят от платформы, поэтому нам нужно внести некоторые изменения, прежде чем мы сможем добавить их в качестве эталона.
в PassXYZ.Vault.Tests.
Файл проекта нашего приложения для управления паролями называется PassXYZ.Vault.csproj. Нам нужно добавить
net6.0 в качестве одной из целевых платформ для этого файла проекта:

```
<TargetFrameworks>net6.0;net6.0-android;net6.0-ios;net6.0-maccatalyst</TargetFrameworks>
```
Когда мы собираем проект PassXYZ.Vault на поддерживаемых платформах, мы ожидаем исполняемый файл, поскольку
это приложение. Однако, когда мы собираем PassXYZ.Vault для целевой платформы net6.0, мы хотим
чтобы проверить это. PassXYZ.Vault должен быть сгенерирован как библиотека, чтобы тестовая среда могла ее использовать.
для запуска тестовых случаев. В этом случае мы ожидаем создать файл с расширением .dll вместо .exe, поэтому мы
необходимо внести следующие изменения:

```
<OutputType Condition="'$(TargetFramework)'!='net6.0'">Exe</OutputType>
```
В предыдущей настройке сборки добавлено условие для проверки целевой платформы для типа вывода. Если целевая платформа отличается от net6.0, мы создадим вывод в виде исполняемого файла.

Благодаря этим изменениям мы можем добавлять эталонные проекты в PassXYZ.Vault.Tests, щелкнув правой кнопкой мыши
узел решения и выберите «Добавить» -> «Ссылка на проект»… или отредактируйте файл проекта для PassXYZ.
Vault.Tests, чтобы добавить следующие строки:

```
<группа элементов>
 <ProjectReference Include="..\PassXYZ.BlazorUI\PassXYZ.
 BlazorUI.csproj" />
 <ProjectReference Include="..\PassXYZ.Vault\PassXYZ.Vault.
 csproj" />
</ItemGroup>
```
Чтобы протестировать проект MAUI, нам также нужно добавить следующую конфигурацию в PassXYZ.Vault.
Тесты проекта:

```
<UseMaui>true</UseMaui>
```
Теперь мы настроили проект xUnit. Давайте добавим наши тестовые случаи.

# Создание тестовых случаев для тестирования интерфейса IDataStore

Сначала мы начнем добавлять тестовые примеры на уровне модели, поскольку настройка тестового примера на уровне модели является
одинаково для версий XAML и Blazor нашего приложения.

На уровне модели основная реализация находится в библиотеке PassXYZLib — вы можете обратиться к
исходный код PassXYZLib, чтобы узнать больше о тестовых примерах на уровне модели:
https://github.com/shugaoye/PassXYZLib

В нашем приложении IDataStore — это интерфейс для экспорта PassXYZLib, поэтому давайте добавим тестовые примеры в наш
тестовый интерфейс, IDataStore. Чтобы протестировать интерфейс IDataStore, мы можем создать новый тестовый класс,
DataStoreTests в проекте PassXYZ.Vault.Tests. Мы можем начать добавлять новый тестовый пример
чтобы проверить случай, добавив элемент следующим образом:

```
открытый класс DataStoreTests
{
 [Факт] ❶
 публичный асинхронный void Add_Item()
 {
 // Упорядочить ❷
 IDataStore<Item> datastore = new MockDataStore();
 ItemSubType itemSubType = ItemSubType.Entry;
 // Действие ❸
 var newItem = хранилище данных.CreateNewItem(itemSubType);
 новыйItem.Name = $"{itemSubType.ToString()}01";
 ожидание хранилища данных.AddItemAsync(newItem);
 var item = datastore.GetItem(newItem.Id);
 // Подтверждаем ❹
 Assert.Equal (новыйItem.Id, item.Id);
 }
}
```
xUnit использует атрибуты для информирования платформы о настройке тестового примера. В этом тестовом примере мы используем
Атрибут [Факт], ❶, чтобы пометить этот метод как тестовый пример. Чтобы определить тестовый пример, мы можем использовать общий
шаблон - Упорядочить, действовать и утверждать:
• Организовать ❷ — Мы подготовим все необходимые настройки для теста. Чтобы добавить элемент, нам нужно инициализировать
сначала интерфейс IDataStore, а затем мы определим переменную для хранения типа элемента.
• Действие ❸ — мы выполняем методы, которые хотим протестировать, а именно CreateNewItem().
и AddItemAsync().
• Assert ❹ — мы проверяем ожидаемый результат. В нашем случае мы пытаемся получить новый элемент
используя item.Id. После этого мы проверяем, что полученный идентификатор элемента совпадает с тем, что
мы ожидали.
Как вы могли заметить, мы тестировали тип Entry в предыдущем тестовом примере. Тип записи только
один из типов предметов — у нас их много. Чтобы протестировать их все, нам нужно создать много тестовых случаев. xUnit
поддерживает другой тип тестового примера, [Theory], который помогает нам тестировать разные сценарии с помощью одного тестового примера.
Мы можем использовать тестовый пример «удалить элемент», чтобы продемонстрировать, как тестировать разные сценарии в одном тесте.
кейс с атрибутом [Теория]. В этом тестовом примере мы можем удалить элемент в разных типах элементов в
один тестовый случай:

```Csharp
открытый класс DataStoreTests
{
 ...
 [Теория] ①
 [InlineData(ItemSubType.Entry)] ②
 [InlineData(ItemSubType.Group)]
 [InlineData(ItemSubType.Notes)]
 [InlineData(ItemSubType.PxEntry)]
 public async void Delete_Item (ItemSubType itemSubType)
 
 // Договариваться
 IDataStore<Item> datastore = new MockDataStore();
 var newItem = хранилище данных.CreateNewItem(itemSubType); ③
 новыйItem.Name = $"{itemSubType.ToString()}01";
 ожидание хранилища данных.AddItemAsync(newItem);
 // Действовать
 логический результат = ожидание
 хранилище данных.DeleteItemAsync(newItem.Id); ④
 Debug.WriteLine($"Delete_Item: {newItem.Name}");
 // Утверждать
 Утвердить.Истина(результат); ⑤
 }
 ...
}
```
Когда мы создаем тестовый пример, используя атрибут [Theory], ①, мы можем передавать различные типы элементов, используя
параметр itemSubType. Значение аргумента itemSubType определяется с помощью
Атрибут [InlineData], ②.
Чтобы упорядочить тестовые данные, мы создаем новый элемент, используя аргумент itemSubType, ③. Затем мы выполняем
метод DeleteItemAsync(), ④, который мы хотим протестировать.
Наконец, мы проверяем возвращаемое значение ⑤. Если элемент успешно удален, результат будет истинным. В противном случае,
результат ложный.
Мы узнали, как создать тестовый пример с использованием атрибута [Факт] и как охватить различные
сценарии с использованием атрибута [Теория]. Давайте обсудим больше тем в разработке тестовых случаев в
следующий раздел.

# Обмен контекстом между тестами

В наших предыдущих тестовых случаях мы создавали новый экземпляр IDataStore для каждого тестового примера. Можем ли мы поделиться одним
Экземпляр IDataStore вместо того, чтобы каждый раз создавать один и тот же экземпляр? Мы можем уменьшить дублирование
поделившись тестовой настройкой с группой тестовых случаев в xUnit.

Существует три способа совместного использования кода установки и очистки между тестами в xUnit:

* Constructor и Dispose — мы можем использовать конструктор класса, чтобы поделиться кодом установки и очистки.
без обмена экземплярами

* Class Fixture — мы можем использовать фикстуру для совместного использования экземпляров объектов в одном классе.

* Фикстуры коллекций — мы можем использовать фикстуры коллекций для совместного использования экземпляров объектов в нескольких
тестовые классы

Совместное использование с помощью конструктора

Чтобы удалить дублированный код настройки из предыдущих тестов, мы можем перенести создание
IDataStore в конструктор тестового класса DataStoreTests следующим образом:

```Csharp
открытый класс DataStoreTests
{
 хранилище данных IDataStore<Item>;
 общедоступные тесты хранилища данных ()
 {
 хранилище данных = новый MockDataStore();
 Debug.WriteLine("Тесты хранилища данных: созданы");
 }
 ...
}

```

В этом коде мы добавили закрытую переменную-член, хранилище данных, и создали экземпляр IDataStore.
в конструкторе DataStoreTests. Мы также добавили вывод отладки, чтобы мы могли отслеживать
создание интерфейса IDataStore. Давайте отладим выполнение класса DataStoreTests
поэтому мы можем увидеть вывод отладки здесь:

```
Тесты хранилища данных: создано
Удалить_Элемент: Entry01
Тесты хранилища данных: создано
Удалить_Элемент: Группа01
Тесты хранилища данных: создано
Удалить_Элемент: PxEntry01
Тесты хранилища данных: создано
Удалить_Элемент: Примечания01
Тесты хранилища данных: создано
Create_Item: PxEntry
Тесты хранилища данных: создано
Create_Item: Группа
Тесты хранилища данных: создано
Create_Item: запись
Тесты хранилища данных: создано
Create_Item: Примечания
Тесты хранилища данных: создано
Add_Item: Готово
```
Из выходных данных отладки видно, что класс DataStoreTests создается для каждого тестового примера. Там
нет никакой разницы, создаем ли мы экземпляр IDataStore внутри тестового метода или в
конструктор. Все тестовые случаи по-прежнему изолированы друг от друга. Когда мы используем атрибут [Theory]
чтобы протестировать разные сценарии одним методом, каждый из них во время выполнения выглядит как отдельный тест-кейс. К
понять это лучше, мы можем использовать команду dotnet, чтобы перечислить все определенные тесты:

```
дотнет тест -t
 Определение проектов по восстановлению...
 Все проекты актуальны для восстановления.
Инструмент командной строки Microsoft (R) Test Execution, версия 17.3.0
 (x64)
Авторское право (c) Корпорация Microsoft. Все права защищены.
Доступны следующие тесты:
 PassXYZ.Vault.Tests.DataStoreTests.Add_Item
 PassXYZ.Vault.Tests.DataStoreTests.Delete_Item(itemSubType:
 Вход)
 PassXYZ.Vault.Tests.DataStoreTests.Delete_Item(itemSubType:
 Группа)
 PassXYZ.Vault.Tests.DataStoreTests.Delete_Item(itemSubType:
 Примечания)
 PassXYZ.Vault.Tests.DataStoreTests.Delete_Item(itemSubType:
 PxEntry)
 PassXYZ.Vault.Tests.DataStoreTests.Create_Item(itemSubType:
 Вход)
 PassXYZ.Vault.Tests.DataStoreTests.Create_Item(itemSubType:
 Группа)
 PassXYZ.Vault.Tests.DataStoreTests.Create_Item(itemSubType:
 Примечания)
 PassXYZ.Vault.Tests.DataStoreTests.Create_Item(itemSubType:
 PxEntry)
```
Мы видим, что каждый параметр, определенный атрибутом [InlineData], отображается как отдельный тест.
случай. Все они являются изолированными тестовыми примерами во время выполнения.
После того, как мы перечислим все тесты, мы можем выборочно выполнить их с помощью команды dotnet.
Если мы хотим запустить все тесты в классе DataStoreTests, мы можем использовать эту команду:

```тест dotnet --filter DataStoreTests```

Если мы хотим запускать только тесты Add_Item, мы можем использовать эту команду:

```тест dotnet --filter DataStoreTests.Add_Item```

Как видно из вывода отладки, несмотря на то, что мы создали экземпляр IDataStore в
конструктор, экземпляр заново создается для каждого теста. Экземпляры, созданные в конструкторе тестового класса
не будут использоваться совместно тестами. Несмотря на то, что эффект тот же, код выглядит более лаконичным.
Однако в некоторых случаях мы хотим совместно использовать экземпляры в тестах. Мы можем сделать это, используя фикстуры класса.
Давайте рассмотрим эти случаи в следующем разделе.

Совместное использование с помощью фикстур класса

Когда мы используем инструмент во всех тестовых примерах, мы можем захотеть поделиться настройками во всех тестовых случаях вместо создания
один и тот же каждый раз. Давайте используем функцию ведения журнала в качестве примера, чтобы объяснить это.
Чтобы получить отчет о тестировании, мы хотим создать журнал тестирования для отслеживания выполнения модульных тестов. Eсть
библиотеку под названием Serilog, которую можно использовать для этой цели. Мы можем регистрировать сообщения на разные каналы
с помощью Серилога. Чтобы использовать Serilog, нам нужно сначала настроить его и очистить после того, как все тесты будут завершены.
был казнен. В этом случае мы хотим вместо этого совместно использовать экземпляр Serilog между всеми тестами.
создания одного для каждого теста. С этой настройкой мы можем создать один файл журнала для всех тестов вместо
несколько файлов журнала для каждого теста.

Чтобы использовать Serilog, нам нужно сначала добавить пакет Serilog в проект. Для этого мы можем запустить
следующие команды dotnet в папке проекта PassXYZ.Vault.Tests:

```
dotnet добавить пакет Serilog
dotnet добавить пакет Serilog.Sinks.File
```
После добавления библиотек Serilog в проект мы можем создать фикстуру класса SerilogFixture,
в демонстрационных целях:

```Csharp
открытый класс SerilogFixture: IDisposable { ❶
 общедоступный регистратор ILogger { получить; частный набор; }
 общедоступный SerilogFixture () {
 Регистратор = новая конфигурация регистратора () ❷
 .МинимальныйУровень.Отладка()
 .WriteTo.File(@"журналы\xunit_log.txt")
 .СоздатьЛоггер();
 Logger.Debug("SerilogFixture: инициализировано");
 }
 общественное недействительное удаление () {
 Logger.Debug("SerilogFixture: закрыто");
 Журнал.ЗакрытьИСбросить(); ❸
 }
}
общедоступный класс DataStoreTests: IClassFixture<SerilogFixture>
{ ❹
 хранилище данных IDataStore<Item>;
 SerilogFixture
 public DataStoreTests (приспособление SerilogFixture) { ❺
 serilogFixture = приспособление; ❻
 хранилище данных = новый MockDataStore();
 serilogFixture.Logger.Debug("Тесты хранилища данных: созданы");
 }
 [Факт]
 public async void Add_Item() ...
 ...
}
```

Если мы хотим использовать фикстуры класса, мы можем создать их, выполнив следующие шаги:
1. Мы можем создать новый класс в качестве класса фикстуры и добавить код установки в конструктор. Здесь,
мы создали класс фиксации, SerilogFixture, ❶ и инициализировали интерфейс ILogger,
❷, в конструкторе.
2. Поскольку нам нужно очистить настройку после выполнения тестового примера, нам нужно реализовать
Интерфейс IDisposable для класса приспособления и поместите код очистки в Dispose().
метод. Мы реализовали IDisposable в SerilogFixture и назвали Serilog
функция Log.CloseAndFlush(), ❸, в методе Dispose().
3. Чтобы использовать фикстуру, тестовый пример должен реализовать интерфейс ```IClassFixture<T>```. Мы
реализовал это в тестовом классе DataStoreTests, ❹.
4. Чтобы получить доступ к экземпляру прибора, мы можем добавить его в качестве аргумента конструктора, и он будет предоставлен
автоматически. В конструкторе DataStoreTests, ❺, мы присваиваем аргумент
закрытая переменная-член, serilogFixture, ❻. В тестовых случаях мы можем получить доступ к Serilog
используя эту переменную.
Чтобы проверить эту настройку, мы заменили весь наш вывод отладки на отладку Serilog. После выполнения
тесты в DataStoreTests, мы можем увидеть сообщения журнала здесь, в файле журнала xunit_log.txt:

```
2022-08-28 10:25:39.273 +08:00 [DBG] SerilogFixture:
инициализирован
2022-08-28 10:25:39.332 +08:00 [DBG] DataStoreTests: создано
2022-08-28 10:25:39.350 +08:00 [DBG] Delete_Item: Entry01
2022-08-28 10:25:39.355 +08:00 [DBG] DataStoreTests: создано
2022-08-28 10:25:39.355 +08:00 [DBG] Delete_Item: Group01
2022-08-28 10:25:39.356 +08:00 [DBG] DataStoreTests: создано
2022-08-28 10:25:39.357 +08:00 [DBG] Delete_Item: PxEntry01
2022-08-28 10:25:39.358 +08:00 [DBG] DataStoreTests: создано
2022-08-28 10:25:39.358 +08:00 [DBG] Delete_Item: Notes01
2022-08-28 10:25:39.359 +08:00 [DBG] DataStoreTests: создано
2022-08-28 10:25:39.359 +08:00 [DBG] Create_Item: PxEntry
2022-08-28 10:25:39.360 +08:00 [DBG] DataStoreTests: создано
2022-08-28 10:25:39.360 +08:00 [DBG] Create_Item: Группа
2022-08-28 10:25:39.361 +08:00 [DBG] DataStoreTests: создано
2022-08-28 10:25:39.361 +08:00 [DBG] Create_Item: Запись
2022-08-28 10:25:39.362 +08:00 [DBG] DataStoreTests: создано
2022-08-28 10:25:39.362 +08:00 [DBG] Create_Item: Примечания
2022-08-28 10:25:39.362 +08:00 [DBG] DataStoreTests: создано
2022-08-28 10:25:39.364 +08:00 [DBG] Add_Item: Готово
2022-08-28 10:25:39.367 +08:00 [DBG] SerilogFixture: закрыто  
```
Как мы и ожидали, класс SerilogFixture инициализируется всего один раз, и экземпляр можно использовать
во всех тестах в DataStoreTests по сравнению с инициализируемым интерфейсом IDataStore
для каждого теста.

# Совместное использование с использованием фикстур коллекции

Используя фикстуры класса, как показано в предыдущем разделе, мы можем совместно использовать контекст настройки теста в одном тесте.
сорт. Есть также случаи, когда мы можем захотеть разделить настройку теста в нескольких тестовых классах. Мы
можно сделать это с помощью фикстур коллекции.
В нашем случае с Serilog мы также можем использовать его во многих тестовых классах, чтобы мы могли видеть весь журнал.
сообщений в один лог-файл. Чтобы использовать одну настройку Serilog для всех тестовых классов, мы можем реализовать сбор
светильники в нашем проекте. Чтобы использовать фикстуры коллекций, мы можем создать два новых класса: SerilogFixture.
и SerilogCollection в проекте PassXYZ.Vault.Tests, как показано в листинге 11.1:

** Листинг 11.1: SerilogFixture.cs (https://epa.ms/SerilogFixture11-1)**

```общественное
пространство имен PassXYZ.Vault.Tests;
открытый класс SerilogFixture: IDisposable {
 общедоступный регистратор ILogger { получить; частный набор; }
 общедоступный SerilogFixture () {
 Регистратор = новая конфигурация регистратора ()
 .МинимальныйУровень.Отладка()
 .WriteTo.File(@"журналы\xunit_log.txt")
 .СоздатьЛоггер();
 Logger.Debug("SerilogFixture: инициализировано");
 }
 общественное недействительное удаление () {
 Logger.Debug("SerilogFixture: закрыто");
 Журнал.ЗакрытьИСбросить();
 }
}
[CollectionDefinition("Коллекция Serilog")] ❶
публичный класс
SerilogCollection:ICollectionFixture<SerilogFixture>
{
} ❷
```

Мы можем выполнить следующие шаги, чтобы реализовать фикстуры коллекции:
1. Мы создаем новый файл класса, SerilogFixture.cs, и помещаем как SerilogFixture, так и
SerilogCollection в этот файл.
2. Украшаем класс определения коллекции SerilogCollection с помощью
Атрибут [CollectionDefinition], ❶. Затем мы даем ему уникальное имя, которое может быть
используется для идентификации тестовой коллекции.
3. Класс определения коллекции, SerilogCollection, должен реализовать
интерфейс ```ICollectionFixture<T>```, ❷.
Чтобы использовать фикстуру коллекции, мы можем внести следующие изменения в наши тестовые классы:
1. Мы можем добавить атрибут [Collection] ко всем тестовым классам, которые будут частью
коллекция. Мы назначаем коллекцию Serilog в качестве имени определению тестовой коллекции в
атрибут. В нашем случае, как видно из листинга 11.2, мы добавляем [Collection("Serilog
collection")] атрибут ① в класс DataStoreTests.
2. Чтобы получить доступ к экземпляру фикстуры, мы можем сделать то же самое, что и в предыдущем разделе с фикстурами класса.
и добавьте его в качестве аргумента конструктора. Тогда он будет предоставлен автоматически. В конструкторе
DataStoreTests, мы назначаем аргумент приспособления для переменной serilogFixture, ②:

**Листинг 11.2: DataStoreTests.cs (https://epa.ms/DataStoreTests11-2)**

```Csharp
пространство имен PassXYZ.Vault.Tests;
[Коллекция ("Коллекция Serilog")] ①
открытый класс DataStoreTests {
 хранилище данных IDataStore<Item>;
 SerilogFixture
 public DataStoreTests (приспособление SerilogFixture) {
 хранилище данных = новый MockDataStore();
 serilogFixture = приспособление; ②
 serilogFixture.Logger.Debug("Тесты хранилища данных
 инициализирован");
 }
 [Факт]
 общедоступный асинхронный недействительный Add_Item () {
 // Договариваться
 ItemSubType itemSubType = ItemSubType.Entry;
// Действовать
 var newItem = хранилище данных.CreateNewItem(itemSubType);
 новыйItem.Name = $"{itemSubType.ToString()}01";
 ожидание хранилища данных.AddItemAsync(newItem);
 var item = datastore.GetItem(newItem.Id);
 // Утверждать
 Assert.Equal (новыйItem.Id, item.Id);
 serilogFixture.Logger.Debug("Добавить_элемент выполнено");
 }
 [Теория]
 [InlineData(ItemSubType.Entry)]
 [InlineData(ItemSubType.Group)]
 [InlineData(ItemSubType.Notes)]
 [InlineData(ItemSubType.PxEntry)]
 public async void Delete_Item (ItemSubType itemSubType)...
 [Теория]
 [InlineData(ItemSubType.Entry)]
 [InlineData(ItemSubType.Group)]
 [InlineData(ItemSubType.Notes)]
 [InlineData(ItemSubType.PxEntry)]
 public void Create_Item (ItemSubType itemSubType) ...
}
```
С помощью этих примеров мы представили, как создавать модульные тесты на уровне модели. Знание
то, что мы получили на данный момент, можно использовать в модульном тестировании и для других приложений .NET.
На данный момент мы завершили введение модульного теста уровня модели. В следующей части этой главы
мы рассмотрим модульный тест компонентов Razor с использованием библиотеки bUnit.

# Тестирование компонентов Razor с использованием bUnit

В разработке .NET MAUI у нас действительно нет хорошей среды модульного тестирования для пользовательского интерфейса на основе XAML.
компонентов, но у нас есть один для Blazor. bUnit — отличная тестовая библиотека, которую можно использовать для
модульное тестирование компонентов Razor. С библиотекой bUnit мы можем разрабатывать модульные тесты.
для компонентов Razor с помощью xUnit, NUnit или MSTest. Мы будем использовать xUnit с bUnit для остальных
главы. Структура модульных тестов с использованием bUnit аналогична тестовым примерам xUnit, которые мы
введены в предыдущем разделе.

Целевыми объектами тестирования в оставшейся части этой главы являются следующие компоненты Razor, которые мы создали в
вторая часть этой книги:

  * Компоненты Razor в проекте PassXYZ.BlazorUI

  * Компоненты Razor в проекте PassXYZ.Vault

  Чтобы протестировать компоненты Razor с помощью bUnit, нам нужно изменить конфигурацию проекта
PassXYZ.Vault.Tests.

# Изменение конфигурации проекта для bUnit

Чтобы настроить тестовую среду, нам нужно добавить пакеты bUnit и Moq и обновить SDK.
тип. Мы можем внести следующие изменения в тестовый проект xUnit PassXYZ.Vault.Tests:

1. Добавьте bUnit в проект.

  Чтобы добавить библиотеку bUnit в проект, мы можем сначала перейти в папку проекта и выполнить
следующую команду из консоли:
  
```
cd PassXYZ.Vault.Tests
dotnet добавить блок пакетов
```

  2. Нам также нужно добавить пакет Moq, который является фиктивной библиотекой, которую мы будем использовать в тестовой настройке:
dotnet добавить пакет Moq

  3. Измените конфигурацию проекта. Чтобы протестировать компоненты Razor, нам также необходимо изменить SDK проекта на Microsoft.NET.Sdk.Razor.

  В файле проекта PassXYZ.Vault.Tests.csproj нам нужно заменить следующую строку: ```<Project Sdk="Microsoft.NET.Sdk">```

  Мы сделаем это следующим образом: ```<Project Sdk="Microsoft.NET.Sdk.Razor">```

  Как только у нас будет готова конфигурация проекта, мы можем создать простой модульный тест, используя bUnit для
протестируйте наши компоненты Razor.

# Создание тестового примера bUnit

В нашем приложении PassXYZ.Vault есть два типа компонентов Razor, которые можно протестировать. Общий
Компоненты Razor находятся в проекте PassXYZ.BlazorUI. Это общие компоненты Razor.
которые можно использовать в разных проектах. Другой набор компонентов Razor находится на страницах.
папка проекта PassXYZ.Vault. Они относятся к приложению PassXYZ.Vault и
использовать общие компоненты из проекта PassXYZ.BlazorUI.
Чтобы протестировать компоненты Razor в проекте PassXYZ.BlazorUI, мы можем протестировать каждый компонент.
в отдельности. Эти тестовые случаи являются модульными тестовыми примерами. Компоненты Razor в папке Pages
Проект PassXYZ.Vault — это страницы пользовательского интерфейса. Эти страницы используют компоненты пользовательского интерфейса из других пакетов, поэтому
у них больше зависимостей. Эти тестовые случаи можно считать интеграционными тестовыми примерами.
Мы можем создать тестовый пример для компонента ModalDialog Razor в PassXYZ.BlazorUI.
проект первый. Чтобы протестировать ModalDialog, мы можем создать тестовый класс xUnit, ModalDialogTests, как
показано в листинге 11.3:

** Листинг 11.3: ModalDialogTests.cs (https://epa.ms/ModalDialogTests11-3)**

```Csharp
пространство имен PassXYZ.Vault.Tests {
 [Коллекция ("Коллекция Serilog")]
 открытый класс ModalDialogTests : TestContext { ❶
 SerilogFixture
 общественные ModalDialogTests (SerilogFixture serilogFixture) {
 this.serilogFixture = serilogFixture;
 }
 [Факт]
 общественный недействительным ModalDialogInitTest () {
 string title = "Тест ModalDialog"; ❷
 var cut = RenderComponent<ModalDialog>( ❸
 параметры => параметры.Добавить(p => p.Title, title) ❹
 .Add(p => p.CloseButtonText, "Закрыть")
 .Add(p => p.SaveButtonText, "Сохранить"));
 cut.Find("h5").TextContent.MarkupMatches(title); ❺
 serilogFixture.Logger.Debug("ModalDialogInitTest:
 сделанный");
 }
 ...
 }
}
```

Как видно из класса модульного теста ModalDialogTests, он очень похож на класс модульного теста, который
мы создали для слоя модели. Мы повторно используем фикстуру коллекции, которую мы создали ранее и инициализировали.
это в конструкторе. В тестовом случае ModalDialogInitTest мы по-прежнему используем Arrange, Act и
Утвердите шаблон для реализации тестового примера.
Все тестовые классы bUnit наследуются от TestContext ❶. На этапе аранжировки мы инициализируем локальный заголовок
переменная, ❷, с определенной строкой. На этапе действия мы вызываем общий метод ```RenderComponent<T>```,
❸ и используйте тип ModalDialog в качестве параметра типа. Мы передаем переменную title, ❹, как
параметр компонента. Результат ```RenderComponent<T>``` сохраняется в переменной cut. в
На этапе утверждения мы проверяем, что текст заголовка после рендеринга совпадает с аргументом, который мы передаем
это с помощью метода Find() bUnit, ❺. Метод Find() bUnit можно использовать для поиска любого HTML-кода.
ярлык. В ModalDialog заголовок отображается как HTML-тег ```<h5>```.
В тестовом примере ModalDialogInitTest мы видим структуру тестов bUnit. В тестах bUnit
сначала мы визуализируем тестируемый компонент. Результат рендеринга сохраняется в переменной cut,
❸. Это экземпляр интерфейса IRenderedComponent. Мы можем проверить результат, обратившись
к свойствам или вызывая методы экземпляра IRenderedComponent.
Когда компоненты Razor визуализируются в TestContext, они имеют тот же жизненный цикл, что и любые другие компоненты.
Компонент бритвы. Мы можем передавать параметры тестируемым компонентам, и они могут производить выходные данные,
аналогично тому, что происходит в браузере.
Когда мы визуализируем компонент ModalDialog в предыдущем примере, мы можем
передать ему параметры компонента с помощью метода Add() построителя параметров
Тип ```ComponentParameterCollectionBuilder<TComponent>```.
У нас может не возникнуть проблем с рендерингом простых компонентов с использованием кода C#. Однако обычно нам нужно
передать компоненту несколько параметров, а это неудобно делать в коде C#. С bUnit мы
может разрабатывать тестовые примеры в файлах Razor, что значительно упрощает разработку модульных тестов.

# Создание тестовых случаев в файлах Razor

Чтобы создавать тесты непосредственно в файлах разметки Razor, мы можем объявить компоненты, использующие разметку Razor, как
мы используем их на странице Razor. Таким образом, нам не нужно вызывать компоненты Razor в коде C#.
и передавать параметры с помощью вызовов функций. Для страницы Razor мы можем визуализировать компоненты Razor, используя
Шаблоны бритвы.
Мы можем продемонстрировать, как создавать тесты в файлах разметки Razor, создав тестовые примеры для большего удобства.
сложный компонент EditorDialog. Мы создали компонент EditorDialog в главе 9.
Компоненты Razor и привязка данных. В листинге 11.4 давайте рассмотрим модульные тесты для него:

** Листинг 11.4: EditorDialogTests.razor (https://epa.ms/EditorDialogTests11-4)**

```Csharp
@наследует TestContext ❶
<h3>Тесты диалогового окна редактора</h3>
@код {
 bool _isOnCloseClicked = ложь;
 строка _key = строка.Пустой;
 строка _value = строка.Пустой;
 string updated_key = "ключ обновлен";
 string updated_value = "значение обновлено";
 void OnSaveClicked (строковый ключ, строковое значение) {
 _ключ = ключ; _значение = значение;
 }
 недействительным OnCloseHandler () {
 _isOnCloseClicked = Истина;
 }
 [Факт]
 public void EditorDialog_Init_WithoutArgument() ...
 [Факт]
 общественное недействительное Edit_OnClose_Clicked () {
var cut = Render(@<EditorDialog Key="@_key"
 Значение="@_значение"
 OnSave=@OnSaveClicked OnClose=@OnCloseHandler>
 </РедакторДиалог>); ❷
 cut.Find("button[class='btn btn-secondary']").Click();❸
 Assert.True (_isOnCloseClicked); ❹
 }
 [Факт]
 public void Edit_With_KeyEditingEnabled() { ❺
var cut = Render(@<EditorDialog Key="@_key"
 Значение="@_значение"
 IsKeyEditingEnable="true" OnSave=@OnSaveClicked>
 </РедакторДиалог>);
 cut.Find("ввод").Change(updated_key);
 cut.Find("textarea").Change(updated_value);
 cut.Find("button[type=submit]").Click();
 Assert.Equal(_key, updated_key);
 Утвердить.Равно(_значение, обновленное_значение);
 }
 [Факт]
 public void Edit_With_KeyEditingDisabled() ...
}
```
Мы можем создать новый компонент Razor, EditorDialogTests, в PassXYZ.Vault.Tests.
проект. Поскольку это тестовый класс bUnit, он является дочерним классом TestContext, ❶. В этом классе мы создаем
тестовые примеры в блоке кода с использованием шаблонов Razor.
  
Сначала мы можем просмотреть тестовый пример Edit_OnClose_Clicked. В этом тестовом примере мы визуализируем
Компонент EditorDialog сначала и после этого мы тестируем кнопку закрытия.
Чтобы визуализировать компонент EditorDialog, мы вызываем метод Render(), ❷, TestContext.
По сравнению с предыдущим примером здесь мы можем визуализировать разметку Razor напрямую, а не вызывать
функция С#. Разметка Razor, которую мы здесь используем, называется шаблонами Razor, и вы можете найти больше
информация об этом в этом документе Microsoft:
  
https://learn.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#razor-templates-1

Шаблоны Razor могут быть определены в следующем формате:

```@<{HTML-тег}>…</{HTML-тег}>```

Он состоит из символа @ и пары открытых и закрытых тегов HTML. Шаблоны Razor можно использовать в
блок кода файла Razor. Его нельзя использовать в файле кода программной части C# или C#.
Используя этот формат, мы можем указать фрагмент разметки Razor в качестве параметра функции C#.
Фрагмент разметки Razor представляет собой шаблон Razor с типом данных RenderFragment или
```RenderFragment<TValue>```. В листинге 11.4 мы передаем параметры в EditorDialog, используя
Шаблоны Razor, как мы видим в следующем коде:

```
var cut = Render(@<EditorDialog Key="@_key" Value="@_value" OnSave=@OnSaveClicked OnClose=@OnCloseHandler>
</РедакторДиалог>);
```
После рендеринга EditorDialog мы можем найти кнопку закрытия и смоделировать действие щелчка, ❸:

```
cut.Find("button[class='btn btn-secondary']").Click();  
```
В обработчике событий OnCloseHandler для переменной _isOnCloseClicked ❹ установлено значение true.
так что мы можем утверждать результат.
  
В тестовом примере Edit_With_KeyEditingEnabled ❺ после рендеринга компонента мы можем
имитировать взаимодействия с пользователем, чтобы установить поля ключа и значения в компоненте. После этого мы можем смоделировать
нажав на кнопку сохранения, как мы видим здесь:
  
```
 cut.Find("ввод").Change(updated_key);
 cut.Find("textarea").Change(updated_value);
 cut.Find("button[type=submit]").Click();
```

При нажатии кнопки вызывается обработчик события. В обработчике события OnSaveClicked
мы сохраняем измененный ключ и значение, чтобы мы могли подтвердить результат:

```
 Assert.Equal(_key, updated_key);
 Утвердить.Равно(_значение, обновленное_значение);
```

Как мы видим из этих двух тестовых примеров, мы можем гораздо проще разрабатывать тесты bUnit, создавая тесты
в файле Razor. Мы можем отображать компоненты с помощью шаблонов Razor, а также запускать различные пользовательские
взаимодействия для интерактивного тестирования компонентов.
Шаблоны Razor — отличный инструмент, помогающий нам комбинировать разметку Razor и код C#, чтобы мы могли использовать
лучшие черты обоих миров. Однако у нас есть ограничение при использовании шаблонов Razor. Давайте
см., как преодолеть это в следующем разделе.  
  
# Использование делегата RenderFragment

  Несмотря на то, что шаблоны Razor могут помочь упростить настройку теста, существует ограничение, особенно в
сложная настройка тестового примера. В сложном тестовом случае шаблоны Razor могут быть очень длинными. Если мы
хотите повторно использовать те же шаблоны Razor в другом тестовом примере, нам нужно скопировать их в новый тест
случай. Возможно, нам придется создать много дублированного кода, и это ограничение шаблонов Razor.
В этом случае мы можем использовать делегат RenderFragment. Как видно из названия, это тип делегата.
RenderFragment или ```RenderFragment<TValue>```. Тип данных шаблонов Razor:
RenderFragment или ```RenderFragment<TValue>```. Делегат RenderFragment — это
тип делегата для шаблонов Razor.  
  
 Вы можете найти больше информации о делегате RenderFragment в следующем
Документ Майкрософт:
  
 https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-3.1#define-reusable-renderfragmentsin-code-2
Чтобы продемонстрировать, как использовать делегат RenderFragment, давайте настроим более сложный тест для

Компонент EditorDialog. EditorDialog можно использовать для редактирования элемента или поля. Мы можем
используйте случай редактирования элемента, чтобы показать, как использовать делегат RenderFragment.

Мы можем создать новый тестовый класс ItemEditTests в проекте PassXYZ.Vault.Tests. К
разделить разметку Razor и код C#, мы можем разделить тестовый класс ItemEditTests на Razor
файл (ItemEditTests.razor) и файл кода программной части C# (ItemEditTests.razor.cs). Мы
можно объявить разметку для тестирования в файле Razor, как показано в листинге 11.5:
  
** Листинг 11.5: ItemEditTests.razor (https://epa.ms/ItemEditTests11-5)**  
  
```
@наследует тестовый контекст
@namespace PassXYZ.Vault.Tests
<h3>Тесты редактирования элементов</h3>
@код {
 частный RenderFragment _editorDialog => __builder =>
 {
 <CascadingValue Value="@_dialogId" Name="Id">
<EditorDialog IsKeyEditingEnable=@isNewItem
 OnSave=@OnSaveClicked Key=@testItem.Name
 Value=@testItem.Notes>
 @if (isNewItem) {
 <select id="itemType" @bind="testItem.ItemType"
 class="form-select" aria-label="Группа">
 <option selected value="Group">Группа</option>
 <option value="Запись">Запись</option>
 <option value="PxEntry">PxEntry</option>
 <option value="Примечания">Примечания</option>
 </выбрать>
 }
 </РедакторДиалог>
 </CascadingValue>
 };
}
```
Мы определяем делегат RenderFragment, _editorDialog, в блоке @code ItemEditTests.
бритва. Делегат RenderFragment должен принимать параметр с именем ```__builder```
Тип RenderTreeBuilder. В коде разметки мы можем получить доступ к переменным, определенным в тестовом классе.
Теперь давайте посмотрим на использование _editorDialog в файле кода программной части C# в листинге 11.6:  
  
** Листинг 11.6: ItemEditTests.razor.cs (https://epa.ms/ItemEditTests11-6)**
  
```Csharp
пространство имен PassXYZ.Vault.Tests;
[Коллекция ("Коллекция Serilog")]
общедоступный частичный класс ItemEditTests: TestContext {
 только чтение SerilogFixture serilogFixture;
 логический isNewItem { получить; набор; } = ложь;
 NewItem testItem { получить ; набор; } }
 строка _dialogId = "editItem";
 string updated_key = "Обновлен элемент";
 string updated_value = "Этот элемент обновлен.";
 общедоступные ItemEditTests (приспособление SerilogFixture) {
 testItem = новый () {
 Имя = "Новый элемент",
 Примечания = «Это новый элемент».
 };
 serilogFixture = приспособление;
 }
 void OnSaveClicked (строковый ключ, строковое значение) {
 testItem.Name = ключ; testItem.Notes = значение;
 }
 [Факт]
 общественное недействительным Edit_New_Item () {
 ИсНовыйЭлемент = Истина;
 var cut = Render(_editorDialog); ❶
 cut.Find("#itemType").Change("Entry");
 cut.Find("ввод").Change(updated_key);
 cut.Find("textarea").Change(updated_value);
 cut.Find("button[type=submit]").Click();
 Assert.Equal(updated_key, testItem.Name);
 Assert.Equal(updated_value, testItem.Notes);
 }
 [Факт]
 общественное недействительное Edit_Existing_Item () {
 ИсНовыйЭлемент = Ложь; ❸
 var cut = Render(_editorDialog); ❶
var ex = Assert.Throws<ElementNotFoundException>(() =>
 cut.Find("#itemType").Change("Entry")); ❷
 Assert.Equal("Не найдено ни одного элемента, соответствующего
селектор '#itemType'", ex.Message); ❹
 cut.Find("textarea").Change(updated_value);
 cut.Find("button[type=submit]").Click();
 Assert.Equal(updated_value, testItem.Notes);
 }
}
```
 Поскольку _editorDialog определяет редактирование элемента, мы можем реализовать несколько тестовых случаев для
```_editorDialog```. Мы видим, что мы отображаем _editorDialog, ❶, для нескольких тестовых случаев, таких как
как Edit_New_Item и Edit_Existing_Item. Используя делегат RenderFragment, наш
код тестирования выглядит намного элегантнее и чище. Если бы мы не пошли этим путем, нам пришлось бы повторить
длинный код разметки в нескольких местах. Использование кода C# напрямую могло даже привести к большему дублированию кода.
В обоих тестовых случаях мы следуем процессу, аналогичному тестированию EditorDialog, устанавливая значения, а затем
нажав на кнопку Сохранить. В коде разметки у нас есть определенный тег ```<select>```. Мы можем изменить
параметр ❷ тега ```<select>``` в тестовом коде. Этот тег ```<select>``` отображается условно
ссылаясь на значение переменной isNewItem. В тесте Edit_Existing_Item мы также можем
проверить отрицательный случай, когда для переменной isNewItem ❸ установлено значение false. В этом случае исключение
выдается, поскольку тег ```<select>``` не отображается. Мы видим, что bUnit также можно использовать для тестирования
отрицательные случаи путем проверки содержания исключения, ❹.
Мы создали тесты bUnit для общих компонентов в проекте PassXYZ.BlazorUI в предыдущем
Примеры. Поскольку эти общие компоненты являются многократно используемыми строительными блоками для пользовательского интерфейса высокого уровня, большинство
они объявляют многие параметры компонента. Делегат RenderFragment или шаблоны Razor
может помочь упростить настройку теста.
Если мы перейдем на страницы Razor в папке Pages проекта PassXYZ.Vault, Items,
ItemDetail или Login также являются компонентами Razor, но они не предназначены для повторного использования. Они есть
Страницы Razor с определенными шаблонами маршрутов, и у них не определено много параметров компонентов.  
Параметры компонентов, объявленные на этих страницах Razor, используются для маршрутизации. Когда мы
разрабатывая тестовые примеры для этих страниц Razor, мы можем реализовать тесты в классе C#, а не в файлах Razor.  
  
# Тестирование страниц Razor  
  
В процессе тестирования разработки для страниц Razor мы узнаем о некоторых очень полезных bUnit.
функции. Мы не сможем просмотреть все тесты страниц Razor в нашем приложении, поэтому мы будем использовать ItemDetail.
В качестве примера. ItemDetail — это страница Razor для отображения содержимого записи пароля. Там
для него определен маршрут:
  
```@page "/entry/{SelectedItemId}"```
  
Когда мы хотим отобразить страницу ItemDetail, нам нужно передать информацию об идентификаторе для экземпляра Item.
к нему, и этот экземпляр не может быть группой. Инициализация страницы ItemDetail выполняется в
Метод жизненного цикла OnParametersSet(), как мы видим здесь:  
  
```Csharp
защищенное переопределение void OnParametersSet() {
 base.OnParametersSet();
 если (SelectedItemId!= ноль) {
 selectedItem = DataStore.GetItem(SelectedItemId, true);
 если (selectedItem == ноль) {
 бросить новое исключение InvalidOperationException( ❷
 "ItemDetail: запись с SelectedItemId не найдена");
 }
 еще {
 если (выбранныйItem.IsGroup) {
 бросить новое исключение InvalidOperationException( ❸
 "ItemDetail: SelectedItemId не должен группироваться здесь.");
 }
 иначе { ❹
 поля.Очистить();
 Список<Поле> tmpFields = selectedItem.GetFields();
 foreach (поле поля в tmpFields) {
 поля.Добавить(поле);
 }
 примечания = selectedItem.GetNotesInHtml();
 }
 }
 }
 еще {
бросить новое исключение InvalidOperationException( ❶
 "ItemDetail: SelectedItemId имеет значение null");
 }
}

Мы разработаем тестовый класс ItemDetailTests, чтобы охватить все пути выполнения в
ПриНабореПараметры(). Чтобы охватить все пути выполнения, мы можем найти следующие тестовые примеры:
• Тестовый случай 1: Инициализировать экземпляр ItemDetail без идентификатора выбранного элемента. Мы получим
Исключение InvalidOperationException, в данном случае ❶.
• Контрольный пример 2: Инициализируйте экземпляр ItemDetail с неправильным идентификатором элемента. В этом случае мы будем
получить исключение InvalidOperationException, ❷.
• Тестовый пример 3: Инициализируйте экземпляр ItemDetail с допустимым идентификатором элемента, но типом элемента как
группа. В этом случае мы получим исключение InvalidOperationException, ❸.
• Контрольный пример 4. Инициализируйте экземпляр ItemDetail с допустимым идентификатором элемента и типом элемента.
запись, ❹.
Мы можем реализовать эти тестовые примеры в тестовом классе ItemDetailTests bUnit, как показано здесь.
Листинг 11.7:
```
**Листинг 11.7: ItemDetailTests.cs (https://epa.ms/ItemDetailTests11-7)**
  
 ```Csharp
 пространство имен PassXYZ.Vault.Tests;
[Коллекция ("Коллекция Serilog")]
открытый класс ItemDetailTests: TestContext {
 SerilogFixture
 Mock<IDataStore<Item>> dataStore;
 общедоступные ItemDetailTests (приспособление SerilogFixture) {
 serilogFixture = приспособление;
 dataStore = новый Mock<IDataStore<Item>>(); ①
 Services.AddSingleton<IDataStore<Item>>
 (хранилище данных.Объект); ②
 }
 [Факт]
 public void Init_Empty_ItemDetail() { ③
 var ex = Assert.Throws<InvalidOperationException>(
 () => RenderComponent<ItemDetail>());
 Утвердить.Равно(
 "ItemDetail: SelectedItemId имеет значение null", ex.Message);
 }
 [Факт]
 public void Load_ItemDetail_WithWrongId() {
 var ex = Assert.Throws<InvalidOperationException>(() =>
 RenderComponent<ItemDetail>(параметры =>
 параметры.Добавить(p => p.SelectedItemId, "Неправильный идентификатор")));
 Assert.Equal("ItemDetail: запись не может быть найдена с
 SelectedItemId", ex.Message);
 }
 [Факт]
 общественные пустоты Load_ItemDetail_WithGroup () {
 Элемент testGroup = новая PwGroup(true, true) {
 Имя = "Группа по умолчанию",
 Notes = "Это группа в ItemDetailTests."
 };
 dataStore.Setup(x => x.GetItem(It.IsAny<string>(),
 It.IsAny<bool>())).Returns(testGroup);
 var ex = Assert.Throws<InvalidOperationException>(() =>
 RenderComponent<ItemDetail>(параметры =>
 параметры.Добавить(p => p.SelectedItemId, testGroup.Id)));
 Assert.Equal("ItemDetail: SelectedItemId не должен быть
 группа здесь.", ex.Message);
 }
 [Факт]
 public void Load_ItemDetail_WithEmptyFieldList() {
 Элемент testEntry = новый PwEntry (правда, правда) {
 Имя = "Запись по умолчанию",
 Notes = "Это запись с пустым списком полей."
 };
 dataStore.Setup(x => x.GetItem(It.IsAny<string>(),
 It.IsAny<bool>())).Returns(testEntry);
 var cut = RenderComponent<ItemDetail>(параметры =>
 параметры.Добавить(p => p.SelectedItemId, testEntry.Id));
 cut.Find("статья").MarkupMatches(
 $"<article><p>{testEntry.Notes}</p></article>");
 }
}
 ```
Первый тестовый пример реализован в Init_Empty_ItemDetail, ③. В тестовой установке мы просто пытаемся
для рендеринга компонента ItemDetail напрямую, без передачи ему идентификатора выбранного элемента. Мы ожидаем
Выбрасывается исключение InvalidOperationException.
Прежде чем мы сможем запустить тестовый пример, нам нужно сначала разрешить зависимость IDataStore. Деталь элемента
имеет зависимость от интерфейса IDataStore<Item>```. Мы можем решить это, используя зависимость
инъекция. В нашем приложении эта зависимость зарегистрирована в MauiProgram.cs.
В bUnit внедрение зависимостей поддерживается с помощью TestContext. Мы можем зарегистрировать зависимость
используя AddSingleton(), ②. Чтобы изолировать тест, мы используем макетную структуру Moq, ①, чтобы заменить
фактическая реализация IDataStore, поэтому мы можем уменьшить сложность настройки теста.
Используя Moq, нам нужно только подделать метод или свойство, которые нам нужны в нашей тестовой настройке. Это может помочь
чтобы изолировать наши тесты от их зависимостей. Чтобы использовать структуру Moq, мы можем создать объект Moq.
используя интерфейс или класс, который нам нужен в качестве параметра типа. Позже мы можем определить поведение
целевой интерфейс или класс, когда мы его используем. В конструкторе мы создаем Mock-объект и регистрируем
Интерфейс ```IDataStore<Item>```, использующий dataStore.Object:
 
```Csharp
dataStore = новый Mock<IDataStore<Item>>();
Services.AddSingleton<IDataStore<Item>>(dataStore.Object);
```
После того, как мы зарегистрируем IDataStore в конструкторе, мы можем снова выполнить первый тестовый пример. На этот раз,
мы можем получить исключение и убедиться, что сообщение соответствует нашим ожиданиям:  
  
 ```Csharp
[Факт]
общественные пустоты Init_Empty_ItemDetail () {
 var ex = Assert.Throws<InvalidOperationException>(
 () => RenderComponent<ItemDetail>());
 Assert.Equal("ItemDetail: SelectedItemId имеет значение null",
 экс.Сообщение);
}
 ```
Далее, давайте посмотрим на второй тестовый пример. Во втором тестовом примере мы передаем недопустимый идентификатор в ItemDetail.
и попробуй отрендерить:  
  
```Csharp
[Факт]
public void Load_ItemDetail_WithWrongId() {
var ex = Assert.Throws<InvalidOperationException>(() =>
RenderComponent<ItemDetail>(параметры =>
 параметры.Добавить(
p => p.SelectedItemId, "Неправильный идентификатор")));
 Assert.Equal("ItemDetail: запись не может быть найдена с
 SelectedItemId", ex.Message);
}
```
В этом случае мы также получаем ожидаемое исключение, и можем проверить его содержимое с помощью Assert.Equal.
В третьем тестовом примере мы передаем допустимый идентификатор в ItemDetail, но тип элемента — это группа. это случай
это трудно повторить в интеграционном тесте или пользовательском приемочном тесте. В модульном тесте довольно легко
проверьте, как мы видим здесь:  
  
```Csharp
[Факт]
общественные пустоты Load_ItemDetail_WithGroup () {
 Элемент testGroup = новая PwGroup(true, true) {
 Имя = "Группа по умолчанию",
 Notes = "Это группа в ItemDetailTests."
 };
 dataStore.Setup(x => x.GetItem(It.IsAny<string>(),
 It.IsAny<bool>())).Returns(testGroup);
 var ex = Assert.Throws<InvalidOperationException>(() =>
RenderComponent<ItemDetail>(параметры =>
параметры.Добавить(p => p.SelectedItemId, testGroup.Id)));
 Assert.Equal("ItemDetail: SelectedItemId не должен быть
 группа здесь.", ex.Message);
 } 
```
Чтобы проверить это, нам нужно создать группу и назначить ее переменной testGroup. В этом тестовом примере нам нужно
для вызова метода GetItem() IDataStore. Поскольку мы издевались над IDataStore в нашей настройке,
здесь нам также нужно смоделировать метод GetItem(). Метод Moq возвращает testGroup
когда его зовут. После того, как тестовая настройка готова, мы можем визуализировать ItemDetail с помощью testGroup.Id.
Результат теста является исключением, которое мы ожидаем.  

В последнем тестовом случае мы передадим действительный идентификатор элемента, а тип элемента — запись:

```Csharp
[Факт]
public void Load_ItemDetail_WithEmptyFieldList() {
Элемент testEntry = новый PwEntry (правда, правда) {
Имя = "Запись по умолчанию",
 Notes = "Это запись с пустым списком полей."
 };
 dataStore.Setup(x => x.GetItem(It.IsAny<string>(),
 It.IsAny<bool>())).Returns(testEntry);
 var cut = RenderComponent<ItemDetail>(параметры =>
 параметры.Добавить(p => p.SelectedItemId, testEntry.Id));
 cut.Find("статья").MarkupMatches(
 $"<article><p>{testEntry.Notes}</p></article>");
 Debug.WriteLine($"{cut.Markup}");
}
```
 
Этот тестовый пример похож на третий тестовый пример, за исключением того, что мы можем создать запись и назначить ее для testEntry.
переменная. После того, как мы визуализируем ItemDetail с помощью testEntry.Id, мы можем убедиться, что ```<article>```
визуализированный HTML-тег — это тот, который мы ожидаем.
До сих пор мы научились тестировать компоненты Razor с помощью bUnit. Мы видим, что можем достичь
очень высокий уровень тестового покрытия с использованием bUnit. Это одно из преимуществ дизайна пользовательского интерфейса Blazor.
Теперь мы завершили все темы, которые хотели изучить по разработке модульных тестов с помощью .NET.
MAUI в этой главе.  
  
# Краткое содержание

 В этой главе мы представили разработку модульных тестов для приложений .NET MAUI. Есть несколько тестов
доступные рамки. Мы выбрали xUnit в качестве основы в этой главе. В шаблоне MVVM
модульное тестирование уровня модели такое же, как и для любого другого приложения .NET. Мы разработали тест-кейсы
для интерфейса IDataStore для тестирования уровня нашей модели. Для модульного теста представления и модели представления
мы сосредоточились на приложении eBlazor Hybrid, используя тестовую библиотеку bUnit. Мы можем разработать сквозной
модульный тест для приложения Blazor Hybrid с платформой xUnit и библиотекой bUnit. С помощью bUnit мы рассмотрели
такие темы, как шаблоны Razor, делегат RenderFragment, внедрение зависимостей и
Moq-фреймворк.
Зная о модульном тестировании из этой главы, вы теперь сможете работать самостоятельно.
разработка юнит-тестов. Пожалуйста, обратитесь к разделу «Дополнительная литература», чтобы найти дополнительную информацию о .NET.
разработка юнит-тестов.
Модульное тестирование может быть частью конвейера CI/CD. С настройкой CI/CD мы можем автоматически запускать модульные тесты.
в процессе разработки. Мы еще обсудим эту тему в следующей главе.  
  
# Дальнейшее чтение

* Microsoft Visual Studio 2005 Unleashed Ларса Пауэрса и Майка Снелла

* https://www.amazon.com/Microsoft-Visual-Studio-2005-Unleashed/dp/0672328194

* МСТтест

* https://github.com/microsoft/testfx

* Усиление модульных тестов Visual Studio, Джон Роббинс.

* https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/march/bugslayer-strengthening-visual-studio-unit-tests

* Карманный справочник NUnit от Билла Гамильтона

* https://www.amazon.com/NUnit-Pocket-Reference-Running-OReilly/dp/0596007396

* Релизы NUnit на SourceForge

* https://sourceforge.net/projects/nunit/

* Почему мы создали xUnit 1.0

* https://xunit.net/docs/why-did-we-build-xunit-1.0

* Документация xUnit

* https://xunit.net/

* Примечание к выпуску xUnit.NET 2.0

* https://xunit.net/releases/2.0  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


# Развертывание и публикация в магазинах приложений

После завершения разработки мы хотим опубликовать наше приложение в различных магазинах приложений. С
.NET MAUI — это кроссплатформенный фреймворк, мы можем собрать один и тот же исходный код для Android, iOS,
macOS и Windows. Наше приложение можно развернуть в репозитории, таком как GitHub, но большинство пользователей
из этих платформ вместо этого используют магазины приложений. Нам нужно знать, как подготовить наше приложение для другого приложения.
магазины. Это тема данной главы. В этой главе мы рассмотрим подготовку приложения
пакеты перед публикацией.

В этой главе мы рассмотрим следующие темы:

* Подготовка пакетов приложений к публикации

* Автоматизация процесса сборки с помощью GitHub Actions.

# Технические требования

Для тестирования и отладки исходного кода в этой главе нам необходимо установить Visual Studio 2022 как в Windows,
и среды macOS. Пожалуйста, обратитесь к разделу Настройка среды разработки в Главе 1,

Начало работы с .NET MAUI для получения полной информации о настройке среды.

Мы создадим пакеты для Windows и Android, используя Windows, и создадим пакеты для iOS и macOS.
с помощью macOS.

Исходный код этой главы доступен в следующем репозитории GitHub:

https://github.com/PacktPublishing/.NET-MAUI-Cross-PlatformApplication-Development/tree/main/Chapter12

# Подготовка пакетов приложений к публикации

В предыдущих главах в .NET MAUI требовалось очень мало знаний о конкретной платформе.
разработка. Однако мы не можем избежать информации о конкретной платформе, когда готовимся к публикации.
наше приложение в отдельные магазины приложений. В этой главе мы расскажем, что нам нужно для подготовки приложения.
для публикации, а затем мы расскажем, как автоматизировать процесс с помощью GitHub Actions.

# Что подготовить к публикации

Чтобы подготовиться к публикации, мы сосредоточимся на работе, которую нам нужно сделать перед отправкой пакета.
в магазин приложений. После того, как пакеты будут загружены в выбранный вами магазин приложений, обратитесь к документам
в каждом магазине приложений о фактическом процессе публикации.

Готовясь к публикации, мы пытаемся ответить на следующие вопросы:

* Как идентифицировать приложение в магазине приложений

* Как определить разработчиков приложения

* Какие устройства поддерживает приложение

Для создания и подписи пакетов приложений на разных платформах существует конфигурация для конкретной платформы.
вовлеченный. В .NET MAUI информация о платформе включена в файл проекта Visual Studio.
и файл конфигурации для конкретной платформы. В файле проекта Visual Studio условная компиляция
используется для указания информации, специфичной для платформы. Мы можем обратиться к Таблице 12.1 для обзора того, что
нам нужно изменить для каждой платформы.

![изображение](https://user-images.githubusercontent.com/26972859/232075525-a24a9192-7dd4-41cc-a04b-20ae336af32d.png)

Таблица 12.1: Конфигурация сборки

В таблице 12.1 для идентификации приложения используются переменные ApplicationId и ApplicationVersion.
определены в файле проекта Visual Studio. Для каждой платформы существует файл конфигурации платформы.

При распространении нашего приложения для Android мы создаем файл .apk или файл .aab. Файл .apk
исходный формат пакета Android, который можно использовать для установки пакета приложения на устройство или
эмулятор. Файл .aab используется для отправки приложения в Google Play Store. Перед отправкой нам нужно
подписать пакет с помощью Keystore. ApplicationId и ApplicationVersion сопоставлены
к идентификатору пакета и коду версии в файле AndroidManifest.xml конфигурации Android.
При распространении нашего приложения для iOS или macOS создается файл .ipa для iOS. Файл .app или .pkg
создается для macOS. Чтобы подписать пакет iOS или macOS, нам нужен сертификат распространения и
профиль распределения. ApplicationId сопоставляется с идентификатором пакета и ApplicationVersion.
сопоставляется с версией пакета в Info.plist.
При распространении нашего приложения для Windows используется формат пакета MSIX. Мы создадим пакет
в файле с расширением .msix. В Windows вместо идентификатора используется универсальный уникальный идентификатор (UUID).
Идентификатор приложения. Этот UUID создается как ApplicationGuid в качестве идентификатора приложения.
ApplicationVersion сопоставляется с атрибутом Version тега Identity в Package.
appxmanifest.

---
**Что такое MSIX?**

MSIX — это новый формат пакета приложений Windows, который можно использовать для всех приложений Windows. Пожалуйста
обратитесь к документации Microsoft, чтобы узнать больше информации:
https://learn.microsoft.com/en-us/windows/msix/обзор
---

В последующих разделах мы расскажем, как создавать пакеты выпусков на каждой платформе. Мы
будет собирать пакеты Windows и Android в Windows и пакеты iOS и macOS в macOS.
Мы попробуем сделать это как с помощью Visual Studio, так и с помощью командной строки.

# Публикация в Microsoft Store

Мы можем создать пакет .msix для Microsoft Store с помощью Visual Studio или командной строки.
в Windows.

В Visual Studio нам нужно установить целевую структуру как net6.0-windows10.0.19041.0 и установить
тип сборки для Release.

После этого мы можем щелкнуть правой кнопкой мыши по узлу проекта и выбрать пункт меню «Опубликовать…».

Как мы видим на рис. 12.1, появится окно с надписью «Выбор метода распределения». Мы можем
выберите Microsoft Store под новым именем приложения и нажмите кнопку «Далее».

![изображение](https://user-images.githubusercontent.com/26972859/232075939-2283e970-ffdc-419e-a7e8-71e68af1c49e.png)

Рисунок 12.1: Выбор метода распространения

Прежде чем мы перейдем к следующему шагу на рис. 12.2, нам нужно подготовить имя приложения.

Чтобы создать новое имя приложения, нам нужно сделать это в Microsoft Store по следующему URL-адресу:

http://developer.microsoft.com/dashboard

Когда у нас есть имя приложения, мы можем связать его с нашим приложением. Вы можете увидеть, как это сделать, на рис. 12.2.

![изображение](https://user-images.githubusercontent.com/26972859/232076167-675bd80e-85ca-4b61-8893-1329717e337c.png)

Рисунок 12.2: Связывание вашего приложения с Microsoft Store

После того, как мы нажмем кнопку «Далее», Visual Studio выполнит для нас поиск имени приложения в Microsoft Store.

Имя приложения, созданного в Microsoft Store, показано на рис. 12.3.

После того, как мы нажмем кнопку «Далее», Visual Studio выполнит для нас поиск имени приложения в Microsoft Store.
Имя приложения, созданного в Microsoft Store, показано на рис. 12.3.

![изображение](https://user-images.githubusercontent.com/26972859/232076381-9a4c8ed4-5a0e-4a83-9277-08fbf22ca981.png)

Рисунок 12.3: Выбор имени приложения

После выбора имени приложения нажмите кнопку «Далее». Появится экран для выбора и настройки пакетов.
появляются, как показано на рисунке 12.4.

![изображение](https://user-images.githubusercontent.com/26972859/232076523-c8a89b61-97a5-4c78-8531-6cfe8199928b.png)

Рисунок 12.4: Выбор и настройка пакетов

Мы можем щелкнуть раскрывающееся меню в разделе «Профиль публикации». Диалог будет показан, как мы можем
см. рис. 12.4. После нажатия кнопки OK в диалоговом окне будет создана новая публикация MSIX.
профиль. Когда у нас есть профиль публикации, мы можем нажать кнопку «Создать» (которая теперь станет
активен) для создания пакета. Завершение сборки и создание пакета займет некоторое время. Как только это
завершится, мы увидим следующий экран, показанный на рис. 12.5, и теперь пакет MSIX
готовы быть представлены.

![изображение](https://user-images.githubusercontent.com/26972859/232076641-61d6026b-c27d-43c7-9f34-394cbd7ece5e.png)

Рисунок 12.5: Пакет MSIX

Расположение нового пакета показано на рис. 12.5. Есть вариант, с помощью которого мы можем проверить
пакет, запустив комплект сертификации приложений для Windows.
На предыдущих шагах два файла (как показано здесь), относящиеся к публикации приложения, будут
созданный в папке проекта:

* Package.StoreAssociation.xml — это файл для связывания приложения с Microsoft Store.
* Properties\PublishProfiles\MSIX-win10-x86.pubxml — это профиль публикации.

Оба файла могут содержать конфиденциальную информацию, поэтому их не следует возвращать в репозиторий Git.
Чтобы интегрировать процесс сборки в среду CI/CD, нам нужно выполнить процесс сборки, используя
командная строка. Чтобы создать пакет .msix с помощью командной строки, мы можем выполнить следующее:
команда из папки проекта:

```
dotnet publish PassXYZ.Vault/PassXYZ.Vault.csproj -c Release -f net6.0-windows10.0.19041.0
```
После создания пакета .msix мы можем загрузить его в Microsoft Store в разделе «Пакеты»
подача приложения.

# Публикация в магазине Google Play

Чтобы подготовиться к отправке в Google Play Store, вам необходимо создать новое приложение в Google Play.
Игровая консоль. Чтобы создать новое приложение в консоли Google Play, вам потребуется учетная запись Google.
Чтобы идентифицировать приложение, каждое приложение Android имеет уникальный идентификатор приложения или идентификатор пакета, определенный в
конфигурационный файл AndroidManifest.xml. Этот файл конфигурации создается Visual Studio
из файла проекта, и его можно найти в Platforms/Android/AndroidManifest.xml.
Давайте рассмотрим AndroidManifest.xml нашего приложения в листинге 12.1:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest
 xmlns:android="http://schemas.android.com/apk/res/android"
 package="com.passxyz.vault2" ❶
 android:installLocation="auto"
 android:versionCode="1"> ❷
 <application
android:allowBackup="true"
android:icon="@mipmap/appicon"
android:roundIcon="@mipmap/appicon_round"
android:supportsRtl="true"></application>
 <uses-permission
 android:name="android.permission.ACCESS_NETWORK_STATE" />
 <uses-permission android:name=
 "android.permission.INTERNET" />
</manifest>
```
**Листинг 12.1: AndroidManifest.xml (https://epa.ms/AndroidManifest12-1)**

В нашем приложении идентификатор приложения — «com.passxyz.vault2» ❶, который генерируется из
ApplicationId, а версия — это значение android:versionCode ❷, которое генерируется
из версии приложения.

Вот объявление идентификатора и версии приложения в файле проекта PassXYZ.Vault.csproj:

```xml
<!-- App Identifier -->
<ApplicationId>com.passxyz.vault2</ApplicationId>
<ApplicationIdGuid>8606B3B5-C03C-41D7-825F-B33718CF791C
 </ApplicationIdGuid>
<!-- Versions -->
<ApplicationDisplayVersion>1.0</ApplicationDisplayVersion>
<ApplicationVersion>1</ApplicationVersion>
```
Чтобы подписать пакет Android, нам нужно создать файл хранилища ключей. Пожалуйста, обратитесь к следующему Android
документ для получения информации о том, как создать файл хранилища ключей и подписать приложение для Android:
https://developer.android.com/studio/publish/app-signing
После того, как у нас есть файл хранилища ключей и подготовлена ​​предыдущая конфигурация, нам нужно установить цель
framework как net6.0-android и установите тип сборки как Release в Visual Studio.
Теперь мы можем щелкнуть правой кнопкой мыши узел проекта и выбрать «Опубликовать…». После этого начнется сборка и мы
можно увидеть, что архив был создан, как показано на рис. 12.6.

![изображение](https://user-images.githubusercontent.com/26972859/232077354-88dca61e-9c91-478c-9813-11eab963db6f.png)

Рисунок 12.6: Создание архива для Android

Как только пакет создан, мы можем подписать его, нажав кнопку «Распространить…», как показано на рис. 12.6.

![изображение](https://user-images.githubusercontent.com/26972859/232077544-6ae2eca9-b6ec-4da6-90fc-338942ad36be.png)

Рисунок 12.7: Выбор канала

Как только мы нажмем кнопку «Распространить…», нам нужно выбрать канал распространения, как показано на рис. 12.7.
Можно подписать и отправить пакет, выбрав Google Play, но мы выберем Ad Hoc, чтобы
подписать его. Мы отправим подписанный пакет в Google Play вручную позже.
Как только мы выберем Ad Hoc, мы увидим другой экран, как показано на рисунке 12.8.

![изображение](https://user-images.githubusercontent.com/26972859/232077646-ceddf1e5-cffd-48bf-92e6-3e17ca465c8a.png)

Рисунок 12.8: Подписание удостоверения с использованием файла хранилища ключей

Как показано на рис. 12.8, мы можем нажать кнопку +, чтобы добавить файл хранилища ключей. После этого мы можем нажать кнопку
Кнопка «Сохранить как», чтобы подписать пакет.
Подписанный файл .aab можно отправить в магазин Google Play в консоли Google Play.
Если у вас нет существующего файла хранилища ключей, вы можете следовать инструкциям по созданию нового файла.
Расположение файлов хранилища ключей по умолчанию — %USERPROFILE%\AppData\Local\Xamarin\Mono для Android\Keystore\.
Чтобы создать пакет из командной строки, мы можем выполнить следующую команду в папке проекта:

``dotnet publish PassXYZ.Vault/PassXYZ.Vault.csproj -c Release -f net6.0-android``

Чтобы узнать, как загрузить подписанный Android App Bundle в Google Play Store, см.
следующий документ Android:

https://developer.android.com/studio/publish/upload-bundle

# Публикация в Apple App Store

Мы можем представить отправку приложения iOS или macOS в App Store вместе, поскольку они
много сходства.

В приложениях iOS или macOS идентификатор и версия сборщика используются для идентификации приложения. Этот
информация хранится в файле конфигурации Info.plist. Генерируется идентификатор бандлера
из ApplicationId, а версия упаковщика создается из ApplicationVersion в
файл проекта Visual Studio.

Чтобы подписать пакет, нам нужен сертификат подписи и профиль обеспечения. Чтобы создать подпись
сертификат и профиль обеспечения, мы можем обратиться к следующему документу:
https://learn.microsoft.com/en-us/dotnet/maui/ios/deployment/provision
Приложения для iOS можно распространять только через App Store. Пакет для подачи представляет собой файл с
расширение .ipa. Приложения для macOS также можно распространять через App Store, но пакет
сам может быть установлен напрямую.

Несмотря на то, что мы можем выполнить некоторые шаги публикации в среде Windows, нам все равно нужно
для подключения к компьютеру с macOS, доступному по сети. Чтобы уменьшить сложность, мы используем macOS.
среду для сборки приложений для iOS и macOS. Перед сборкой пакетов нам нужно
обновите файл проекта Visual Studio, чтобы настроить собственный сертификат подписи и профиль распространения:

```
<PropertyGroup Condition="$(TargetFramework.Contains('-ios'))
and '$(Configuration)' == 'Release'">
 <RuntimeIdentifier>ios-arm64</RuntimeIdentifier>
 <CodesignKey>iPhone Distribution: Shugao Ye (W9WL9WPD24)
 </CodesignKey>
 <CodesignProvision>passxyz_2022</CodesignProvision>
</PropertyGroup>
<PropertyGroup Condition="$(TargetFramework.Contains('-
 maccatalyst')) and '$(Configuration)' == 'Release'">
 <CodesignEntitlement>Entitlements.plist
 </CodesignEntitlement>
 <CodesignKey>
 3rd Party Mac Developer Application: Shugao Ye
 (W9WL9WPD24)
 </CodesignKey>
 <CodesignProvision>passxyz.maccatalyst</CodesignProvision>
</PropertyGroup>
```
Как мы видим, мы можем использовать условную конфигурацию как для iOS, так и для macOS. Различные подписи
сертификаты и профили распространения используются для iOS и macOS.

В Visual Studio для macOS мы также можем настроить сертификаты подписи и профили распространения в
настройки проекта для iOS, как показано на рис. 12.9. Этот параметр пока не поддерживается для macOS.
момент, но вы можете обнаружить, что он уже доступен, когда вы читаете эту книгу.

![изображение](https://user-images.githubusercontent.com/26972859/232078124-e30243ac-9c79-4abf-85f3-3ac4a335bd5f.png)

Рисунок 12.9: Подписание пакета конфигурации

Если мы не уверены, верны ли настройки, мы можем проверить их с помощью Xcode. Мы можем создать
приложение в Xcode, использующее тот же идентификатор комплекта "com.passxyz.vault2", что и наше приложение. После этого мы
можно проверить конфигурацию подписи, как показано на рисунке 12.10.

![изображение](https://user-images.githubusercontent.com/26972859/232079686-0735b208-9a3d-488f-8f97-a22d158f11b5.png)

Рисунок 12.10: Настройки подписи iOS в Xcode

Если есть какие-либо проблемы с сертификатом подписи или профилем обеспечения, мы можем увидеть сообщения об ошибках.
сообщает Xcode. Как только параметр будет правильным в Xcode, тот же параметр можно использовать в Visual Studio.
проект без вопросов.
Со всеми готовыми конфигурациями мы можем создать файл .ipa в папке проекта, используя
следующая команда:

```
dotnet publish PassXYZ.Vault/PassXYZ.Vault.csproj -c Release -f net6.0-ios /p:CreatePackage=true /p:ArchiveOnBuild=True
```
После успешного выполнения предыдущей команды создается файл .ipa. Мы можем представить это
файл в App Store. Существует три метода загрузки пакета в App Store.
Пожалуйста, обратитесь к следующему документу, чтобы узнать больше деталей:

https://help.apple.com/app-store-connect/#/devb1c185036

Из предыдущего документа мы знаем, что можем использовать Xcode, altool или Transporter для загрузки
пакет.

Здесь мы будем использовать приложение Transporter. После входа в систему с помощью приложения Transporter мы можем загрузить пакет в App Store, как показано на рис. 12.11.

![изображение](https://user-images.githubusercontent.com/26972859/232079996-39266ced-4bba-464d-95a4-48189315f80f.png)

Рисунок 12.11: Загрузка пакета с помощью приложения Transporter

Процессы создания и загрузки пакета macOS аналогичны процессам для приложения iOS. Там
— это три разных фреймворка (AppKit, MacCatalyst и SwiftUI), которые можно использовать для сборки macOS.
Программы. В .NET MAUI MacCatalyst используется в реализации для конкретной платформы.
По умолчанию App Sandbox не включен в приложениях MacCatalyst, поэтому нам нужно включить его. Чтобы включить его в
приложение macOS, нам нужно добавить файл Entitlements.plist в конфигурацию сборки. Мы можем
просмотрите файл Entitlements.plist в листинге 12.2:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
 "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
 <key>com.apple.security.app-sandbox</key>
 <true/>
 <key>com.apple.security.files.user-selected.read-only
 </key>
 <true/>
 <key>com.apple.security.network.client</key>
 <true/>
</dict>
</plist>
```
** Листинг 12.2: Entitlements.plist (https://epa.ms/Entitlements12-2)**

Мы не можем проверить конфигурацию сертификата подписи и профиля подготовки в Visual Studio.
для macOS на данный момент, но мы можем проверить это в Xcode, как показано на рисунке 12.12.

![изображение](https://user-images.githubusercontent.com/26972859/232080280-13dcd9ef-309a-40c2-a71c-3ecfabd92008.png)

Рисунок 12.12: Настройки подписи приложения macOS в Xcode

Когда все конфигурации готовы, мы можем собрать пакет в папке нашего проекта, используя следующую команду:

```
dotnet publish PassXYZ.Vault/PassXYZ.Vault.csproj -c Release -f net6.0-maccatalyst /p:CreatePackage=true /p:EnablePackageSigning=true"

```
После успешной сборки пакета мы можем загрузить файл .pkg в App Store, используя
Приложение Transporter, как показано на рисунке 12.13. Мы видим, что мы загрузили как iOS, так и macOS.
пакеты в App Store успешно.

![изображение](https://user-images.githubusercontent.com/26972859/232080500-432397c4-7f71-4ad4-810d-090fec25b0c3.png)

Рисунок 12.13: Загрузка приложения macOS с помощью приложения Transporter

После загрузки пакетов в Microsoft Store, Google Play Store и App Store мы
можно протестировать загруженные пакеты перед окончательным выпуском, используя инструменты тестирования, предоставляемые магазинами:

* App Store — TestFlight можно использовать для тестирования приложений iOS/macOS перед их выпуском в производство.

* Магазин Google Play — альфа- или бета-тестирование может быть настроено до выпуска продукта.

* Microsoft Store — тестовые пакеты можно использовать в Microsoft Store для тестирования загруженных пакетов.

Мы узнали основные этапы подготовки пакетов приложений для поддерживаемых платформ. С
Имея все это в виду, мы можем изучить, как настроить автоматическую сборку приложения .NET MAUI в непрерывном режиме.
среды интеграции и непрерывной доставки (CI/CD), такой как GitHub Actions или Azure DevOps.

# Действия на GitHub

Поскольку наш исходный код размещен на GitHub, мы будем использовать действия GitHub в качестве примера, чтобы представить
как настроить рабочие процессы CI для разработки .NET MAUI.

# Понимание действий GitHub

GitHub Actions — это платформа CI/CD, которую можно использовать для поддержки автоматизации развертывания. Для
Разработка приложений .NET MAUI, наша цель — создавать, тестировать и развертывать наши приложения в магазинах приложений или указанных
издательские каналы. В этом разделе мы сосредоточимся на CI с использованием GitHub Actions, а не на обоих CI
и компакт-диск. Чтобы развернуть приложения в различных магазинах, необходимо выполнить множество шагов настройки для конкретной учетной записи, см.
документ .NET MAUI для деталей:

https://learn.microsoft.com/en-us/dotnet/maui/deployment/

Рабочий процесс GitHub Actions — это процесс автоматической сборки и развертывания результатов из
проект. Рабочий процесс обычно начинается с события, такого как событие push или pull_request, или когда
подается вопрос. После запуска рабочего процесса определенные задания начнут выполнять определенные задачи.
внутри бегуна. Каждое задание состоит из одного или нескольких шагов, которые либо запускают сценарий, либо действие.
Таким образом, действия GitHub включают в себя события, бегунов, задания/шаги, действия и бегунов.

# Рабочие процессы

Рабочие процессы GitHub Actions определяются файлом YAML в каталоге .github/workflows.
YAML — это надмножество JSON, и этот язык лучше удобочитаем. Репозиторий может иметь один или
несколько рабочих процессов для выполнения разных задач. Взгляните на рисунок 12.14, чтобы понять рабочий процесс.
определенный в проекте PassXYZ.Vault.

![изображение](https://user-images.githubusercontent.com/26972859/232080767-09b3eda2-f7de-4987-8ef2-58012e38f4f2.png)

Рисунок 12.14: Рабочий процесс Windows runner

Как видно на рис. 12.14, это пример того, как рабочий процесс работает в Android и Windows.
строит. Рабочий процесс запускается событием push или pull_request или вручную. Он работает внутри
Средство запуска Windows для выполнения сборок. Когда рабочий процесс запускается, два задания, Android Build
и Windows Build, будут выполнены. Каждое задание включает четыре шага для выполнения сборки, как показано на
Рисунок 12.14.

В нашем проекте мы определили два следующих рабочих процесса:

* passxyz-ci-macos.yml — это рабочий процесс для сборки iOS и macOS на платформе запуска macOS.

* passxyz-ci-windows.yml — это рабочий процесс для сборки Android и Windows на
Бегун Windows

Мы можем видеть файлы YAML в листинге 12.3 и листинге 12.4:

```yml
name: PassXYZ.Vault CI Build (Windows)
on: ①
 push: ②
 branches: [ master ]
 paths-ignore:
 - '**/*.md'
 - '**/*.gitignore'
 - '**/*.gitattributes'
 pull_request: ③
 branches: [ master ]
 workflow_dispatch: ④
permissions:
 contents: read
env:
 DOTNET_NOLOGO: true
 DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
 DOTNET_CLI_TELEMETRY_OPTOUT: true
 DOTNETVERSION: 6.0.400
 PROJECT_NAME: PassXYZ.Vault
jobs: ⑤
# MAUI Android Build
 build-android: ⑥
 runs-on: windows-2022 ⑦
 name: Android Build
 steps: ⑧
 - name: Checkout
 uses: actions/checkout@v3 ⑨
 - name: Restore Dependencies
 run: dotnet restore ${{env.PROJECT_NAME}}/$
 {{env.PROJECT_NAME}}.csproj
 - name: Build MAUI Android
 run: dotnet publish ${{env.PROJECT_NAME}}/$
 {{env.PROJECT_NAME}}.csproj -c Release -f net6.0-
 android --no-restore
 - name: Upload Android Artifact
 uses: actions/upload-artifact@v3
 with:
 name: passxyz-android-ci-build
 path: ${{env.PROJECT_NAME}}/bin/Release/net6.0-
 android/*Signed.a*
# MAUI Windows Build
 build-windows:
 runs-on: windows-2022
 name: Windows Build
 steps:
 - name: Checkout
 uses: actions/checkout@v3
 - name: Restore Dependencies
 run: dotnet restore ${{env.PROJECT_NAME}}
 /${{env.PROJECT_NAME}}.csproj
 - name: Build MAUI Windows
 run: dotnet publish ${{env.PROJECT_NAME}}/$
 {{env.PROJECT_NAME}}.csproj -c Release -f net6.0-
 windows10.0.19041.0 --no-restore
 - name: Upload Windows Artifact
 uses: actions/upload-artifact@v3
 with:
 name: passxyz-windows-ci-build
 path: ${{env.PROJECT_NAME}}/...

```
**Листинг 12.3: passxyz-ci-windows.yml (https://epa.ms/passxyz-ci-windows12-3)**

Файл YAML в листинге 12.3 немного длинный, но он объясняет, что нужно настроить в рабочем процессе. Мы
теперь будет анализировать его шаг за шагом.

# События

Рабочий процесс запускается событиями, которые определяются после ключевого слова on: ①. В предыдущем
рабочего процесса мы определили события push ②, pull_request ③ и workflow_dispatch ④.
Как для push, так и для pull_request мы отслеживаем события в основной ветке. Мы также игнорируем
никаких коммитов, связанных со сборкой, таких как файлы уценки или файлы конфигурации. Пожалуйста, обратитесь к следующему
Документация GitHub о событиях, которые можно использовать для запуска рабочих процессов, для получения дополнительной информации:
https://docs.github.com/en/actions/using-workflows/events-thattrigger-workflows

# Вакансии

Когда рабочий процесс запускается, он начинает выполнять определенные задания. Задания определяются после заданий:
⑤ ключевое слово. В рабочем процессе можно определить одно или несколько заданий. Они идентифицируются идентификатором задания, например
сборка-андроид ⑥. Есть два задания, build-android и build-windows, определенные в
Листинг 12.3. Каждое задание может определять имя, исполнителя и несколько шагов.

# Бегуны

Бегун — это тип платформы, на которой выполняется задание. В нашей конфигурации и Android и Windows
задания выполняются с помощью средств выполнения Windows. Бегун определяется после ключевого слова run-on: ⑦.
Пожалуйста, обратитесь к документации GitHub Actions о настройке бегунов. Бегун, которого мы
используется windows-2022, который является меткой образа бегуна. В конфигурации образа windows2022 предустановлены Visual Studio 2022 и .NET MAUI, поэтому мы можем запускать сборку без
установка любых зависимостей. Однако в рабочем процессе passxyz-ci-macos.yml мы
необходимо установить .NET MAUI, прежде чем мы сможем начать сборку.

# Шаги

В задании можно определить несколько шагов, и они определяются после шагов: ⑧ ключевое слово. В обоих
Сборки Android и Windows состоят из четырех шагов: проверка, восстановление зависимостей, сборка и загрузка.
Каждый шаг может запускать сценарий или действие. На этапе оформления заказа действие оформления используется после
использует: ⑨ ключевое слово. Действие — это пользовательское приложение на платформе GitHub Actions для выполнения
сложная, но часто повторяющаяся задача. Используя действия, мы можем повторно использовать код, например компонент в объектно-ориентированном программировании. Чтобы использовать его, мы можем просто указать имя действия с необязательным номером версии.
В нашем скрипте мы можем указать действие оформления заказа как action/checkout@v3.

Исходный код действия checkout размещен на GitHub, его можно найти на следующем сайте:

https://github.com/actions/checkout

На этапах восстановления и сборки мы можем просто запустить следующую команду dotnet сразу после
запустить: синтаксис:

```dotnet restore ${{env.PROJECT_NAME}}/${{env.PROJECT_NAME}}.csproj```

После завершения сборки мы можем загрузить артефакт, используя другое действие загрузки артефакта.
Мы представили рабочий процесс passxyz-ci-windows.yml, который выполняет Android и
Сборки Windows. Давайте рассмотрим рабочий процесс passxyz-ci-macos.yml, который выполняет iOS и
сборки macOS в листинге 12.4:

```yml
name: PassXYZ.Vault CI Build (MacOS)
on:
 push:
 branches: [ master ]
 paths-ignore:
 - '**/*.md'
 - '**/*.gitignore'
 - '**/*.gitattributes'
 pull_request:
 branches: [ master ]
 workflow_dispatch:
permissions:
 contents: read
env:
 DOTNET_NOLOGO: true
 DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
 DOTNET_CLI_TELEMETRY_OPTOUT: true
 DOTNETVERSION: 6.0.400
 PROJECT_NAME: PassXYZ.Vault
jobs:
# MAUI iOS Build
 build-ios:
 runs-on: macos-12 ❶
 name: iOS Build
 steps:
 - name: Checkout
 uses: actions/checkout@v3
 - name: Install .NET MAUI ❷
 shell: pwsh
 run: |
 & dotnet nuget locals all --clear
 & dotnet workload install maui --source
 https://aka.ms/dotnet6/nuget/index.json --source
 https://api.nuget.org/v3/index.json
 & dotnet workload install android ios maccatalyst
tvos macos maui wasm-tools maui-maccatalyst --source
 https://aka.ms/dotnet6/nuget/index.json --source
 https://api.nuget.org/v3/index.json
 - name: Restore Dependencies
 run: dotnet restore ${{env.PROJECT_NAME}}
 /${{env.PROJECT_NAME}}.csproj
 - name: Build MAUI iOS
 run: dotnet build ${{env.PROJECT_NAME}}
 /${{env.PROJECT_NAME}}.csproj -c Release -f
 net6.0-ios --no-restore /p:buildForSimulator=True
 /p:packageApp=True /p:ArchiveOnBuild=False
 - name: Upload iOS Artifact
 uses: actions/upload-artifact@v3
 with:
 name: passxyz-ios-ci-build
 path: ${{env.PROJECT_NAME}}/bin/Release/net6.0-
 ios/iossimulator-x64/**/*.app
# MAUI MacCatalyst Build
 build-mac:
 runs-on: macos-12
 name: MacCatalyst Build
 steps:
 - name: Checkout
 uses: actions/checkout@v3
 - name: Install .NET MAUI
 shell: pwsh
 run: |
 & dotnet nuget locals all --clear
 & dotnet workload install maui --source
 https://aka.ms/dotnet6/nuget/index.json --source
 https://api.nuget.org/v3/index.json
 & dotnet workload install android ios maccatalyst
 tvos macos maui wasm-tools maui-maccatalyst --source
 https://aka.ms/dotnet6/nuget/index.json --source
 https://api.nuget.org/v3/index.json
 - name: Restore Dependencies
 run: dotnet restore ${{env.PROJECT_NAME}}
 /${{env.PROJECT_NAME}}.csproj
 - name: Build MAUI MacCatalyst
 run: dotnet publish ${{env.PROJECT_NAME}}
 /${{env.PROJECT_NAME}}.csproj -c Release -f
 net6.0-maccatalyst --no-restore -p:BuildIpa=True
 - name: Upload MacCatalyst Artifact
 uses: actions/upload-artifact@v3
 with:
 name: passxyz-macos-ci-build
 path: ${{env.PROJECT_NAME}}/bin/Release/net6.0-
 maccatalyst/maccatalyst-x64/publish/*.pkg
```
Листинг 12.4: passxyz-ci-macos.yml (https://epa.ms/passxyz-ci-macos12-4)

Рабочий процесс сборки iOS и macOS аналогичен рабочему процессу сборки Android и Windows.
Отличие в том, что здесь используется бегунок macos-12 ❶. Visual Studio для macOS предварительно установлена
в этом раннере, но .NET MAUI на данный момент не установлен. Нам нужно добавить дополнительный шаг для установки
.NET MAUI ❷ перед сборкой. Остальные шаги аналогичны сборке Windows или Android.

Мы представили конфигурацию всех сборок в GitHub Actions. Давайте проверим статус сборки на GitHub.

![изображение](https://user-images.githubusercontent.com/26972859/232082024-ce2a0909-c6cf-43d0-85db-00bf2d328704.png)

Рисунок 12.15: Статус сборки Android и Windows

На рис. 12.15 видно, что сборки для Android и Windows выполнены успешно.
Артефакты сборки можно загрузить с GitHub после сборки.

![изображение](https://user-images.githubusercontent.com/26972859/232082412-b59843fb-7b74-4518-a8bd-0f29684c4b74.png)

Рисунок 12.16: Статус сборки iOS и MacCatalyst

На рис. 12.16 мы видим, что сборки iOS и MacCatalyst выполнены успешно.
После успешных сборок в GitHub Actions мы завершили внедрение нашей упаковки.
app для отправки в магазин приложений и автоматизации сборки с помощью GitHub Actions.

# Краткое содержание

CI/CD — это распространенная практика в современном процессе разработки. В этой главе мы представили, как
подготовить сборку и отправить пакеты для различных магазинов приложений. Процесс после подачи
Сборка пакетов не рассматривается, поскольку они относятся к конкретным платформам и учетным записям.

После того, как мы представим процесс сборки каждой платформы, мы можем автоматизировать этот процесс в GitHub Actions.
Во второй части этой главы мы рассказали, как настроить процесс сборки в GitHub Actions.

Со всеми навыками, которые вы узнали из этой книги, вы должны быть в состоянии разработать свой собственный .NET.
MAUI и будьте готовы отправить свои приложения в поддерживаемые магазины приложений прямо сейчас.

































































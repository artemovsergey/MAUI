# Создание нашего первого приложения .NET MAUI

В этой главе мы создадим новый проект .NET MAUI и внесем необходимые изменения, чтобы
может использовать его в последующем развитии. Приложение, которое мы разработаем, — это приложение для управления паролями.
Мы будем постепенно добавлять в него функции в следующих главах. Когда мы закончим часть 1, у нас будет
функциональное приложение для управления паролями. В этой главе мы создадим приложение с помощью Visual Studio.
шаблон и инициализировать ресурсы приложения. После этого мы соберем и протестируем его на поддерживаемых
платформы. Чтобы использовать Shell в нашем приложении, мы создадим новый проект Xamarin.Forms с поддержкой Shell.
а затем перенести его в наш проект .NET MAUI.
В этой главе будут рассмотрены следующие темы:

* Настройка нового проекта .NET MAUI

* Запуск приложений и управление жизненным циклом

* Настройка ресурсов

* Создание нового проекта Xamarin.Forms с помощью Shell.

* Перенос этого проекта Xamarin.Forms в .NET MAUI.

# Технические требования

Для тестирования и отладки исходного кода в этой главе вам необходимо установить Visual Studio 2022 на обоих компьютерах.
Windows и macOS. Пожалуйста, обратитесь к разделу Настройка среды разработки в Главе 1, Получение
Начал с .NET MAUI, подробнее.

# Управление исходным кодом в этой книге

Поскольку в этой книге мы разрабатываем приложение для управления паролями поэтапно, исходный код каждой главы
строится на основе предыдущих глав. Чтобы продолжать работать над постоянным улучшением, у нас будут отдельные ветки для хранения исходного кода каждой главы. Если вы хотите клонировать исходный код
все главы одной командой, можно клонировать из основной ветки. В основной ветке у нас есть все
главы в отдельные папки. Если вы не хотите использовать Git, вы также можете скачать исходный код в виде
сжатый файл из области выпуска, как показано на следующей диаграмме (Рисунок 2.1):

![изображение](https://user-images.githubusercontent.com/26972859/231735500-c2c81f97-1278-4c04-90fc-012f3e9d3b29.png)
Рисунок 2.1: Исходный код в GitHub

Поскольку время от времени могут появляться новые выпуски .NET MAUI, теги и версии Git в
область выпуска будет обновляться в соответствии с новыми выпусками .NET MAUI и исправлениями ошибок.

Исходный код этой книги можно найти в следующем репозитории GitHub:
https://github.com/PacktPublishing/Modern-Cross-Platform-ApplicationDevelopment-with-.NET-MAUI

Исходный код этой книги можно загрузить тремя способами:

* Загрузите исходный код в сжатом файле.

Исходный код можно загрузить в разделе выпуска или использовать следующий URL-адрес:
https://github.com/PacktPublishing/.NET-MAUI-Cross-PlatformApplication-Development/releases/tag/V1.0.0
Тег выпуска может быть изменен, когда будет доступен новый выпуск.

* Клонировать исходный код одной главы.
Чтобы проверить исходный код главы, вы можете использовать следующую команду в качестве примера:
``$ git clone https://github.com/PacktPublishing/.NET-MAUICross-Platform-Application-Development.git -b Chapter02```

* Клонировать исходный код из основной ветки.
Чтобы проверить исходный код всех глав из основной ветки, вы можете использовать
следующая команда:

``$ git clone https://github.com/PacktPublishing/.NET-MAUICross-Platform-Application-Development.git```

# Настройка нового проекта .NET MAUI

Мы можем создать новый проект .NET MAUI с помощью Visual Studio или командной строки.

# Создание нового проекта с помощью Visual Studio

Чтобы создать новый проект .NET MAUI, выполните следующие действия:

1. Запустите Visual Studio 2022 и выберите Создать новый проект на экране запуска. Это будет
откройте мастер создания нового проекта.
В верхней средней части экрана есть окно поиска. Можем набрать в поиске Мауи
и будут показаны шаблоны проектов, связанных с .NET MAUI (см. рис. 2.2):

![изображение](https://user-images.githubusercontent.com/26972859/231735973-12c9a704-3dd1-451e-9987-5de35931ec9d.png)
Рисунок 2.2: Настройка нового проекта – создание нового проекта

Существует три шаблона для приложения или библиотеки .NET MAUI:
* Приложение .NET MAUI — это приложение .NET MAUI на основе XAML.
* Приложение .NET MAUI Blazor — этот шаблон можно использовать для создания приложения .NET MAUI Blazor.
* Библиотека классов .NET MAUI — это вариант создания библиотеки классов .NET MAUI. Мы можем
создавать общие компоненты как библиотеку классов .NET MAUI, когда мы разрабатываем приложение .NET MAUI.

2. Выбираем приложение .NET MAUI и нажимаем кнопку «Далее»; переходит к следующему шагу настройки
ваш новый проект, как показано на рисунке 2.3:

![изображение](https://user-images.githubusercontent.com/26972859/231736227-91d9f7c2-2cdb-4391-837d-423dbec12fa5.png)
Рисунок 2.3: Настройка нового проекта — настройка нового проекта

3. Введите имя проекта и имя решения как PassXYZ.Vault и нажмите кнопку Далее. После
проект создан, структура проекта будет выглядеть, как на рис. 2.4, где показано следующее:
* Общие файлы — в новом проекте в шаблон включены три файла — App.xaml,
MainPage.xaml и MauiProgram.cs. Это группа файлов, с которыми мы будем работать
на протяжении всей книги. Они не зависят от платформы. И бизнес-логика, и пользовательский интерфейс могут быть
разработан здесь и доступен на всех платформах.
* Файлы для конкретных платформ — пять подпапок (Android, iOS, MacCatalyst, Windows,
и Tizen) в папке «Платформы». Поскольку мы не будем поддерживать Tizen, мы можем удалить его.
из нашего проекта.

- Ресурсы. Разнообразные ресурсы, начиная от изображений, шрифтов, заставок, стилей и необработанных данных.
активы находятся в папке Resources. Эти ресурсы можно использовать на всех поддерживаемых платформах.

![изображение](https://user-images.githubusercontent.com/26972859/231736451-eba6531b-f282-43db-9ca5-fce5ed025a9e.png)
Рисунок 2.4: Структура проекта .NET MAUI

В проекте .NET MAUI существует только одна структура проекта. Далее мы увидим, что развитие
Xamarin.Forms включает в себя несколько проектов.

# Создание нового проекта с помощью команды dotnet

Несмотря на то, что мы установили .NET MAUI как часть установки Visual Studio, .NET MAUI можно
устанавливается отдельно с помощью командной строки. Таким образом, мы можем выбрать другое развитие
инструменты, чем Visual Studio. Мы можем создать и собрать приложение .NET MAUI с помощью команды dotnet.
линия. Чтобы узнать об установленных шаблонах проекта, мы можем использовать следующую команду:

```C:\ > dotnet новый --list```

Чтобы создать новый проект с помощью командной строки, мы можем выполнить следующую команду:

```C:\ > dotnet new maui -n "PassXYZ.Vault"```

Создан новый проект .NET MAUI, и теперь мы можем его собрать и протестировать. Прежде чем мы перейдем к
что, давайте потратим некоторое время на то, чтобы взглянуть на код запуска и жизненный цикл приложения .NET MAUI.

# Запуск и жизненный цикл приложения

В проекте .NET MAUI запуск приложения и управление жизненным циклом обрабатываются следующим образом.
два файла:

- MauiProgram.cs
- App.xaml/App.xaml.cs

Для запуска и настройки приложения используется .NET Generic Host. Когда приложение запускается, появляется
Объект .NET Generic Host создается для инкапсуляции ресурсов приложения и функциональности жизненного цикла, например
в дальнейшем:

- Внедрение зависимостей (DI)

- Ведение журнала

- Конфигурация

- Закрытие приложения

Это позволяет инициализировать приложения в одном месте и дает возможность настраивать шрифты,
службы и сторонние библиотеки.

---
NET универсальный хост
Если вы являетесь разработчиком Xamarin, возможно, вы не знакомы с .NET Generic Host. В ASP.NET
Core, .NET Generic Host используется для инкапсуляции ресурсов в приложении. В .NET MAUI
тот же шаблон заимствован и используется для управления запуском и конфигурацией.
---

Давайте рассмотрим код запуска приложения в листинге 2.1 (MauiProgram.cs):

** Листинг 2.1: MauiProgram.cs (https://epa.ms/MauiProgram2-1)**

```Csharp
пространство имен PassXYZ.Vault;
общедоступный статический класс MauiProgram
{
 публичный статический MauiApp CreateMauiApp() ➊
 {
 var builder = MauiApp.CreateBuilder(); ➋
 строитель
 .UseMauiApp<приложение>() ❹
 .ConfigureFonts (шрифты =>
 {
 шрифты.AddFont("OpenSans-Regular.ttf",
 "ОпенСансРегуляр");
 });
 вернуть строитель.Build(); ➌
 }
}
```
В листинге 2.1 мы видим следующее:

➊ На каждой платформе точка входа находится в коде, специфичном для платформы. Точка входа вызывает
Функция CreateMauiApp, являющаяся методом статического класса MauiProgram.

➋ Внутри CreateMauiApp он вызывает функцию CreateBuilder, которая является методом
статический класс MauiApp и возвращает экземпляр MauiAppBuilder, который предоставляет .NET Generic
Интерфейс хоста.

➌ Возвращаемое значение CreateMauiApp — это экземпляр MauiApp, который является точкой входа вашего приложения.

❹ Класс App, указанный в методе UseMauiApp, является корневым объектом нашего приложения. Давайте
просмотрите определение класса App в листинге 2.2:

**Листинг 2.2: App.xaml.cs (https://epa.ms/App2-2)**

```Csharp
пространство имен PassXYZ.Vault;
Приложение общедоступного частичного класса: Приложение ①
{
общедоступное приложение ()
{
 ИнициализироватьКомпонент();
 Главная страница = новый AppShell(); ②
}
}
```
В листинге 2.2 ① класс приложения является производным от класса приложения, а класс приложения
класс определен в пространстве имен Microsoft.Maui.Controls.
② AppShell является экземпляром Shell и определяет пользовательский интерфейс начальной страницы приложения. Приложение
создает экземпляр класса Window, в котором приложение будет работать, а представления будут
отображается. В классе App мы можем перезаписать метод CreateWindow для управления жизненным циклом,
что мы скоро увидим.

# Управление жизненным циклом

В приложении .NET MAUI есть следующие четыре состояния жизненного цикла:

* Бег

* Не бегать

* Деактивировано

* Остановлено

Во время переходов между состояниями будут запускаться предопределенные события жизненного цикла. Как видно из таблицы 2.1, определены шесть событий кроссплатформенного жизненного цикла:

|Событие|Описание|Переход состояния|Метод переопределения|
|:----|:----------|:---------------|:--------------|
|Created|Это событие вызывается после того, как собственное окно было создано.|Не запущено -> Выполняется|OnCreated|
|Активировано|Это событие возникает, когда окно было активировано и является или станет окном в фокусе.|Не работает -> |Работает|При активации|
|Deactivated|Это событие возникает, когда окно больше не находится в фокусе. Однако окно может оставаться видимым.|Выполняется -> Деактивировано|ПриДеактивировано|
|Остановлено|Это событие возникает, когда окно больше не видно.|Деактивировано -> Остановлено|При остановке|
|Resumed|Это событие возникает, когда приложение возобновляет работу после остановки.|Stopped -> Running|OnResumed|
|Destroying|Это событие возникает, когда родное окно уничтожается и освобождается.|Остановлено -> Не работает|OnDestroying|

Таблица 2.1: События жизненного цикла и методы переопределения

Эти события жизненного цикла связаны с экземпляром класса Window, созданным приложением.
Для каждого события определен соответствующий метод переопределения. Мы можем либо подписаться на
события жизненного цикла или создавать функции переопределения для управления жизненным циклом.

## Подписка на события жизненного цикла Windows

Чтобы подписаться на события жизненного цикла, как показано в листинге 2.3, в ➊ мы можем переопределить функцию CreateWindow.
в классе App для создания экземпляра Window, на который мы можем подписываться на события:

**Листинг 2.3: App.xaml.cs с событиями жизненного цикла (https://epa.ms/App2-3)**

```Csharp
с помощью System.Diagnostics;
пространство имен PassXYZ.Vault;
общедоступное частичное приложение класса: приложение {
 общественное приложение () {
 ИнициализироватьКомпонент();
 Главная страница = новая главная страница();
 }
 защищенное переопределение окна CreateWindow(IActivationState
 состояние активации) ➊
 {
 Окно окна = base.CreateWindow (состояние активации);
 window.Created += (s, e) => {
 Debug.WriteLine("PassXYZ.Vault.App: 1. Создано событие");
 };
 window.Activated += (s, e) => {
 Debug.WriteLine("PassXYZ.Vault.App: 2. Активированное событие");
 };
 window.Deactivated += (s, e) => {
 Debug.WriteLine("PassXYZ.Vault.App: 3. Деактивировано
 событие");
 };
 window.Stopped += (s, e) => {
 Debug.WriteLine("PassXYZ.Vault.App: 4. Событие остановлено");
 };
 window.Resumed += (s, e) => {
 Debug.WriteLine("PassXYZ.Vault.App: 5. Возобновлено событие");
 };
 window.Destroying += (s, e) => {
 Debug.WriteLine("PassXYZ.Vault.App: 6. Уничтожение
 событие");
 };
 возвратное окно;
 }
}
```
В листинге 2.3 мы изменили код App.xaml.cs и подписались на все шесть событий, чтобы
можно запустить тест и наблюдать за состоянием в окне вывода Visual Studio, как показано ниже. После того как мы
запустив наше приложение, мы видим, что события Created и Activated запускаются. Затем мы сворачиваем наше приложение. Мы видим, что запускаются события Deactivated и Stopped. Когда мы возобновим наше приложение,
События Resumed и Activated запускаются. Наконец, мы закрываем наше приложение, и событие Destroying
уволен:

```
PassXYZ.Vault.App: 1. Создано событие
PassXYZ.Vault.App: 2. Активированное событие
PassXYZ.Vault.App: 4. Остановлено событие
PassXYZ.Vault.App: 3. Деактивированное событие
PassXYZ.Vault.App: 5. Возобновлено мероприятие
PassXYZ.Vault.App: 2. Активированное событие
PassXYZ.Vault.App: 5. Возобновлено мероприятие
PassXYZ.Vault.App: 2. Активированное событие
Поток 0x6f94 завершился с кодом 0 (0x0).
PassXYZ.Vault.App: 6. Разрушающее событие
Программа «[30628] PassXYZ.Vault.exe» завершилась с кодом 0
(0x0).

```
# Использование методов переопределения жизненного цикла

В качестве альтернативы мы можем использовать методы переопределения жизненного цикла. Мы можем создать свой собственный производный класс
из класса окна:
1. В Visual Studio щелкните правой кнопкой мыши узел проекта и выберите «Добавить», а затем «Новый элемент…».
2. В окне «Добавить новый элемент» выберите класс C# из шаблона и назовите его PxWindow. Мы
создал новый класс, как показано в листинге 2.4:

**Листинг 2.4: PxWindow.cs (https://epa.ms/PxWindow2-4)**

```Csharp
с помощью System.Diagnostics;
пространство имен PassXYZ.Vault;
открытый класс PxWindow: окно
{
 публичный PxWindow() : base() {}
 общедоступный PxWindow (страница страницы): база (страница) {}
 защищенное переопределение void OnCreated() {
 Debug.WriteLine("PassXYZ.Vault.App: 1. При Создании");
 }
 защищенное переопределение void OnActivated() {
 Debug.WriteLine("PassXYZ.Vault.App: 2. OnActivated");
 }
 защищенное переопределение void OnDeactivated() {
 Debug.WriteLine("PassXYZ.Vault.App: 3. OnDeactivated");
 }
 защищенное переопределение void OnStopped() {
 Debug.WriteLine("PassXYZ.Vault.App: 4. OnStopped");
 }
 защищенное переопределение void OnResumed() {
 Debug.WriteLine("PassXYZ.Vault.App: 5. OnResumed");
 }
 защищенное переопределение void OnDestroying() {
 Debug.WriteLine("PassXYZ.Vault.App: 6. При уничтожении");
 }
}
```
В листинге 2.4 мы создали новый класс PxWindow. В этом классе мы определяем переопределение нашего жизненного цикла
методы. Мы можем использовать этот новый класс в App.xaml.cs.
Далее давайте посмотрим на модифицированную версию App.xaml.cs (листинг 2.5):

** Листинг 2.5. Модифицированный App.xaml.cs с помощью PxWindow (https://epa.ms/App2-5) **

```Csharp
пространство имен PassXYZ.Vault;
общедоступное частичное приложение класса: приложение
{
общедоступное приложение ()
{
 ИнициализироватьКомпонент();
}
защищенное переопределение окна CreateWindow(IActivationState
 состояние активации) ➊
 {
 вернуть новый PxWindow (новый MainPage());
 }
}
```
Когда мы повторяем шаги теста, мы видим следующий вывод из окон вывода Visual Studio.
Вывод очень похож на предыдущий. По сути, оба подхода оказывают одинаковое влияние на
управление жизненным циклом:

```
PassXYZ.Vault.App: 1. При создании
PassXYZ.Vault.App: 2. При активации
PassXYZ.Vault.App: 4. При остановке
PassXYZ.Vault.App: 3. OnDeactivated
PassXYZ.Vault.App: 5. OnResumed
PassXYZ.Vault.App: 2. При активации
PassXYZ.Vault.App: 5. OnResumed
PassXYZ.Vault.App: 2. При активации
PassXYZ.Vault.App: 6. При уничтожении
Программа «[25996] PassXYZ.Vault.exe» завершилась с кодом 0
(0x0).
```

Мы узнали об управлении жизненным циклом приложений в .NET MAUI через класс Window. Мы можем
либо подпишитесь на события жизненного цикла, либо переопределите переопределяемые методы для управления жизненным циклом приложения.
В таблице 2.1 показано сравнение этих двух подходов.
Если вы были разработчиком Xamarin.Forms, вы могли знать, что существуют определенные методы жизненного цикла
в классе Application. В .NET MAUI по-прежнему доступны следующие виртуальные методы:

* OnStart — вызывается при запуске приложения

* OnSleep — вызывается каждый раз, когда приложение переходит в фоновый режим.

* OnResume — вызывается при возобновлении работы приложения после перевода в фоновый режим.

Чтобы наблюдать за поведением этих методов, мы можем переопределить следующие методы в нашем классе App:
как показано в листинге 2.6:

**Листинг 2.6: App.xaml.cs (https://epa.ms/App2-6)**

```Csharp
с помощью System.Diagnostics;
пространство имен PassXYZ.Vault;
общедоступное частичное приложение класса: приложение
{
общедоступное приложение ()
{
ИнициализироватьКомпонент();
 Главная страница = новая главная страница();
}
защищенное переопределение void OnStart() { ➊
 Debug.WriteLine("PassXYZ.Vault.App: OnStart");
}
защищенное переопределение void OnSleep() { ➋
 Debug.WriteLine("PassXYZ.Vault.App: OnSleep");
}
защищенное переопределение void OnResume() { ➌
 Debug.WriteLine("PassXYZ.Vault.App: OnResume");
}
}
```
Когда мы тестируем предыдущий код в Windows, мы видим следующее отладочное сообщение в Visual
Окно выходных данных студии:

```
PassXYZ.Vault.App: OnStart
PassXYZ.Vault.App: OnSleep
Поток 0x6844 завершился с кодом 0 (0x0).
Поток 0x6828 завершился с кодом 0 (0x0).
Поток 0x683c завершился с кодом 0 (0x0).
PassXYZ.Vault.App: OnResume
```
Как видно из листинга 2.6,
➊ Когда приложение запускается, мы видим, что вызывается метод OnStart.
➋ Когда мы сворачиваем наше приложение, мы видим, что вызывается метод OnSleep.
➌ Когда мы возобновляем работу приложения с панели задач, вызывается метод OnResume.
Мы узнали о состояниях жизненного цикла приложения .NET MAUI. Мы также узнали, что можем
подпишитесь на события жизненного цикла или используйте методы переопределения для управления жизненным циклом. Далее давайте изучим
конфигурация ресурсов во время запуска приложения.

# Настройка ресурсов

Управление ресурсами — одно из основных различий между .NET MAUI и Xamarin.
Когда дело доходит до кроссплатформенной разработки, каждая платформа имеет свой собственный способ управления ресурсами.
и это сложная задача для команды разработчиков — знать и управлять всеми этими вещами. Например,
мы должны включать изображения разных размеров для поддержки разных разрешений.
В Xamarin большинство ресурсов управляются отдельно в проектах для конкретных платформ. Если мы хотим
чтобы добавить изображение, мы должны добавить файлы изображений разных размеров во все проекты платформы отдельно.
.NET MAUI предоставляет элегантное решение для эффективного управления ресурсами. Цель дизайна одного сингла
project для всех поддерживаемых платформ помогает управлять ресурсами в одном месте.
В .NET MAUI файлы ресурсов можно пометить по разным категориям, используя действие сборки на основе
какую роль они играют в проекте, как видно из таблицы 2.2:

|Тип ресурса|Действие сборки|Пример|
|:------------|:-----------|:----- |
|Изображения|MauiImage|dotnet_bot.svg|
|Иконки |MauiIcon|appicon.svg|
|Изображение экрана-заставки|MauiSplashScreen|appicifg.svg|
|Шрифты|MauiFont|OpenSans-Regular.ttf|
|Определение стиля с помощью внешнего CSS|MauiCss||
|Необработанные активы|MauiAsset||
|Определение пользовательского интерфейса XAML|MauiXaml||

Таблица 2.2: Типы ресурсов .NET MAUI

После добавления файла ресурсов действие сборки можно задать в окне «Свойства» в Visual Studio.
Если мы посмотрим на файл проекта, то увидим следующую ItemGroup. Если мы расположим ресурсы в соответствии с
соглашение о настройке папки по умолчанию, ресурсы будут рассматриваться как соответствующая категория и
действие сборки будет установлено автоматически:

```xml
<группа элементов>
 <!-- Значок приложения -->
 <MauiIcon Include="Ресурсы\AppIcon\appicon.svg"
 ForegroundFile="Ресурсы\AppIcon\appiconfg.svg"
Цвет="#512BD4" />
 <!—Заставка 
 <MauiSplashScreen Include= "Resources\Splash\splash.svg" Color="#512BD4" BaseSize="128,128" />
 <!-- Изображения -->
 <MauiImage Include="Ресурсы\Изображения\*" />
 <!-- Пользовательские шрифты -->
 <MauiFont Include="Ресурсы\Шрифты\*" />
</ItemGroup>
```

# Значок приложения

В нашей настройке приложения у нас есть файл изображения SVG, appicon.svg, в папке Resources\AppIcon.
папку с действием сборки, установленным на MauiIcon. Во время сборки этот файл используется для создания значка.
изображения на целевой платформе для различных целей, например, на устройстве или в магазине приложений.
Этот файл SVG можно переместить вместе с другими изображениями в папку Resources\Images.
В этом случае мы должны использовать следующую запись в файле проекта:

```xml
<MauiIcon Include="Ресурсы\Изображения\appicon.png"
ForegroundFile="Ресурсы\Изображения\appicconfg.svg" Цвет="#512BD4"
/>
```
Однако в этом случае действие сборки несовместимо с файлами в одной и той же папке, поэтому appicon.
svg находится в папке Resources\AppIcon вместо Resources\Images в нашем проекте.

# Заставка

Это как значок приложения. У нас есть файл изображения SVG, splash.svg, в папке Resources/Splash.
папка с действием сборки, установленным на MauiSplashScreen:

```xml
<MauiSplashScreen Include="Ресурсы\Всплеск\всплеск.svg"
Цвет="#512BD4" />
```
Значки приложений, экраны-заставки и другие изображения — это простые ресурсы, и мы настраиваем их в
файл проекта напрямую.
Некоторые часто используемые ресурсы, такие как пользовательский шрифт и DI, возможно, придется настроить в коде или
как код, так и файлы проекта. Мы обсудим пользовательские шрифты здесь и оставим DI в w, Dependency Injection
и усовершенствование дизайна.

# Установка пользовательских значков шрифтов

Пользовательскими шрифтами можно управлять как частью ресурсов. В мобильном приложении визуальное представление обычно
передается через изображения. Мы используем изображения во всех видах навигации. В Android и iOS
при разработке нам необходимо управлять ресурсами изображения для разных разрешений экрана. В обоих приложениях Xamarin.
Forms и .NET MAUI мы можем использовать собственный шрифт (шрифт значка) вместо изображений для значков приложений.
В .NET MAUI, если элементы управления могут отображать текст, эти элементы управления обычно определяют свойства, которые мы можем использовать.
настроить параметры шрифта для текста. Настраиваются следующие свойства:

* FontAttributes — перечисление с тремя элементами: None, Bold и Italic.
Значение по умолчанию для этого свойства — None.

* FontSize, который является свойством размера шрифта, а тип — double.

* FontFamily, которое является свойством семейства шрифтов и имеет строковый тип.

# В чем преимущество использования пользовательских шрифтов для значков?

Есть много преимуществ в использовании пользовательских шрифтов в качестве значков вместо изображений.
Значки шрифтов — это векторные значки, а не растровые значки. Векторные иконки масштабируются, то есть вам не нужно
разные изображения с разными размерами и разным разрешением в зависимости от устройства. Масштабирование шрифта значков
можно обрабатывать через свойство FontSize. Размер файла шрифта также намного меньше, чем
изображений. Размер файла шрифта с сотнями значков может составлять всего несколько КБ.
Помимо размера шрифта, цвет значка можно изменить с помощью свойства TextColor. Статичными изображениями,
мы не можем изменить цвет значка.
Наконец, файлами шрифтов можно управлять в общем проекте, поэтому нам не нужно управлять шрифтами отдельно.
на разных платформах.

# Настройка пользовательского шрифта

Настройка пользовательского шрифта состоит из двух частей — файлов шрифтов и конфигурации.

Пользовательские файлы шрифтов можно добавить в общий проект .NET MAUI или Xamarin.Forms. Конфигурация
пользовательских шрифтов в .NET MAUI отличается от Xamarin.Forms. В Xamarin.Forms мы должны настроить
это в AssemblyInfo.cs, в то время как мы можем управлять конфигурацией через .NET Generic Host в
.NET ИСПРАВЛЕНО.

В Xamarin.Forms процесс для этого выглядит следующим образом:

1. Добавьте файл шрифта в общий проект Xamarin.Forms в качестве внедренного ресурса (сборка
действие: EmbeddedResource).
2. Зарегистрируйте файл шрифта со сборкой в ​​файле, таком как AssemblyInfo.cs, с помощью
Атрибут ExportFont. Также можно указать необязательный псевдоним.

В .NET MAUI процесс изменен и упрощен следующим образом:
1. Добавьте файлы шрифтов в папку Resources->Fonts. Действие сборки установлено на MauiFont,
как мы можем видеть на рисунке 2.5:

![изображение](https://user-images.githubusercontent.com/26972859/231742991-158f48fa-f515-4329-9c98-8168c4233825.png)
Рисунок 2.5: Ресурсы .NET MAUI

Вместо регистрации файла шрифта в сборке .NET MAUI инициализирует большую часть ресурсов.
через .NET Generic Host в коде запуска, как показано в следующем листинге 2.7 в ➊.
Файлы шрифтов добавляются с помощью метода ConfigureFonts(), который является методом расширения.
класса MauiAppBuilder.

В нашем проекте мы используем библиотеку иконок Font Awesome из следующего проекта с открытым исходным кодом:
https://github.com/FortAwesome/Font-Awesome
Файлы шрифтов fa-brands-400.ttf, fa-regular-400.ttf и fa-solid-900.ttf могут
можно загрузить с предыдущего веб-сайта.
Давайте просмотрим листинг 2.7 с исходным кодом и посмотрим, как добавить эти шрифты в конфигурацию приложения.

** Листинг 2.7: MauiProgram.cs (https://epa.ms/MauiProgram2-7)**

```Csharp
пространство имен PassXYZ.Vault;
общедоступный статический класс MauiProgram
{
 публичный статический MauiApp CreateMauiApp()
  {
 var builder = MauiApp.CreateBuilder();
 строитель
 .UseMauiApp<приложение>()
 .ConfigureFonts(шрифты => ➊
 {
 fonts.AddFont("fa-regular-400.ttf",
 "ШрифтAwesomeRegular");
 fonts.AddFont("fa-solid-900.ttf", "FontAwesomeSolid");
 fonts.AddFont("fa-brands-400.ttf",
 "FontAwesomeBrands");
 шрифты.AddFont("OpenSans-Regular.ttf",
 "ОпенСансРегуляр");
 });
 вернуть строитель.Build();
 }
}
```
В приведенном выше коде мы можем добавить шрифты, вызвав метод ConfigureFonts ➊ в
Объект MauiAppBuilder. Чтобы передать аргументы в ConfigureFonts, мы вызываем метод AddFont.
чтобы добавить шрифт в объект IFontCollection.

# Отображение значков шрифтов

Чтобы отобразить значки шрифтов в приложениях .NET MAUI, мы можем указать данные значка шрифта в
Объект FontImageSource. Этот класс, производный от класса ImageSource, имеет
следующие свойства, как показано в таблице 2.3:

|Имя свойства|Тип|Описание|
|:------------|:---|:----------|
|Glyph|string|Значение символа Unicode, например ""|
|Size|double|Размер шрифта в аппаратно-независимых единицах измерения|
|FontFamily|string|Строка, представляющая семейство шрифтов, например FontAwesomeRegular|
|Цвет|Цвет|Цвет значка шрифта в Microsoft.Maui.Graphics.Color|

Таблица 2.3: Свойства FontImageSource

В следующем примере XAML один значок шрифта отображается в представлении изображения:

```xml
<Цвет фона изображения="#D1D1D1">
 <Изображение.Источник>
 <FontImageSource Glyph=""
 FontFamily="FontAwesomeRegular"
Размер = "32" />
 </Изображение.Источник>
</изображение>
```
Если вы не знакомы с синтаксисом XAML из предыдущего примера, не беспокойтесь. Мы узнаем
об этом в следующей главе. В предыдущем коде значок пользователя отображается в элементе управления Image,
из семейства шрифтов FontAwesomeRegular, которое мы только что добавили в конфигурацию. 
Глиф значка пользователя имеет \uf007 шестнадцатеричный формат, и это экранированный формат C#. Чтобы использовать его в
XML, мы должны использовать экранированный формат XML, то есть .

Эквивалентный код C# выглядит следующим образом:

```Csharp
Изображение изображение = новое изображение {
 BackgroundColor = Color.FromHex("#D1D1D1")
};
image.Source = новый FontImageSource {
 Глиф = "\ uf007",
 FontFamily = "FontAwesomeRegular",
 Размер = 32
};
```
В предыдущем примере мы обращаемся к значку шрифта, используя Glyph в шестнадцатеричном числе как строку. Это
не удобно использовать практически. Мы можем определить глифы шрифта как строковые константы C#, чтобы мы могли
обратиться к чему-то более значимому. Есть много способов сделать это. Здесь мы используем открытый исходный код
инструмент IconFont2Code для генерации строковых констант. IconFont2Code можно найти по следующему адресу
URL-адрес в GitHub:

https://github.com/andreinitescu/IconFont2Code

Мы используем Font Awesome в нашем проекте. На сайте IconFont2Code мы можем загрузить наш шрифт
из папки Resources\Fonts, а IconFont2Code сгенерирует для нас код, как
в следующем примере:

```Csharp
пространство имен PassXYZ.Vault.Resources.Styles;
статический класс FontAwesomeRegular
{
 общедоступная константная строка Heart = "\ uf004";
 общедоступная константная строка Star = "\ uf005";
 общедоступная константная строка Scan = "\uf006";
 общедоступная константная строка User = "\uf007";
 общедоступная константная строка Qrcode = "\uf008";
 public const string Fingerprint = "\uf009";
 общедоступная константная строка Clock = "\uf017";
 общедоступная константная строка ListAlt = "\uf022";
 public const string Flag = "\uf024";
 общедоступная константная строка Bookmark = "\uf02e";
 ...
общедоступная константная строка SmileBeam = "\uf5b8";
public const string Surprise = "\uf5c2";
public const string Устал = "\uf5c8";
}
```
Мы можем сохранить сгенерированные файлы C# в папке Resources\Styles. Предыдущий файл может быть
нашел здесь:

```Ресурсы\Стили\FontAwesomeRegular.cs```

С предыдущим статическим классом FontAwesomeRegular значок шрифта можно использовать так же, как обычный
текст в файле XAML:

```xml
<Кнопка
 Текст = "Нажми меня"
 Атрибуты Шрифта = "Полужирный"
 Сетка.Строка="3"
 SemanticProperties.Hint="Подсчитывает, сколько раз вы
 нажмите "
 Щелкнул = "По счетчику кликов"
 HorizontalOptions="Центр">
 <Кнопка.ImageSource>
 <FontImageSource FontFamily="FontAwesomeSolid"
 Glyph="{x:Статическое приложение:FontAwesomeSolid.
 Плюскруг}"
 Color="{Вторичный цвет динамического ресурса}"
 Размер = "16" />
 </Кнопка.ImageSource>
</кнопка>
```
В предыдущем коде мы добавили значок кружка плюс к элементу управления «Кнопка» перед текстом «Нажмите
me". Чтобы сослаться на имя значка в сгенерированном классе C#, мы добавили пространство имен приложения, как определено здесь:

```xmlns:app="clr-namespace:PassXYZ.Vault.Resources.Styles"````

На данный момент мы создали наш проект и настроили необходимые нам ресурсы. Время для
построить и протестировать наше приложение.

# Сборка и отладка

Как мы помним в главе 1 «Начало работы с .NET MAUI», в отношении среды разработки
setup, мы не можем построить и протестировать все цели, используя одну платформу. Пожалуйста, обратитесь к Таблице 1.8 о
доступные цели сборки на платформах Windows и macOS. Для простоты мы построим и протестируем
Windows и Android на платформе Windows. Для сборок iOS и macOS мы сделаем это на
платформа макОС.
Как только мы будем готовы, мы можем построить и отладить наше приложение.
Сначала создадим и протестируем на платформе Windows. Мы можем выбрать фреймворк, который мы хотим запустить
или отладить, как показано на рис. 2.6:

![изображение](https://user-images.githubusercontent.com/26972859/231744837-e1768581-19d8-4221-9066-df85791f85e0.png)
Рисунок 2.6: Сборка и отладка

# Окна

Мы можем запускать или отлаживать сборку Windows на локальном компьютере, выбрав net6.0-windows10.0.19041.
как каркас. Для этого мы должны включить режим разработчика в Windows, если он еще не включен.
Пожалуйста, обратитесь к рисунку 2.7, чтобы включить режим разработчика в Windows 10 или 11:
1. Откройте меню «Пуск».
2. Найдите настройки разработчика и выберите его.
3. Включите режим разработчика.
4. Если вы получили предупреждающее сообщение о режиме разработчика, прочтите его и выберите Да.

![изображение](https://user-images.githubusercontent.com/26972859/231745011-414b8ffb-6b51-4f64-9d10-2d6b44b25bbb.png)
Рисунок 2.7: Режим разработчика

# Андроид

Для сборки Android мы можем протестировать ее с помощью эмулятора или устройства Android. Перед сборкой или отладкой
нам нужно подключить устройство или настроить экземпляр эмулятора. Пожалуйста, обратитесь к следующему Microsoft
документация о том, как настроить устройство или экземпляр эмулятора:
https://learn.microsoft.com/en-us/dotnet/maui/
Мы можем запускать или отлаживать из Visual Studio (рис. 2.6), выбрав net6.0-android в качестве фреймворка.
Кроме того, мы также можем выполнить сборку и запуск из командной строки, используя следующую команду:

``сборка dotnet -t:Выполнить -f net6.0-android```

![изображение](https://user-images.githubusercontent.com/26972859/231745362-0caad7fe-5bdc-44d5-8d5c-72a88a600a70.png)
Рисунок 2.8: Запуск на Android и Windows

После того, как мы запустим приложение на устройствах Android и Windows, мы увидим предыдущий экран (рис. 2.8).

# iOS и macOS

Мы можем создавать и тестировать цели iOS и macOS на компьютере Mac. Шаги по сборке и тестированию с использованием
Microsoft Visual 2022 для Mac похож на то, что мы сделали в Windows и Android. Давайте посмотрим
как это сделать с помощью командной строки.
Чтобы построить и протестировать цель iOS, мы можем использовать следующую команду в папке проекта:

``dotnet build -t:Run -f net6.0-ios -p:_DeviceName=:v2:udid=02C556DA-64B8-440B-8F06-F8C56BB7CC22``

Чтобы выбрать целевой эмулятор iOS, нам нужно указать идентификатор устройства, используя следующий параметр:

```-p:_DeviceName=:v2:udid=```

Чтобы найти идентификатор устройства, мы можем запустить Xcode на компьютере Mac и перейти в Windows -> Устройства и
Симуляторы, как показано на рисунке 2.9:

![изображение](https://user-images.githubusercontent.com/26972859/231745717-5a67c7dc-7790-48c8-a874-167d0743c1ef.png)
Рисунок 2.9: Устройства и симуляторы в Xcode

Для цели macOS мы можем использовать следующую команду для сборки и тестирования:

``сборка dotnet -t:Выполнить -f net6.0-maccatalyst```

Скриншот для iOS и macOS показан на рис. 2.10, и мы видим, что внешний вид
аналогично Android и Windows.

![изображение](https://user-images.githubusercontent.com/26972859/231745910-85ddfa94-8518-46d8-a2bf-e3ae9de4b81b.png)

Рисунок 2.10: Запуск на iOS и macOS

Настройка среды для Android, iOS и macOS включает детали, зависящие от платформы. Пожалуйста, обратитесь
в документации Microsoft для получения подробных инструкций.
Несмотря на то, что это приложение работает хорошо, вы можете видеть, что приложение, которое мы только что создали, является простым и имеет только один
окно. Чтобы заложить лучшую основу для нашей последующей разработки, мы будем использовать Shell в качестве навигационного
рамки. В Xamarin.Forms есть хороший шаблон на основе оболочки, и мы можем использовать его для создания
исходный код нашего приложения.

# Создание шаблона проекта Model-View-ViewModel

Теперь мы можем успешно запустить только что созданное приложение. Мы собираемся разработать менеджер паролей
приложение с именем PassXYZ.Vault в остальной части этой книги. Версия 1.xx этого приложения реализована в Xamarin.
Forms, и вы можете найти его на GitHub здесь:
https://github.com/passxyz/Vault
Версия 1.xx создана с использованием Xamarin.Forms 5.0.0. Мы воссоздадим его с помощью .NET MAUI и поделимся
опыт в этой книге. Новый релиз будет версии 2.xx, а исходный код находится здесь:
https://github.com/passxyz/Vault2

Оболочка поддерживается Microsoft.Maui.Controls.Shell и Xamarin.Forms.Shell в
.NET MAUI и Xamarin.Forms. Он обеспечивает общий пользовательский опыт навигации, который можно использовать
на всех платформах. Подробнее о Shell мы расскажем в главе 5 «Введение в Shell и навигацию». Мы
будет использовать .NET MAUI Shell в качестве основы пользовательского интерфейса и метода навигации в этой книге.
В проектах, созданных на основе шаблона Visual Studio как .NET MAUI, так и Xamarin.Forms, используется
Оболочка. Однако шаблон проекта .NET MAUI по умолчанию содержит только самую простую форму оболочки, т.к.
мы можем видеть в листинге 2.8:

**Листинг 2.8: AppShell.xaml (https://epa.ms/AppShell2-8)**

```xml
<?xml версия="1.0" кодировка="UTF-8" ?>
<Оболочка
 x:Class="PassXYZ.Vault.AppShell"
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:local="clr-namespace:PassXYZ.Vault"
 Shell.FlyoutBehavior="Отключено">
 <ShellContent
 Заголовок = "Главная"
 ContentTemplate="{DataTemplate local:MainPage}"
 Маршрут = «Главная страница» />
</оболочка>
```
Если вы не знакомы с XAML в листинге 2.8, не беспокойтесь. Мы познакомимся с синтаксисом XAML в главе 3.
Дизайн пользовательского интерфейса с помощью XAML. Мы видим, что MainPage отображается в ShellContent. Это
самый простой пользовательский интерфейс без лишнего контента. В нашем приложении мы будем использовать Model-View-ViewModel.
(MVVM) шаблон и пользовательский интерфейс на основе Shell. Шаблон MVVM является широко используемым шаблоном проектирования пользовательского интерфейса.
в разработке приложений .NET MAUI. Нам нужно создать шаблонный код, чтобы включить как MVVM, так и
шаблон и структуру навигации Shell. Мы могли бы сделать это с нуля. Однако Xamarin.Forms
шаблон включает такие стандартные коды, которые я использовал в версии 1.xx PassXYZ.Vault. Мы можем создать
тот же шаблон проекта для .NET MAUI. Сделав это, мы также можем получить представление о том, как
переносите или повторно используйте существующий код из Xamarin.Forms.

# Миграция и повторное использование шаблона оболочки из Xamarin.Forms

Xamarin.Forms включает более сложный шаблон оболочки, который можно настроить для создания шаблона.
код всплывающей панели навигации или навигации с вкладками. Мы можем создать новый проект Xamarin.Forms, используя этот
шаблон. После этого мы можем использовать этот шаблонный код в только что созданном приложении .NET MAUI.
Чтобы создать новый проект Xamarin.Forms, выполните следующие действия.

1. Запустите Visual Studio 2022 и выберите Создать новый проект. Это открывает Создать новый проект
волшебник. В поле поиска мы можем ввести Xamarin и все шаблоны проектов, связанные с Xamarin.
будет показано (см. рис. 2.11):

![изображение](https://user-images.githubusercontent.com/26972859/231746399-15710564-19f8-43cb-a71e-a138a477ac28.png)

Рисунок 2.11: Новый проект Xamarin

2. Выберите Мобильное приложение (Xamarin.Forms) из списка и нажмите Далее. На следующем экране, как
показано на рисунке 2.12, мы должны выбрать другое местоположение, но использовать то же имя проекта,
PassXYZ.Vault и нажмите кнопку «Создать»:

![изображение](https://user-images.githubusercontent.com/26972859/231746490-037ab6d0-7ca5-4b29-8c54-4f52615e738e.png)

Рисунок 2.12: Настройка проекта Xamarin

3. У нас есть еще один шаг, как показано на рисунке 2.13. Выберем шаблон Flyout и нажмем Create:

![изображение](https://user-images.githubusercontent.com/26972859/231746597-a93d9c2b-681f-40f2-a2e0-673b524468b2.png)

Рисунок 2.13: Настройка проекта Xamarin — всплывающее окно

После создания нового решения мы видим, что в решении есть четыре проекта, как показано на
Рисунок 2.14:

* PassXYZ.Vault — это проект .NET Standard, который совместно используется другими проектами, и все
здесь должен быть независимый от платформы код

* PassXYZ.Vault.Android — это проект для платформы Android.

* PassXYZ.Vault.iOS — это проект для платформы iOS.

* PassXYZ.Vault.UWP — это проект, специфичный для UWP.

Мы видим, что структура проекта Xamarin.Forms сильно отличается от .NET MAUI. Есть
несколько проектов в решении. Все ресурсы управляются отдельно в проектах для конкретных платформ.
Большая часть разработки должна выполняться в проекте .NET Standard, PassXYZ.Vault, и мы
будет переносить и повторно использовать код в этом проекте.

![изображение](https://user-images.githubusercontent.com/26972859/231746771-11edb7c5-344a-4a75-9e2c-59e6f299144b.png)

Рисунок 2.14: Структура проекта Xamarin.Forms

Исходный код этого проекта Xamarin.Forms можно найти здесь:
https://github.com/shugaoye/PassXYZ.Vault2/tree/xamarin

Если код для конкретной платформы не задействован, процесс миграции относительно прост. Мы занимаемся
тут простейший случай. Рабочий код обычно намного сложнее, чем этот, поэтому любая миграция
следует планировать после детального анализа.

Давайте сосредоточимся на проекте .NET Standard. Содержимое проекта .NET Standard включает
шаблонный код паттерна MVVM и Shell UI, что нам и нужно. Мы можем копировать файлы в
предыдущий список в проект .NET MAUI и изменить пространства имен в исходном коде.

Ниже приведены шаги, которые необходимо предпринять в процессе миграции:

1. См. Таблицу 2.4, в которой приведен список действий, соответствующих списку файлов и
папки в проекте .NET Standard:

|Xamarin.Forms|Действия|.NET MAUI|
|:------------|:------|:--------|
|App.xaml |Нет |Сохранить версию .NET MAUI. Он определяет экземпляр класса Application.|
|AppShell.xaml|Replace|Перезаписать версию .NET MAUI и изменить пространства имен на .NET MAUI. Этот файл определяет иерархию навигации Shell.|
|Views/|Copy|Новая папка в проекте .NET MAUI. Нужно изменить пространства имен.|
|ViewModels/|Копировать|Новая папка в проекте .NET MAUI. Нужно изменить пространства имен.|
|Сервисы/|Копировать|Интерфейс для экспорта моделей. Новая папка в проекте .NET MAUI. Нужно изменить пространства имен.|
|Модели/|Копировать|Новая папка в проекте .NET MAUI. Нужно изменить пространства имен.|

Таблица 2.4: Действия в стандартном проекте .NET

2. В проекте .NET MAUI см. Таблицу 2.4, чтобы заменить следующие пространства имен:

|Старое пространство имен|Новое пространство имен|
|:------------|:------------|
|xmlns="http://xamarin.com/schemas/2014/forms"|xmlns="http://schemas.microsoft.com/dotnet/2021/maui"|
|используя Xamarin.Forms|используя Microsoft.Maui И используя Microsoft.Maui.Controls|
|используя Xamarin.Forms.Xaml|используя Microsoft.Maui.Controls.Xaml|

Таблица 2.5. Пространства имен в .NET MAUI и Xamarin.Forms

3. Протестируйте и исправьте все ошибки.

На рис. 2.15 мы видим, что список измененных файлов — это представления и модели представлений:

![изображение](https://user-images.githubusercontent.com/26972859/231748161-e082af77-4069-4e26-a913-f86d60e149fa.png)

Рисунок 2.15: Измененные файлы при миграции (https://bit.ly/3NlfqvO)

В этом простом случае все изменения связаны с пространством имен. Это не так в реальных ситуациях.
Несмотря на то, что процесс выглядит простым, он все еще относительно сложен для новичков в .NET.
МАУИ. Я не рекомендую вам повторять это. Вместо этого я создал новый шаблон проекта Visual Studio.
чтобы включить желаемый результат.

Давайте создадим и протестируем это обновленное приложение.

![изображение](https://user-images.githubusercontent.com/26972859/231748309-fe99055a-8290-4c83-84c9-953131a2be56.png)

Рисунок 2.16: PassXYZ.Vault с оболочкой .NET MAUI

На рис. 2.16 мы видим, что в меню «Шелл» по умолчанию включены три страницы:

• О компании — это страница о компании.

• Обзор — это точка входа в список элементов.

• Выход — это ссылка на страницу входа, где вы можете войти или выйти из системы.

Мы будем использовать его в качестве шаблонного кода для дальнейшего развития в этой книге. Подведем итоги работы
что мы сделали в этом разделе, я создал для него шаблон проекта Visual Studio. Используя этот проект
шаблон, мы можем создать желаемую структуру проекта.

# Шаблон проекта Visual Studio

Шаблон проекта можно загрузить в виде пакета расширения Visual Studio с веб-сайта Visual Studio.
Торговая площадка, как показано на рисунке 2.17:

![изображение](https://user-images.githubusercontent.com/26972859/231748648-354aba08-f03e-4562-8a8a-4a8ad6060c80.png)

Рисунок 2.17: Шаблон проекта в Visual Studio Marketplace

После установки этого шаблона проекта мы можем создать новый проект .NET MAUI, как показано на рисунке 2.18:

![изображение](https://user-images.githubusercontent.com/26972859/231748829-4ffa1198-e32e-4f77-8b8d-e3d6810ab1cb.png)

Рисунок 2.18: Создание нового проекта .NET MAUI с использованием шаблона проекта

В проекте, созданном с использованием этого шаблона, структура проекта такая же, как и в этой главе.
Исходный код этого шаблона проекта можно найти здесь:
https://github.com/passxyz/MauiTemplate

# Краткое содержание

В этой главе мы создали новый проект .NET MAUI. Мы научились настраивать .NET MAUI
приложение с помощью .NET Generic Host, и мы можем использовать собственный шрифт (Font Awesome) после обновления
конфигурация ресурсов. Мы также узнали о жизненном цикле приложения .NET MAUI. Мы протестировали
как подписаться на события жизненного цикла, переопределив метод CreateWindow и создав
производный класс от класса Window. Чтобы создать шаблонный код с шаблоном MVVM и оболочкой
поддержку, мы создали новый шаблон проекта .NET MAUI. На протяжении всего процесса мы демонстрировали
как перенести код Xamarin.Forms в .NET MAUI.
В следующей главе мы узнаем, как создать пользовательский интерфейс с помощью XAML. XAML можно использовать для
создавать пользовательские интерфейсы для WPF, UWP, Xamarin.Forms и .NET MAUI. Мы будем создавать и улучшать
пользовательские интерфейсы нашего приложения диспетчера паролей с использованием XAML.










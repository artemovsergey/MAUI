# Изучение MVVM и привязки данных

В последней главе мы узнали, как создавать пользовательские интерфейсы (UI) с помощью XAML. В этой главе мы будем
узнать, как использовать шаблон Model-View-ViewModel (MVVM) и привязку данных в .NET MAUI
разработка приложения. MVVM — это шаблон проектирования пользовательского интерфейса для разделения кода пользовательского интерфейса и кода, не связанного с пользовательским интерфейсом. привязка данных
ключевая технология, на которую опирается MVVM. Мы улучшим дизайн нашего приложения, используя MVVM и
привязка данных. Мы также заменим модель данных, используя библиотеки с открытым исходным кодом.
В этой главе будут рассмотрены следующие темы:

* Понимание MVVM и MVC

* Привязка данных

* Улучшение модели данных и сервиса

# Технические требования

Для тестирования и отладки исходного кода в этой главе вам необходимо установить Visual Studio 2022 на
ваш ПК или Mac. Пожалуйста, обратитесь к разделу Настройка среды разработки в Главе 1, Получение
Начал с .NET MAUI, подробнее.
Исходный код этой главы доступен в следующей ветке GitHub:  https://github.
com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development/
tree/main/Chapter04.
Исходный код можно загрузить с помощью следующей команды Git:

```
git clone -b Chapter04 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development
```

# Понимание MVVM и MVC

При разработке программного обеспечения мы обычно следуем и повторно используем передовой опыт и шаблоны проектирования. Шаблон Model-ViewController (MVC) — это подход к разделению обязанностей системы. Это может помочь
разделить реализацию пользовательского интерфейса и бизнес-логики на разные части.

![изображение](https://user-images.githubusercontent.com/26972859/231772893-fc58dc30-81ae-467f-99bd-f0944ce39284.png)

Рисунок 4.1: Шаблон MVC

Шаблон MVC, как показано на рис. 4.1, делит обязанности системы на три отдельные части.
Модель хранит данные приложения и обрабатывает бизнес-логику. Классы моделей обычно могут быть реализованы
как обычные старые объекты CLR (POCO) или объекты передачи данных (DTO). POCO — это класс, который не
зависят от любых классов, специфичных для платформы, поэтому классы POCO можно использовать с LINQ или Entity Framework.
хорошо. DTO — это подмножество класса POCO, которое содержит только данные без логики или поведения. классы DTO
может использоваться для передачи данных между слоями. Модель не зависит от представления или контроллера.
поэтому его можно реализовать и протестировать отдельно.

Представление представляет информацию о модели пользователю и взаимодействует с пользователем.

Контроллер обновляет модель и представление в ответ на действия пользователя. Наше понимание
модель и представление не слишком сильно изменились с течением времени, но было разное понимание
и реализации контроллера с момента введения шаблона MVC.

Model-View-Presenter (MVP) — один из них. Позже Microsoft использовала MVVM и XAML в WPF,
который является разновидностью MVP. В Xamarin.Forms и .NET MAUI, XAML и шаблон MVVM
также используются.

![изображение](https://user-images.githubusercontent.com/26972859/231773077-96e94ea1-3cb7-4541-8e00-59d8d428b14a.png)

Рисунок 4.2: Шаблон MVVM

Как видно на рис. 4.2, в MVVM вместо контроллера используется модель представления. Различия
между MVVM и MVC следующие:
• Разделение представления и модели. Модель представления используется для обработки связи между
вид и модель. Представление получает доступ к данным и логике в модели через модель представления.
• Привязка данных между представлением и моделью представления. Используя привязку данных, изменения в представлении или
viewmodel может автоматически обновляться в другом. Это может помочь уменьшить сложность
реализации.
• Как в MVC, так и в MVVM модель можно тестировать отдельно. В MVVM можно
модульные тесты дизайна для модели представления.
Когда представление изменяется, изменения будут отражаться в модели представления через привязку данных. Модель представления
будет обрабатывать изменения данных в модели. Точно так же, когда данные изменяются в модели, модель представления
получает уведомление об обновлении представления. Распространенным решением для уведомлений является установка обработчиков событий для
уведомить об изменениях. С привязкой данных реализация значительно упрощается


# MVVM в PassXYZ.Vault

В нашем приложении PassXYZ.Vault мы используем MVVM для обработки обмена данными между представлением и
модель просмотра. Как видно на рис. 4.3, у нас есть пять страниц содержимого XAML и столько же
определенных моделей просмотра. В нашей модели данных у нас есть класс Item, который является классом нашей модели, и он
можно получить через интерфейс IDataStore.

![изображение](https://user-images.githubusercontent.com/26972859/231773278-c1cb7d23-fe90-45b5-bccc-0da7f094286c.png)

Рисунок 4.3: MVVM в PassXYZ.Vault

Привязка данных используется как канал связи между представлениями и моделями представлений. Модель представления
обновит модель Item через интерфейс службы IDataStore. Мы научимся использовать данные
привязка в следующем разделе путем анализа страницы сведений об элементе и модели представления.

# Привязка данных

Давайте рассмотрим, как MVVM и привязка данных работают в нашем приложении. Мы можем проанализировать ItemDetailPage
и ItemDetailViewModel в начале нашего пути. Следующий список включает вид,
viewmodel и модель, которую мы собираемся исследовать:

* View – ItemDetailPage, см. листинг 3.4 в предыдущей главе.

* Viewmodel — ItemDetailViewModel, см. листинг 4.1.

* Model — Item (доступ через интерфейс IDataStore), см. листинг 3.3 в предыдущей главе
ItemDetailPage — это представление, используемое для отображения содержимого экземпляра Item. Этот экземпляр
хранится в модели представления. Элементы пользовательского интерфейса, представляющие содержимое Item, связаны с
экземпляр через привязку данных.

Привязка данных используется для связывания свойств целевых и исходных объектов. Вот список задействованных
свойства целевых и исходных объектов:

* Target — это задействованный элемент пользовательского интерфейса, и этот элемент пользовательского интерфейса должен быть дочерним элементом BindableObject. Элемент пользовательского интерфейса, используемый в ItemDetailPage, — это Label.

* Целевое свойство — это свойство целевого объекта. Это BindableProperty. Если целью является Label, как мы упоминали здесь, целевым свойством может быть свойство Text объекта Label.

* Источник — это исходный объект, на который ссылается привязка данных. Здесь это ItemDetailViewModel.

* Путь к значению исходного объекта — это путь к значению в исходном объекте. Здесь путь — это свойство модели представления, например Text или Description.

Давайте посмотрим на следующий код в ItemDetailPage:

```xml
<StackLayout Spacing="20" Padding="15">
 <Label Text="Name:" FontSize="Medium" />
 <Label Text="{Binding Name}" FontSize="Small"/> ❶
 <Label Text="Description:" FontSize="Medium" />
 <Label Text="{Binding Description}"
 FontSize="Small"/> ❷
</StackLayout>

```
В XAML здесь есть два пути источника привязки данных: Имя, ❶ и Описание.
❷. Целью привязки является Label, а целевым свойством является свойство Text объекта Label. Если мы рассмотрим
иерархия наследования Label выглядит так:

```
Object -> BindableObject -> Element -> NavigableElement -> VisualElement
-> View -> Label

```
Мы видим, что Element, VisualElement и View являются производными от BindableObject.
Цель привязки данных должна быть дочерней по отношению к BindableObject.
Источником привязки является модель представления ItemDetailViewModel. Имя, ① и описание,
②, являются свойствами модели представления, как показано в листинге 4.1 здесь:

** Листинг 4.1: ItemDetailViewModel.cs (https://epa.ms/ItemDetailViewModel4-1)**

```Csharp
using PassXYZ.Vault.Models;
namespace PassXYZ.Vault.ViewModels {
[QueryProperty(nameof(ItemId), nameof(ItemId))]
public class ItemDetailViewModel : BaseViewModel {
 private string itemId;
 private string name;
 private string description;
 public string Id { get; set; }
 public string Name { ①
 get => name;
 set => SetProperty(ref name, value);
 }
 public string Description… ②
 public string ItemId...
 public async void LoadItemId(string itemId) { ③
 try {
 var item = await DataStore.GetItemAsync
 (itemId);
 Id = item.Id;
 Name = item.Name;
 Description = item.Description;
 }
 catch (Exception) {
 Debug.WriteLine("Failed to Load Item");
 }
 }
}
 
```
Значения Name (①) и Description (②) загружаются из модели в методе LoadItemId().
метод, ③. Вы можете заметить, что класс украшен атрибутом QueryPropertyAttribute.
Это используется для передачи параметров во время навигации по страницам, и это будет представлено в следующей главе.

Давайте воспользуемся следующей таблицей 4.1, чтобы обобщить компоненты привязки данных в коде.

|Элементы привязки данных|Пример|
|:--------------------|:------|
|Цель|Ярлык|
|Целевое свойство|Текст|
|Исходный объект |ItemDetailViewModel|
|Путь к значению исходного объекта |Имя или описание|

Таблица 4.1: Параметры привязки данных

Проанализировав предыдущий код, давайте посмотрим на синтаксис выражения привязки:

```xml
<object property="{Binding bindProp1=value1[, bindPropN=valueN]*}" ... />
```
Свойства привязки можно задать в виде серии пар "имя-значение" в форме bindProp=value. Для
например, см. следующее:

```xml
<Label Text="{Binding Path=Description}" FontSize="Small"/>
```
Свойство Path является свойством по умолчанию, и его можно опустить, если оно является первым в свойстве.
список, как показано здесь:

```xml
<Label Text="{Binding Description}" FontSize="Small"/>
```
Свойству Source можно задать переопределение BindingContext, что мы вскоре обсудим.
Существует много свойств привязки, и вы можете найти подробности, обратившись к документу Microsoft
о классе Binding здесь:

https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding?view=windowsdesktop-6.0

Когда мы устанавливаем привязку данных к цели, мы можем использовать следующие два члена целевого класса:

* Свойство BindingContext дает нам исходный объект

* Метод SetBinding указывает целевое свойство и исходное свойство.

В нашем случае мы устанавливаем для свойства BindingContext экземпляр ItemDetailViewModel,
❶, в файле кода программной части C# ItemDetailPage, как показано в листинге 4.2 здесь. Он установлен на странице
уровне, и он применяется ко всем целям привязки для этой страницы:

** Листинг 4.2: ItemDetailPage.xaml.cs (https://epa.ms/ItemDetailPage4-2)**

```Csharp
using PassXYZ.Vault.ViewModels;
using System.ComponentModel;
using Microsoft.Maui;
using Microsoft.Maui.Controls;
namespace PassXYZ.Vault.Views
{
 public partial class ItemDetailPage : ContentPage
 {
  public ItemDetailPage()
 {
 InitializeComponent();
 BindingContext = new ItemDetailViewModel(); ❶
 }
 }
 void OnFieldSelected ...
}
```
Вместо использования расширения разметки Binding мы также можем создать привязку с помощью SetBinding.
метод прямо как здесь:

```xml
<StackLayout Spacing="20" Padding="15">
 <Label Text="Text:" FontSize="Medium" />
 <Label x:Name="labelText" FontSize="Small"/> ❷
 <Label Text="Description:" FontSize="Medium" />
 <Label Text="{Binding Description}"
 FontSize="Small"/>
 </StackLayout>
```

❷ В коде XAML мы удалили расширение разметки Binding и указали имя экземпляра.
как текст метки. В файле кода программной части C# мы можем вызвать метод SetBinding(), ❸, в
конструктор ItemDetailPage для создания привязки данных для свойства Text

```Csharp
public ItemDetailPage()
 {
 InitializeComponent();
 BindingContext = new ItemDetailViewModel();
 labelText.SetBinding(Label.TextProperty, "Text"); ❸
 }
```

# Режим привязки

В этом обсуждении все элементы пользовательского интерфейса являются объектами Label, которые не доступны для редактирования пользователем. Это
односторонняя привязка от источника к цели. В такой настройке привязки мы не меняем цель
объекты. Изменения в исходном объекте вызовут обновления в целевом объекте.

В .NET MAUI поддерживаются четыре режима привязки. Давайте рассмотрим их, обратившись к рисунку 4.4.

![изображение](https://user-images.githubusercontent.com/26972859/231775839-b1b28baf-b300-48fc-aa30-9f6d7eef8a88.png)

Рисунок 4.4: Режим привязки

Эти режимы привязки поддерживаются в .NET MAUI:

*Односторонняя привязка обычно используется в случае предоставления данных пользователю. В нашем приложении мы будем
получить список записей паролей и отобразить этот список на ItemsPage. Когда пользователь нажимает
элемент в списке, сведения о пароле будут отображаться на ItemDetailPage. используется односторонний
в обоих случаях.

* Двусторонняя привязка приводит к изменению либо исходного свойства, либо целевого свойства для
автоматически обновлять другие. В нашем приложении, когда пользователь редактирует поля ввода пароля
или когда пользователь вводит имя пользователя и пароль на LoginPage, целевая запись пользовательского интерфейса
Компонент и объект модели исходного представления устанавливаются с помощью TwoWay.

* OneWayToSource является обратным режиму привязки OneWay. Когда целевое свойство
изменяется, исходное свойство будет обновлено. Когда мы добавляем новую запись пароля на
NewItemPage, мы можем использовать OneWayToSource вместо режима привязки TwoWay для
повысить производительность.

* Привязка OneTime — это режим привязки, не показанный на рис. 4.4. Целевые свойства
инициализируются исходными свойствами, но любые дальнейшие изменения исходных свойств
не будет обновлять целевые свойства. Это более простая форма режима привязки OneWay с
лучшая производительность.

Если мы не указываем режим привязки в привязке данных, используется режим привязки по умолчанию. Мы можем
перезапишите режим привязки по умолчанию, если это необходимо.
В нашем коде ItemsPage мы используем элемент управления ListView для отображения списка групп паролей и
записи, поэтому мы должны установить атрибут IsRefreshing в режим привязки OneWay:

```Csharp
IsRefreshing="{Binding IsBusy, Mode=OneWay}"
```
Когда мы добавляем новый элемент в NewItemPage, мы используем элементы управления Entry и Editor для редактирования
характеристики. Мы можем использовать режимы привязки OneWayToSource или TwoWay:

```xml
<Label Text="Text" FontSize="Medium" />
<Entry Text="{Binding Text, Mode=TwoWay}" FontSize="Medium" />
<Label Text="Description" FontSize="Medium" />
<Editor Text="{Binding Description, Mode=OneWayToSource}" AutoSize="TextChanges" FontSize="Medium" Margin="0" />
```

# Изменение уведомлений во вьюмоделях

На рис. 4.4 мы видим, что целью привязки данных является класс, производный от BindableObject. Кроме
это требование, в настройке привязки данных как цель привязки данных, так и источник также должны
реализовать интерфейс INotifyPropertyChanged, чтобы при изменении свойства
Событие PropertyChanged вызывается для уведомления об изменении.
В шаблоне MVVM модель представления обычно является источником привязки данных, и нам нужно реализовать
интерфейс INotifyPropertyChanged в наших моделях просмотра. Если мы сделаем это для каждой модели представления,
будет много дублированного кода. В шаблоне Visual Studio класс BaseViewModel, как мы
в листинге 4.3, включен в шаблонный код, и мы используем его в нашем приложении. Другие модели просмотра
наследовать этот класс:

**Листинг 4.3. BaseViewModel.cs (https://epa.ms/BaseViewModel4-3)**

```Csharp
namespace PassXYZ.Vault.ViewModels;
public class BaseViewModel : InotifyPropertyChanged ❶
{
 public IDataStore<Item> DataStore =>
 DependencyService.Get<IDataStore<Item>>();
 bool isBusy = false;
 public bool IsBusy {
 get { return isBusy; }
 set { SetProperty(ref isBusy, value); } ❷
 }
 string title = string.Empty;
 public string Title {
  get { return title; }
 set { SetProperty(ref title, value); }
 }
 protected bool SetProperty<T>(ref T backingStore,
 T value,
 [CallerMemberName] string propertyName = "",
 Action onChanged = null) {
 if (EqualityComparer<T>.Default.Equals
 (backingStore, value))
 return false;
 backingStore = value;
 onChanged?.Invoke();
 OnPropertyChanged(propertyName);
 return true;
 }
 #region INotifyPropertyChanged
 public event PropertyChangedEventHandler PropertyChanged;❹
 protected void OnPropertyChanged([CallerMemberName]
 string propertyName = "") { ❸
 var changed = PropertyChanged;
 if (changed == null)
 return;
changed.Invoke(this,
 new PropertyChangedEventArgs(propertyName));
 }
 #endregion
}
```
В классе BaseViewModel (листинг 4.3) мы видим следующее:

* ❶ BaseViewModel реализует интерфейс INotifyPropertyChanged, и это
Интерфейс определяет одно событие, PropertyChanged, ❹.

* ❸ Когда свойство изменяется в установщике, метод OnPropertyChanged
называется. В OnPropertyChanged запускается событие PropertyChanged. Копия
обработчик события PropertyChanged сохраняется в измененной локальной переменной, поэтому
реализация безопасна в многопоточной среде. Когда событие PropertyChanged
запущен, ему необходимо передать имя свойства в качестве параметра, чтобы указать, какое свойство изменено.
Атрибут CallerMemberName можно использовать для поиска имени метода или имени свойства.
вызывающей стороны, поэтому нам не нужно жестко кодировать имя свойства.

* ❷ Когда мы определяем свойство в модели представления, метод OnPropertyChanged
вызывается в сеттере, но, как видите, в нашем коде мы вместо этого вызываем SetProperty<T>
OnPropertyChanged напрямую. SetProperty<T> выполнит дополнительную работу, прежде чем
вызывает OnPropertyChanged. Он проверяет, изменилось ли значение. Если нет изменений,
он вернется и ничего не сделает. Если значение изменено, оно обновит поле поддержки и вызовет
OnPropertyChanged для запуска события изменения.

Если мы вспомним ItemDetailViewModel в листинге 4.1, он наследуется от класса BaseViewModel.
В установщике свойств Name и Description мы вызываем SetProperty<T>, чтобы установить
значения и запустить событие PropertyChanged:

```Csharp
public string Name {
 get => name;
 set => SetProperty(ref name, value);
 }
 public string Description {
 get => description;
 set => SetProperty(ref description, value);
 }
```
В этом разделе мы узнали о привязке данных и интерфейсе INotifyPropertyChanged.
Нам нужно создать шаблонный код для определения свойства с поддержкой уведомлений об изменениях. Для упрощения
код и автоматически сгенерировать шаблонный код за кулисами, мы можем использовать MVVM Toolkit. Пожалуйста
дополнительную информацию о наборе инструментов MVVM можно найти в разделе «Дополнительная литература».
Получив некоторые базовые знания о дизайне пользовательского интерфейса XAML, шаблоне MVVM и привязке данных,
мы можем улучшить наше приложение, используя только что полученные знания.

# Улучшение модели данных и сервиса

Чтобы улучшить наше приложение, давайте еще раз рассмотрим варианты использования. Разрабатываем кроссплатформенный пароль
приложение-менеджер, совместимое с популярным форматом базы данных KeePass. У нас есть следующее
случаи использования:
  
  * Вариант использования 1: LoginPage — как пользователь менеджера паролей, я хочу войти в систему с паролем
приложение менеджера, чтобы я мог получить доступ к своим данным пароля

  * Вариант использования 2: AboutPage. Как пользователь менеджера паролей, я хочу иметь обзор своей
база данных и приложение, которое я использую

  * Вариант использования 3: ItemsPage — как пользователь менеджера паролей я хочу видеть список групп и
записи, чтобы я мог исследовать и проверять данные своего пароля

  * Вариант использования 4: ItemDetailPage. Как пользователь менеджера паролей, я хочу
ввод пароля после того, как я выберу его в списке вводов пароля

  * Вариант использования 5: NewItemPage — как пользователь менеджера паролей я хочу добавить запись пароля или
создать новую группу в моей базе данных

Эти пять вариантов использования унаследованы от шаблона Visual Studio, и их достаточно для
пользовательские истории нашего приложения для управления паролями на данный момент. Мы улучшим наше приложение, используя этих пользователей
рассказы в этой главе.
  
Мы рассмотрели модель, представление и модель представления, но приведенная здесь модель слишком проста и неудобна.
достаточно для использования в приложении диспетчера паролей:

```Csharp
public class Item
{
 public string Id { get; set; }
 public string Name { get; set; }
 public string Description { get; set; }
}  
```
Основные функции нашего приложения для управления паролями инкапсулированы на уровне модели. Мы будем
построить нашу модель, используя два пакета .NET, KPCLib и PassXYZLib. Эти два пакета включают
все функции управления паролями, которые нам нужны.

# KPCLib

Модель, которую мы будем использовать, — это библиотека KeePass, которая называется KeePassLib. И KeePass, и
KeePassLib созданы для .NET Framework, поэтому их можно использовать только в Windows. я портировал
KeePassLib и пересобрал ее как библиотеку .NET Standard 2.0, упакованную как KPCLib. KPCLib может быть
можно найти в NuGet и GitHub здесь:
  
  * NuGet: https://www.nuget.org/packages/KPCLib/
  
  * GitHub: https://github.com/passxyz/KPCLib

  KPCLib используется и как имя пакета, и как пространство имен. В комплект KPCLib входят два
пространства имен, KeePassLib и KPCLib. Пространство имен KeePassLib является исходным из
KeePass со следующими изменениями:

  * Обновлено и создано для .NET Standard 2.0.
  
  * Обновлены классы PwEntry и PwGroup, производные от абстрактного класса Item.

  В пространстве имен KPCLib определен абстрактный класс Item. Причина, по которой я создал новый класс и
сделал его родительским классом PwEntry и PwGroup из-за разницы в дизайне навигации между
KeePass и PassXYZ.Vault.
Если мы посмотрим на пользовательский интерфейс KeePass на рис. 4.5, то увидим, что это классический пользовательский интерфейс рабочего стола Windows. 
навигация разработана вокруг древовидного представления, такого как проводник Windows.

![изображение](https://user-images.githubusercontent.com/26972859/231781606-fbbd00ed-d0d4-4630-b075-7e022fa4c6f4.png)

  Рисунок 4.5: Пользовательский интерфейс KeePass

Два класса, PwGroup и PwEntry, ведут себя как каталоги и файлы. Экземпляр PwGroup — это просто
как каталог, и включает в себя список дочерних элементов — PwGroup и PwEntry. Все экземпляры PwGroup
отображать в виде дерева на правой панели. Когда выбран экземпляр PwGroup, список
PwEntry в этой группе отображается на правой панели. PwEntry включает содержимое пароля
записи, такие как имя пользователя и пароль. Содержимое PwEntry отображается на нижней панели.
В дизайне пользовательского интерфейса PassXYZ.Vault мы используем шаблон оболочки .NET MAUI. Это реализация
многоуровневый шаблон Master-Detail. В многоуровневом шаблоне Master-Detail для отображения используется один список.
предметы. В этом случае экземпляры PwGroup и PwEntry могут отображаться в одном списке.
После выбора элемента мы предпримем действие в соответствии с типом элемента.

# Абстракция PwGroup и PwEntry
  
Чтобы лучше работать с дизайном пользовательского интерфейса PassXYZ.Vault, мы можем абстрагировать PwGroup и PwEntry как элемент.
абстрактный класс, как показано на рис. 4.6.

![изображение](https://user-images.githubusercontent.com/26972859/231782011-5a80c2e7-26b8-42d4-83e9-160a2a15cf4e.png)

Рисунок 4.6: Диаграмма классов элемента

Ссылаясь на эту диаграмму классов UML на рис. 4.6 и исходный код Item.cs в листинге 4.4,
мы можем видеть, что следующие свойства определены в абстрактном классе Item. Эти свойства
реализовано как в PwEntry, так и в PwGroup:


  * ① Имя – название предмета

  * ② Описание – описание предмета.

  * ③ Примечания – комментарии к элементам, определяемые пользователем

  * ④ IsGroup – true, если экземпляр PwGroup, или false, если это PwEntry

  * ⑤ Id — идентификатор экземпляра (уникальное значение, аналогичное первичному ключу в базе данных)

  * ⑥ ImgSource — источник изображения значка (и PwGroup, и PwEntry могут иметь связанный значок)

  * ⑦ LastModificationTime – время последней модификации элемента

  * ⑧ Item реализует интерфейс INotifyPropertyChanged и может хорошо работать в модели MVVM для привязки данных:

**Листинг 4.4: Item.cs (https://epa.ms/Item4-4)**

```Csharp
using System.Text;
namespace KPCLib
{
 public abstract class Item : INotifyPropertyChanged ⑧
 {
 public abstract DateTime LastModificationTime {get;set;};} ⑦
 public abstract string Name { get; set; } ①
 public abstract string Description { get;} ②
 public abstract string Notes { get; set; } ③
 public abstract bool IsGroup { get; } ④
 public abstract string Id { get; } ⑤
 virtual public Object ImgSource { get; set; } ⑥
#region INotifyPropertyChanged ...
 }
}
```

# PassXYZLib

Чтобы использовать KeePassLib в PassXYZ.Vault, нам нужно использовать некоторые API-интерфейсы .NET MAUI для расширения
функциональные возможности, необходимые для нашего приложения. Чтобы отделить бизнес-логику от пользовательского интерфейса и расширить
функциональные возможности KeePassLib для .NET MAUI, библиотека классов .NET MAUI, PassXYZLib, является
создан для инкапсуляции расширенной модели в отдельную библиотеку. PassXYZLib — это пакет
имя и пространство имен.
Чтобы добавить PassXYZLib в наш проект, мы можем добавить его в файл проекта PassXYZ.Vault.csproj,
как видно здесь:

```Csharp
<ItemGroup>
 <PackageReference Include="PassXYZLib" Version="2.0.2" />
 </ItemGroup> 
```
Здесь мы также можем добавить пакет PassXYZLib из командной строки. Из командной строки перейдите к
папку проекта и выполните эту команду, чтобы добавить пакет:

``dotnet добавить пакет PassXYZLib```

# Обновление модели

После добавления в проект пакета PassXYZLib мы можем получить доступ к KPCLib, KeePassLib и
Пространства имен PassXYZLib. Чтобы заменить текущую модель, нам нужно удалить файл Models/Item.
cs из проекта.
  
После этого нам нужно заменить пространство имен PassXYZ.Vault.Models на KPCLib.

![изображение](https://user-images.githubusercontent.com/26972859/231782832-e2fca22e-7462-4427-8c32-df7b356f2791.png)

Рисунок 4.7: Обновление модели из PassXYZ.Vault.Models в KPCLib (https://bit.ly/3uXVl7H)

В истории коммитов, рис. 4.7, мы видим, что есть четыре модели представлений, и три представления
измененный. Все изменения являются изменениями пространства имен, поэтому нам не нужно подробно объяснять их.

# Обновление сервиса
  
Основные изменения можно найти в MockDataStore.cs. В классе MockDataStore мы
изменено пространство имен и инициализация фиктивных данных.

Чтобы отделить модель от остальной системы, мы используем интерфейс IDataStore для инкапсуляции.
собственно реализация. На этом этапе мы используем фиктивные данные для реализации сервиса для тестирования, поэтому
используется класс MockDataStore. Мы заменим его фактической реализацией в главе 6.
Представляем внедрение зависимостей и сервисы для конкретных платформ с использованием внедрения зависимостей.

---
Инверсия зависимостей и внедрение зависимостей
Мы узнаем о принципе инверсии зависимостей (DIP), который является одним из SOLID
принципов проектирования, в Главе 6, Знакомство с внедрением зависимостей и специфичными для платформы сервисами.
Мы узнаем, как использовать внедрение зависимостей для управления сопоставлением IdataStore.
интерфейс к фактической реализации.
---

В исходном коде мы создали новые экземпляры PassXYZ.Vault.Models.Item для инициализации
фиктивные данные. После замены модели мы не можем создать KPCLib.Item напрямую, так как это абстрактный
сорт. Вместо этого мы можем создать новые экземпляры PxEntry, используя данные JSON, и назначить PxEntry
экземпляры в список элементов:

```Csharp
Static string[] jsonData =…;
 readonly List<Item> items;
 public MockDataStore() {
 items = new List<Item>() {
 new PxEntry(jsonData[0]),
 new PxEntry(jsonData[1]),
 new PxEntry(jsonData[2]),
 new PxEntry(jsonData[3]),
 new PxEntry(jsonData[4])
 };
 }
```
Для создания экземпляров абстрактного класса можно использовать фабричный шаблон. Чтобы сделать тестовый код
простой, мы не использовали его здесь. Фабричный шаблон используется в фактической реализации далее в этой книге.
Мы заменили модель в примере кода нашей собственной моделью. С этим изменением мы можем
улучшите ItemsPage и ItemDetailPage, чтобы отразить обновленную модель.
Мы обновим представление и модель представления с помощью привязки данных к коллекциям в следующем разделе.

# Привязка к коллекциям
  
В предыдущем разделе мы представили некоторые базовые знания о привязке данных, а также заменили
модель с помощью PassXYZLib. Когда мы ввели привязку данных, мы использовали ItemDetailPage и
ItemDetailViewModel, чтобы объяснить, как связать исходное свойство с целевым свойством. Для страницы сведений об элементе мы создали привязку данных из одного источника к одной цели. Однако есть много
случаи, когда нам нужно привязать коллекцию данных к пользовательскому интерфейсу, например ListView или CollectionView,
для отображения группы данных.

![изображение](https://user-images.githubusercontent.com/26972859/231783417-872c30e0-3b1c-448d-aaac-886aab07d564.png)

Рисунок 4.8: Привязка к коллекциям

Как видно на рис. 4.8, когда мы создаем привязку данных из объекта коллекции к представлению коллекции,
используется свойство ItemsSource. В .NET MAUI представления коллекций, такие как ListView
и CollectionView могут использоваться, и оба имеют свойство ItemsSource.
  
В качестве объекта коллекции мы можем использовать любую коллекцию, реализующую интерфейс IEnumerable. Однако,
изменения в объекте коллекции могут не обновлять пользовательский интерфейс автоматически. Для обновления пользовательского интерфейса
автоматически исходный объект должен реализовать интерфейс INotifyCollectionChanged.
  
Мы можем реализовать наш объект коллекции с интерфейсом INotifyCollectionChanged, но
Самый простой подход — использовать класс ObservableCollection<T>. Если какой-либо элемент в наблюдаемом
коллекция изменена, привязанное представление пользовательского интерфейса уведомляется автоматически.
Имея это в виду, давайте рассмотрим диаграмму классов наших моделей, моделей представлений и представлений, как показано на
Рисунок 4.9:
  
* Модель: Элемент, PwEntry, PwGroup, Поле
* Модель просмотра: ItemsViewModel, ItemDetailViewModel
* Вид: ItemsPage, ItemDetailPage

Когда мы отображаем список элементов для пользователя, пользователь может выполнить действие с выбранным элементом. Если предмет
является группой, мы покажем группы и записи в экземпляре ItemsPage. Если элемент является записью,
мы покажем содержимое записи на странице содержимого, которая является экземпляром ItemDetailPage.
На ItemDetailPage мы показываем пользователю список полей. Каждое поле является парой ключ-значение и
реализован как экземпляр класса Field.

Таким образом, мы показываем пользователю два вида списков — список элементов или список полей. Список предметов
отображается в ItemsPage, а список полей отображается в ItemDetailPage.

![изображение](https://user-images.githubusercontent.com/26972859/231783733-8f28e4ff-78b4-4ec7-8410-b1ac2c3d52aa.png)

Рисунок 4.9: Диаграмма классов модели, представления и модели представления

На этой диаграмме классов мы видим, что и PwEntry, и PwGroup являются производными от Item. Eсть
список элементов в ItemsViewModel и список полей в ItemDetailViewModel. в
представлений, ItemsPage содержит ссылку на ItemsViewModel, а ItemDetailPage содержит
ссылка на ItemDetailViewModel.

  После того, как мы доработаем наш дизайн, мы можем посмотреть на реализацию. Мы проверим реализацию
ItemDetailViewModel и ItemDetailPage для проверки изменения дизайна:

```Csharp
  [QueryProperty(nameof(ItemId), nameof(ItemId))]
public class ItemDetailViewModel : BaseViewModel {
 private string itemId;
 private string description;
 public string Id { get; set; }
 public ObservableCollection<Field> Fields { get; set; } ❶
 public string Description ...
 public string ItemId ...
 public ItemDetailViewModel() {
 Fields = new ObservableCollection<Field>(); ❷
 }
 public async void LoadItemId(string itemId) {
 try {
 var item = await DataStore.GetItemAsync(itemId);
 Id = item.Id;
 Title = item.Name;
 Description = item.Description;
 if (!item.IsGroup) {
 PwEntry dataEntry = (PwEntry)item; ❸
 Fields.Clear();
 List<Field> fields = dataEntry.GetFields(GetImage:
 FieldIcons.GetImage); ❹
 foreach (Field field in fields) {
 Fields.Add(field);
 }
 }
 }
 catch (Exception) {
 Debug.WriteLi"e("Failed to Load I"em");
 }
 }
}
```
Как показано в приведенном здесь коде, мы видим разницу в ItemDetailViewModel по сравнению с
Листинг 4.1 в начале этой главы:
• ❶ Свойство Fields определено как тип ObservableCollection<Field> для
держите список полей
• ❷ Переменная Fields инициализируется в конструкторе ItemDetailViewModel.
• ❸ Тип элемента переменной здесь PwEntry, и мы можем преобразовать его в экземпляр PwEntry.
• ❹ Мы можем получить список полей, вызвав метод расширения GetFields(), который
определено в библиотеке PassXYZLib

---
Изучив изменения в ItemDetailViewModel, давайте рассмотрим изменения в
ItemDetailPage в листинге 4.5:
---

**Листинг 4.5: ItemDetailPage.xaml (https://epa.ms/ItemDetailPage4-5)**

```xml
<?xml versi"n="".0" encodi"g="ut"-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 x:Class="PassXYZ.Vault.Views.ItemDetailPage"
 xmlns:local="clr-namespace:PassXYZ.Vault.ViewModels"
 xmlns:model="clr-namespace:KPCLib;assembly=KPCLib" ①
 x:DataType="local:ItemDetailViewModel"
 Title="{Binding Title}">
 <StackLayout>
 <ListView x:Name="FieldsListView"
 ItemsSource="{Binding Fields}" ②
 VerticalOptions="FillAndExpand"
 HasUnevenRows="False"
 RowHeight="84"
 IsPullToRefreshEnabled="true"
 IsRefreshing="{Binding IsBusy, Mode=
 OneWay}"
 CachingStrategy="RetainElement"
 ItemSelected="OnFieldSelected">
 <ListView.ItemTemplate...> ③
 <ListView.Footer>
 <StackLayout Padding="5" Orientation=
 "Horizontal">
 <Label Text="{Binding Description}
 ".../>
 </StackLayout>
 </ListView.Footer>
 </ListView>
 </StackLayout>
</ContentPage>
```
  
В ItemDetailPage мы видим много изменений по сравнению с Листингом 3.4 в Главе 3, User
Дизайн интерфейса с помощью XAML. ListView используется для отображения полей в записи:

  * ① Для использования Field в DataTemplate добавлено пространство имен xmlns:model. Поскольку
Класс поля находится в другой сборке, нам нужно указать имя сборки следующим образом:
 xmlns:model="clrnamespace:KPCLib;assembly=KPCLib"

  * ② Мы привязываем свойство Fields к свойству ItemsSource ListView.

  * ③ DataTemplate используется для определения внешнего вида каждого элемента в ListView. Он свернут в листинге 4.5.

  Давайте расширим его и рассмотрим реализацию DataTemplate в этом блоке кода:

В ItemDetailPage мы видим много изменений по сравнению с Листингом 3.4 в Главе 3, User
Дизайн интерфейса с помощью XAML. ListView используется для отображения полей в записи:

  * ① Для использования Field в DataTemplate добавлено пространство имен xmlns:model. Поскольку

  Класс поля находится в другой сборке, нам нужно указать имя сборки следующим образом:
 xmlns:model="clrnamespace:KPCLib;assembly=KPCLib"

  * ② Мы привязываем свойство Fields к свойству ItemsSource ListView.

  * ③ DataTemplate используется для определения внешнего вида каждого элемента в ListView. Он рухнул
в листинге 4.5.
Давайте расширим его и рассмотрим реализацию DataTemplate в этом блоке кода:

```xml
<DataTemplate>
 <ViewCell>
 <Grid Padding="10" x:DataType="model:Field" > ➊
 <Grid.RowDefinitions...>
 <Grid.ColumnDefinitions...>
 <Grid Grid.RowSpan="2" Padding="10">
 <Grid.ColumnDefinitions...>
 <Image Grid.Column="0" Source="{Binding ImgSource}"
 HorizontalOptions="Fill"
 VerticalOptions="Fill" /> ➋
 </Grid>
 <Label Text="{Binding Key}" Grid.Column="1".../> ➌
 <Label Text="{Binding Value}" Grid.Row="1"
 Grid.Column="1".../> ➍
 </Grid>
 </ViewCell>
</DataTemplate> 
```
В DataTemplate макет каждого поля определяется в элементе ViewCell. В ViewCell
элемент, мы определили макет сетки 2x2. Первый столбец используется для отображения значка поля. Ключ и
значения в поле отображаются во втором столбце с двумя строками:
   
  * ➊ Атрибут x:DataType в макете сетки имеет значение Поле, а следующие данные
привязка в Grid будет ссылаться на свойство Field. Класс Field определен в нашей модели,
который находится в пакете KPCLib.

   * ➋ Для отображения значка поля свойству Source элемента управления Image присваивается значение ImgSource.
собственность Филда.

   * ➌,➍ Свойство «Ключ» и свойство «Значение» поля присваиваются свойству «Текст».
свойство элемента управления Label.
С помощью этого анализа мы узнали, как создать привязку данных для коллекции. Привязка данных, используемая в
ItemsPage и ItemsViewModel аналогичны этой реализации. Разница в том, что мы используем
Коллекция Field здесь и коллекция классов Item используется в ItemsPage. Завершив
изменения, мы можем увидеть улучшение пользовательского интерфейса на рисунке 4.10.

![изображение](https://user-images.githubusercontent.com/26972859/231786690-f2a1c18e-4403-4537-9c4c-e5a27e2da6c6.png)

Рисунок 4.10: Улучшенные ItemsPage и ItemDetailPage

В улучшенном пользовательском интерфейсе мы отображаем список элементов на ItemsPage (слева). Элементы списка могут быть
записи (например, в Facebook, Twitter или Amazon) или группы, которые мы увидим в следующей главе.
Когда пользователь щелкает элемент, например GitHub, мы отобразим его на ItemDetailPage (на странице
верно). На странице сведений об элементе отображается информация об этой учетной записи (GitHub).
После внедрения новой модели данных дизайн не сильно изменился. Мы улучшили пользовательский интерфейс, чтобы
сделать его более осмысленным, но большая часть сложности скрыта в наших библиотеках моделей — KPCLib и
PassXYZLib. Это преимущество, которое мы можем увидеть, используя шаблон MVVM для разделения модели.
(бизнес-логика) из дизайна пользовательского интерфейса.

# Краткое содержание
   
В этой главе мы узнали о шаблоне MVVM и применили его к разработке нашего приложения. Один ключ
Особенностью шаблона MVVM является привязка данных между представлением и моделью представления. Мы узнали о
привязку данных и использовали ее в реализации нашего приложения.
Мы также улучшили модель в этой главе. Мы улучшили его, внедрив два пакета — KPCLib
и PassXYZLib. Мы заменили модель в примере кода моделью в этих двух пакетах.
Мы обновили пользовательские интерфейсы ItemsPage и ItemDetailPage, чтобы отразить изменения в модели.
В следующей главе мы уточним наши пользовательские истории и продолжим улучшать пользовательский интерфейс, используя наши знания.
Shell и навигация.

дальнейшее чтение
   
* Введение в набор инструментов MVVM: https://learn.microsoft.com/en-us/dotnet/
инструментарий сообщества/mvvm/
   
* KeePass — бесплатный менеджер паролей с открытым исходным кодом: https://keepass.info/

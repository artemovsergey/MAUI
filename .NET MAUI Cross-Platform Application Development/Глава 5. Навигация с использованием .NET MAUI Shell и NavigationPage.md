# Навигация с использованием .NET MAUI Shell и NavigationPage

В предыдущей главе мы представили шаблон MVVM и привязку данных. Мы улучшили пользователя
дизайн интерфейса и представил нашу модель данных. В нашем приложении мы можем выбрать страницу во всплывающем меню.
меню, и мы можем переключиться на детали элемента, когда элемент выбран. это часть навигации
механизм в .NET MAUI. В этой главе мы углубимся в дизайн навигации и
узнаете, как работает навигация в .NET MAUI.

В этой главе будут рассмотрены следующие темы:

* Реализация навигации

* Использование оболочки

* Улучшение дизайна и навигации

# Технические требования

Для тестирования и отладки исходного кода в этой главе вам необходимо установить Visual Studio 2022 на
ваш ПК или Mac. Пожалуйста, обратитесь к разделу Настройка среды разработки в Главе 1, Получение
Начал с .NET MAUI, подробнее.
Исходный код этой главы доступен в следующей ветке GitHub: https://github.
com/PacktPublishing/.NET-MAUI-Кроссплатформенное-Приложение-Разработка/
дерево/главное/Глава05.
Исходный код можно загрузить с помощью следующей команды git:

```xml
git clone -b Chapter05 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development
```

# Реализация навигации

В этой главе мы собираемся реализовать логику навигации нашего приложения менеджера паролей. Это будет
включают в себя следующие функции:

* Вход и подключение к базе данных

* Изучение данных в базе паролей

Дизайн навигации оказывает значительное влияние на пользовательский опыт. В .NET MAUI есть встроенный
механизм, помогающий разработчикам эффективно реализовывать навигацию. Как мы видели в предыдущем
главы, мы можем использовать Shell в нашем приложении. В этой главе мы узнаем о Shell и усовершенствуем наши
приложение с функциями, предоставляемыми Shell. Прежде чем погрузиться в Shell, мы изучим базовую навигацию.
механизм в .NET MAUI.

Существует два наиболее распространенных способа реализации навигации — иерархический и модальный:

* Иерархическая навигация обеспечивает навигацию, при которой пользователь может перемещаться по
страницы как вперед, так и назад. Этот шаблон обычно использует панель инструментов или панель навигации в
верхней части экрана, чтобы отобразить кнопку «Вверх» или «Назад» в верхнем левом углу. Обычно он поддерживает
Стек страниц LIFO для управления навигацией. LIFO расшифровывается как «последний пришел, первый ушел», что означает
последняя страница, на которую нужно зайти, открывается первой.

* Модальная навигация отличается от иерархической навигации тем, как пользователи могут реагировать
к этому. Если на экране отображается модальная страница, пользователи должны выполнить или отменить необходимые действия.
задачу на странице, прежде чем они смогут предпринять другие действия. Пользователи не могут уйти от модального
страниц до того, как требуемая задача будет завершена или отменена.

# INНавигационный интерфейс и NavigationPage

В .NET MAUI как иерархическая навигация, так и модельная навигация поддерживаются через
Интерфейс навигации. Интерфейс INavigation поддерживается специальной страницей под названием
Страница навигации. NavigationPage используется для управления навигацией по стеку других страниц.
Иерархия наследования NavigationPage выглядит следующим образом:

```
Объект > BindableObject > Элемент > NavigableElement > VisualElement >
Страница > Страница навигации
```
NavigableElement определяет свойство Navigation, которое реализует INavigation.
интерфейс. Это унаследованное свойство можно вызывать из любого VisualElement или Page для навигации.
целей, как показано здесь:

```Csharp
общедоступная навигация Microsoft.Maui.Controls.INavigation { get; }
```
Чтобы использовать NavigationPage, мы должны добавить первую страницу в стек навигации в качестве корневой страницы
приложение. Мы можем увидеть пример этого в следующем фрагменте кода:

```Csharp
общедоступное частичное приложение класса: приложение
{
 ...
 общедоступное приложение ()
 {
 ИнициализироватьКомпонент();
 Главная страница = новая страница навигации (новая первая страница());
 }
 ...
}
```
Мы строим стек навигации в конструкторе класса App, который является производным классом от
Приложение. TheFirstPage, который является производным классом ContentPage, помещается на
стек навигации.

# Использование стека навигации

Существует два способа перехода на страницу или со страницы. Когда мы хотим просмотреть новую страницу, мы можем добавить
новую страницу в стек навигации. Это действие называется толчком. Если мы хотим вернуться к предыдущему
page, мы можем извлечь предыдущую страницу из стека:

![изображение](https://user-images.githubusercontent.com/26972859/231789680-d873148c-665d-4b4a-83ad-92cda6551d19.png)

Рисунок 5.1: Нажмите и вытолкните

Как показано на рис. 5.1, мы можем использовать метод PushAsync() или PopAsync() в интерфейсе INavigation.
интерфейса для перехода на новую страницу или возврата на предыдущую страницу соответственно.
Если мы находимся на странице 1, мы можем перейти на страницу 2 с помощью обработчика события GotoPage2(). В этой функции
мы помещаем новую страницу Page2 в стек:

```Csharp
async void GotoPage2 (отправитель объекта, EventArgs e) {
 await Navigation.PushAsync (новая страница2());
}
```
Оказавшись на странице 2, мы можем вернуться назад с помощью обработчика событий BackToPage1(). В этой функции
мы извлекаем предыдущую страницу из стека:

```Csharp
async void BackToPage1 (отправитель объекта, EventArgs e) {
 ожидайте Navigation.PopAsync();
}
```
В предыдущем примере мы перешли на новую страницу, используя метод иерархической навигации. К
отображать модальную страницу, мы можем использовать модальный стек. Например, в нашем приложении, если мы хотим создать новый
элемент в ItemsPage, мы можем вызвать PushModalAsync() в ItemsViewModel:

```Csharp
ожидайте Shell.Current.Navigation.
PushModalAsync (NewItemPage (тип));
```
После создания нового элемента мы можем вызвать PopModalAsync() в NewItemViewModel:

```Csharp
_ = ожидание Shell.Current.Navigation.PopModalAsync();
```
На страницах модели NewItemPage мы не можем переходить на другие страницы до завершения или
отменить задание. И PopAsync(), и PopModalAsync() возвращают ожидаемую задачу
Тип ```Task<Page>```.

# Управление стеком навигации

В иерархической навигации мы можем не только извлекать страницы из стека, но и манипулировать ими.
стек навигации.

# Вставка страницы

Мы можем вставить страницу в стек с помощью метода InsertPageBefore():

```Csharp
public void InsertPageBefore (страница-страница, страница до);  
```

Ниже приведены два параметра InsertPageBefore():

  * страница: это страница, которую нужно добавить

  * перед: это страница, перед которой вставляется страница

  На рис. 5.1, когда мы находимся на странице Page2, мы можем вставить перед ней другую страницу, Page1:
Navigation.InsertPageBefore(новая страница1(), это);

# Удаление страницы

Мы также можем удалить определенную страницу из стека, используя метод RemovePage():

```Csharp
public void RemovePage (Страница страницы);
```
На рис. 5.1, учитывая, что у нас есть ссылка на страницу 2, когда мы находимся на странице 3, мы можем удалить страницу 2.
из стека. После вызова PopAsync() мы вернемся на страницу Page1:

```Csharp
// ссылочная страница2 является экземпляром страницы2
Навигация. Удалить Страницу (страница 2);
ожидайте Navigation.PopAsync();  
```
Благодаря этому мы научились создавать стек навигации с помощью NavigationPage. Как только мы
есть навигационный стек, мы можем использовать интерфейс INavigation для выполнения навигационных действий. Для
простое приложение, этого может быть достаточно. Тем не менее, будет много работы, связанной с
сложное приложение. У нас есть лучший выбор в .NET MAUI, известном как Shell. С «Шелл» мы можем
предоставить пользователям лучший опыт навигации с меньшими затратами труда.

# Использование оболочки

Интерфейс INavigation и NavigationPage обеспечивают основные функции навигации. Если мы
полагаться только на них, нам самим приходится создавать сложные навигационные механизмы. В .NET MAUI,
есть встроенные шаблоны страниц на выбор, и они могут предоставлять различные возможности навигации.
Как показано на диаграмме классов на рис. 5.2, для различных вариантов использования доступны встроенные страницы.
Все эти страницы — TabbedPage, ContentPage, FlyoutPage, NavigationPage и Shell.
– являются производными классами Page:

![изображение](https://user-images.githubusercontent.com/26972859/231790667-363a88b4-4a0a-4753-8b02-0805c651c7a0.png)

Рисунок 5.2: Диаграмма классов встроенных страниц в .NET MAUI

ContentPage, TabbedPage и FlyoutPage можно использовать для создания различных пользовательских интерфейсов.
согласно вашим требованиям.

  * ContentPage является наиболее часто используемой страницей и может включать любые элементы макета и представления. Это
подходит в случае одностраничного оформления.
  * TabbedPage можно использовать для размещения нескольких страниц. Каждая дочерняя страница может быть выбрана серией
вкладок вверху или внизу страницы.
  * Всплывающая страница может отображать список элементов, аналогичный элементам меню на рабочем столе.
приложение. Пользователь может переходить на отдельные страницы через пункты меню.

  Несмотря на то, что Shell также является производным классом Page, он включает в себя общий пользовательский интерфейс навигации,
которые могут облегчить жизнь разработчикам. Это помогает разработчикам, уменьшая сложность приложения
разработка с настраиваемыми и богатыми функциями в одном месте.
Shell предоставляет следующие возможности:

  * Единое место для описания визуальной иерархии приложения
  
  * Настраиваемый общий пользовательский интерфейс навигации

  * Схема навигации на основе URI, которая очень похожа на то, что мы имеем в веб-браузере.
  
  * Встроенный обработчик поиска

  Стандартными блоками верхнего уровня Shell являются всплывающие окна и вкладки. Мы можем использовать всплывающие окна и вкладки для создания
структура навигации нашего приложения.

# Вылететь

Всплывающее меню можно использовать в качестве меню верхнего уровня приложения Shell. В нашем приложении мы должны использовать оба всплывающих окна.
и вкладки для создания дизайна навигации верхнего уровня. В этом разделе мы рассмотрим всплывающие окна; В следующий
мы обсудим, как использовать вкладки в нашем приложении.
На рис. 5.3 показано, как выглядит всплывающее меню в нашем приложении. Из всплывающего меню мы можем переключиться
на AboutPage, ItemsPage или LoginPage. Чтобы получить доступ к всплывающему меню, мы можем провести пальцем от
в левой части экрана или щелкните всплывающий значок, который представляет собой значок гамбургера ①. Когда мы нажимаем Root
Группа ② во всплывающем меню мы увидим список записей паролей или групп:

![изображение](https://user-images.githubusercontent.com/26972859/231791165-17ad57b0-a654-4dcc-b9a1-2e3bf0c1bf73.png)

Рисунок 5.3: Всплывающее окно

Всплывающее меню состоит из всплывающих элементов или пунктов меню. На рис. 5.3 «О программе» и «Корневая группа»
всплывающие элементы, в то время как выход из системы является пунктом меню.

# Всплывающие элементы
  
Каждый элемент всплывающего меню представляет собой объект FlyoutItem, содержащий объект ShellContent. Мы можем определить
всплывающие элементы, как в файле AppShell.xaml. Мы назначаем строковый ресурс заголовку ①
атрибут и ImageSource для атрибута Icon ②. Они соответствуют свойствам
Класс FlyoutItem:

```xml
<FlyoutItem ① Title="{x:Static resources:Resources.About}" ②
Значок="tab_info.png" >
 <Вкладка>
 <ShellContent Route="AboutPage" ContentTemplate=
 "{DataTemplate local:AboutPage}" />
 </таб>
</ВылетающийЭлемент>
<FlyoutItem x:Name="RootItem" Title="Обзор"
 Значок="tab_home.png">
 <Вкладка>
 <ShellContent Route="RootPage" ContentTemplate=
 "{DataTemplate local:ItemsPage}" />
 </таб>
</ВылетающийЭлемент>  
```
В оболочке есть неявные операторы преобразования, которые можно использовать для удаления элементов FlyoutItem и Tab.
объекты, чтобы предыдущий код XAML также можно было упростить, например:

```xml
<ShellContent Title="{x:Статические ресурсы:Ресурсы.
О}" Icon="tab_info.png" Route="О странице"
ContentTemplate="{DataTemplate local:AboutPage}" />
<ShellContent x:Name="RootItem" Title="Обзор" Icon="tab_
home.png" Route="RootPage" ContentTemplate="{DataTemplate
локальный:ItemsPage}" />  
```

# Пункты меню

Элементы всплывающего меню можно использовать для перехода на страницу содержимого, но иногда нам может потребоваться выполнить какое-либо действие.
вместо перехода на страницу содержимого. В этом случае мы можем использовать пункты меню. В нашем случае имеем
определил выход из системы как пункт меню:  

```xml
 <MenuItem Text="Выход" IconImageSource="tab_login.png"
 Clicked="OnMenuItemClicked">
</элемент меню>
```
Как видно из предыдущего кода XAML, каждый пункт меню является объектом MenuItem. Элемент меню
имеет событие Clicked и свойство Command. Когда MenuItem нажат, мы можем выполнить
действие. В предыдущем пункте меню мы назначили OnMenuItemClicked() в качестве обработчика события.
Давайте рассмотрим AppShell.xaml в нашем приложении в листинге 5.1. Здесь мы определили два всплывающих элемента и один
пункт меню. Мы можем выбрать AboutPage ➊ и ItemsPage ➋ со всплывающими элементами и выйти из системы ➌
через пункт меню:  
  
** Листинг 5.1: AppShell.xaml в PassXYZ.Vault (https://epa.ms/AppShell5-1)**  

```xml
<Shell xmlns="http://schemas.microsoft.com
 /dotnet/2021/мауи"
 xmlns:x="http://schemas.microsoft.com
 /winfx/2009/xaml"
 xmlns:local="clr-namespace:PassXYZ.Vault.Views"
 xmlns:style="clr-namespace:PassXYZ.
 Хранилище.Ресурсы.Стили"
 xmlns:resources="clr-namespace:PassXYZ.
 Хранилище.Свойства"
 xmlns:app="clr-namespace:PassXYZ.Vault"
 Title="PassXYZ.Хранилище"
 x:Class="PassXYZ.Vault.AppShell">
 <Shell.Ресурсы...>
 <Панель вкладок> ➍
 <Tab Title="{x:Статические ресурсы:Ресурсы.
 action_id_login}" Icon="tab_login.png">
 <ShellContent Route="LoginPage" ContentTemplate=
 "{DataTemplate local:LoginPage}" />
 </таб>
 <Tab Title="{x:Статические ресурсы:Resources.menu
 _id_users}" Icon="tab_users.png">
 <ShellContent Route="SignUpPage" ContentTemplate=
 "{DataTemplate local:SignUpPage}" />
 </таб>
 </Вкладка>
 <FlyoutItem Title="{x:Статические ресурсы:Ресурсы.О}"
 Значок="tab_info.png" >
 <ShellContent Route="AboutPage" ContentTemplate=
 "{DataTemplate local:AboutPage}" /> ➊
 </ВылетающийЭлемент>
 <FlyoutItem x:Name="RootItem" Title="Обзор"
 Значок="tab_home.png">
 <ShellContent Route="RootPage" ContentTemplate=
 "{DataTemplate local:ItemsPage}" /> ➋
 </ВылетающийЭлемент>
 <MenuItem Text="Выход" IconImageSource="tab_login.png"
 Clicked="OnMenuItemClicked"> ➌
 </элемент меню>
</оболочка>
```
Существует также TabBar ➍, определенный для LoginPage и SignUpPage. Теперь рассмотрим вкладки.  
  
# Вкладки

Когда мы используем вкладки, Shell может создать навигацию, аналогичную TabbedPage. Как показано
на рис. 5.4 в нижней панели вкладок на платформах Android и iOS есть две вкладки, но это выглядит
отличается на платформе Windows:
  
![изображение](https://user-images.githubusercontent.com/26972859/231792921-49ce98c4-cb02-4d7c-8b16-01d4e769e375.png)
  
Рисунок 5.4: TabBar и вкладки на Android
 
Как видно на рис. 5.5, в Windows панель вкладок находится вверху:  
  
![изображение](https://user-images.githubusercontent.com/26972859/231793147-763895be-c97b-44d0-bf4c-36c995732ea4.png)
  
 Рисунок 5.5: TabBar и вкладки в Windows
  
 Чтобы создать вкладки в нашем приложении, мы должны определить объект TabBar. Объект TabBar может содержать один или
больше объектов Tab, и каждый объект Tab представляет собой вкладку на панели вкладок. Каждый объект Tab может содержать
один или несколько объектов ShellContent. Следующий код XAML показывает, что он очень похож на
тот, который мы получаем, когда мы определяем всплывающее окно:

```xml
<Вкладка>
 <Tab Title="{x:Статические ресурсы:Ресурсы.
 action_id_login}" Icon="tab_login.png">
 <ShellContent Route="LoginPage" ContentTemplate=
 "{DataTemplate local:LoginPage}" />
 </таб>
 <Tab Title="{x:Статические ресурсы:Resources.menu_id_users}"
 Значок = "tab_users.png">
 <ShellContent Route="SignUpPage" ContentTemplate=
 "{DataTemplate local:SignUpPage}" />
 </таб>
</Вкладка>  
```
Точно так же, как мы делали это во всплывающем коде XAML, мы можем сделать предыдущий код немного проще,
удаление тегов Tab. Мы можем использовать неявные операторы преобразования Shell для удаления объектов Tab. Как
как мы видим, мы можем удалить теги Tab и определить атрибуты Title и Icon в тегах ShellContent:
  
```xml
<Вкладка>
 <ShellContent Title="{x:Статические ресурсы:Ресурсы.
 action_id_login}" Icon="tab_login.png"
 Route="LoginPage" ContentTemplate="{DataTemplate
 локальный: страница входа}" />
 <ShellContent Title="{x:Статические ресурсы:Ресурсы.
 menu_id_users}" Icon="tab_users.png"
 Route="SignUpPage" ContentTemplate="{DataTemplate
 местный:SignUpPage}" />
</Вкладка>  
```
Если мы определим как объекты TabBar, так и объекты FlyoutItem в AppShell.xaml, TabBar отключит
всплывающие элементы. Вот почему, когда мы запускаем наше приложение, мы видим экран с вкладками, показывающий
страницы входа или регистрации. После того, как пользователь успешно войдет в систему, мы можем привести его к RootPage, который
зарегистрированный маршрут в листинге 5.1. Мы научимся регистрировать маршруты и перемещаться с помощью зарегистрированных
маршруты в следующем разделе.
  
# Навигация по оболочке  
  
В Shell мы можем переходить на страницы через зарегистрированные маршруты. Существует два способа регистрации маршрутов.
Первый способ — зарегистрировать маршруты в визуальной иерархии Shell. Второй способ — зарегистрировать их явно
используя статический метод RegisterRoute() класса Routing.  

# Регистрация абсолютных маршрутов  

Мы можем зарегистрировать маршруты в визуальной иерархии Shell, как мы это сделали в листинге 5.1. Мы можем указать маршрут через
свойство Route объекта FlyoutItem, TabBar, Tab или ShellContent. В AppShell.xaml,
мы зарегистрировали следующие маршруты:  
  
|Маршрут|Страница|Описание|
|:----|:---|:----------|
|LoginPage|LoginPage|Этот маршрут отображает страницу для входа пользователя|
|SignUpPage|SignUpPage|Этот маршрут отображает страницу для регистрации пользователя|
|AboutPage|AboutPage|Этот маршрут отображает страницу о нашем приложении|
|RootPage|ItemsPage|Этот маршрут отображает страницу для навигации по базе паролей|  
  
 Таблица 5.1: Зарегистрированные маршруты в визуальной иерархии
  
 Чтобы перейти к маршруту в визуальной иерархии Shell, мы можем использовать абсолютный URI маршрута, например //
Страница авторизации.
  
# Регистрация относительных маршрутов  

Мы также можем перейти на страницу без предварительного определения ее в визуальной иерархии. Например, мы можем
перейдите на страницу сведений о пароле, ItemDetailPage, на любом уровне иерархии пароля
группы. В нашем приложении мы можем явно зарегистрировать следующие маршруты, используя RegisterRoute() в App.
xaml.cs:  

```Csharp
общедоступное приложение ()
{
 ИнициализироватьКомпонент();
 Routing.RegisterRoute(имя(ItemsPage),
 typeof(ItemsPage));
 Routing.RegisterRoute(имя(ItemDetailPage),
 typeof(ItemDetailPage));
 Routing.RegisterRoute(имя(NewItemPage),
 typeof(НоваяСтраницаЭлементов));
 DependencyService.Register<MockDataStore>();
 DependencyService.Register<UserService>();
 Главная страница = новый AppShell();
}
```
В предыдущем коде мы определили следующие маршруты:  
  
|Маршрут|Страница|Описание|
|:----|:---|:----------|
|ItemDetailPage|ItemDetailPage|Это маршрут для отображения сведений о вводе пароля|
|NewItemPage|NewItemPage|Это путь для добавления нового элемента (записи или группы)|
|ItemsPage|ItemsPage|Это маршрут для отображения страницы для навигации по базе данных паролей|  
  
Таблица 5.2: Маршруты зарегистрированных страниц сведений
  
Чтобы продемонстрировать, как использовать относительные маршруты, мы добавим новый элемент. Когда мы хотим добавить новый элемент,
мы можем перейти к NewItemPage, используя относительный маршрут, например:
  
```Csharp
await Shell.Current.GoToAsync(nameof(NewItemPage));  
```
В этом случае ищется маршрут NewItemPage и если маршрут найден, страница будет отображаться
и помещается в стек навигации. Стек навигации здесь такой же, как и при объяснении
базовая навигация с использованием интерфейса INavigation. Когда мы определяем относительный маршрут и перемещаемся
ему мы передаем строку как имя маршрута. Чтобы избежать опечаток, мы можем использовать имя класса в качестве маршрута.
name с помощью выражения nameof.
 
После того, как мы заполнили информацию о новом элементе в NewItemPage, мы можем нажать кнопку Сохранить
или кнопку Отмена. В обработчике событий кнопки «Сохранить» или «Отмена» мы можем вернуться к
предыдущую страницу, используя следующий код:
  
```ждите Shell.Current.Navigation.PopModalAsync();```

  В качестве альтернативы мы можем использовать следующий код:
 
```ждать Shell.Current.GoToAsync("..");```

Как видно из предыдущего кода, есть два способа вернуться назад. Первый использует
метод PopModalAsync() интерфейса INavigation. Поскольку сама Shell является производным
класса Page, он реализует интерфейс INavigation через унаследованный класс Navigation.
свойство. Мы можем вызвать модальный метод навигации PopModalAsync(), чтобы вернуться назад. Здесь,
NewItemPage — это модальная страница.  
  
Второй подход заключается в том, что мы можем использовать метод GoToAsync() для возврата назад. С
NewItemPage — это модальная страница, вам может быть интересно, как мы можем различать, является ли страница
является модальной страницей или нет, когда мы вызываем GoToAsync(). В навигации Shell это определяется через
режим представления страницы. Страница содержимого NewItemPage определяется следующим образом:  
  
```xml
<?xml версия="1.0" кодировка="UTF-8"?>
<ContentPage xmlns="http://schemas.microsoft.com
 /dotnet/2021/мауи"
 xmlns:x="http://schemas.microsoft.com
 /winfx/2009/xaml"
 x:Class="PassXYZ.Vault.Views.NewItemPage"
 Shell.PresentationMode="ModalAnimated" ➊
 Заголовок="Новый элемент">
 <ContentPage.Содержимое...>
</ContentPage >  
```

Как мы видим, свойство Shell.PresentationMode ➊ определено на странице содержимого.
В зависимости от того, хотим ли мы использовать анимацию, мы можем установить другое значение для этого свойства. Для
обычная страница контента, мы можем установить для нее значение NotAnimated или Animated. Для модальной страницы мы можем установить его на
Modal, ModalAnimated или ModalNotAnimated. Если мы используем значение по умолчанию, устанавливается Animated.
Чтобы вернуться назад, используется метод GoToAsync() с маршрутом, установленным на ... Это похоже на
механизм навигации по файловой системе или URL-адрес браузера. Относительный маршрут, .., означает навигацию
вернуться к родительскому маршруту. Его можно комбинировать с маршрутом для навигации по странице на родительском уровне, например:

```Csharp
await Shell.Current.GoToAsync("../AboutPage");
```
В Таблице 5.1 и Таблице 5.2 вы увидите, что ItemsPage зарегистрирован как абсолютный маршрут
RootPage и относительный маршрут ItemsPage. ItemsPage может содержать группы паролей в разных
уровни. На верхнем уровне это абсолютный маршрут, но это относительный маршрут на всех других уровнях навигационной иерархии.  
  
# Передача данных на страницы
  
Чтобы дополнительно объяснить, почему мы регистрируем ItemsPage как абсолютный, так и относительный маршруты, давайте рассмотрим
навигационная иерархия нашего приложения, как показано на рис. 5.6:  
  
![изображение](https://user-images.githubusercontent.com/26972859/231826996-3567f415-1b79-4335-b30e-22c9fb60fcee.png)
  
 Рисунок 5.6: Иерархия навигации
  
В нашем приложении после успешного входа на главной странице вверху отображается список записей и групп
уровне базы данных паролей, называемой корневой группой. Это похоже на навигацию по файловой системе.
В корне файловой системы отображается верхний уровень файлов и папок.
Первый экземпляр ItemsPage использует маршрут RootPage, к которому мы можем получить доступ через
всплывающий элемент. Предположим, что в корневой группе есть подгруппы с именами Group1 и Group2, как показано на рис.
Рисунок 5.6. Мы можем перейти к этим подгруппам, которые являются экземплярами ItemsPage. Эти случаи
ItemsPage не могут быть определены заранее, поскольку они являются относительными маршрутами и помещаются в стек навигации.
по требованию. Эти навигационные стеки могут быть такими же глубокими, как и фактические данные, хранящиеся в базе данных паролей.
Эти два разных маршрута ItemsPage определены в AppShell.xaml и App.xaml.cs.
вот так:
  
 1. Маршрут RootPage (абсолютный маршрут):
  
 ```xml
  <FlyoutItem x:Name="RootItem" Title="Обзор" Icon="tab_
дом.png">
 <ShellContent Route="RootPage" ContentTemplate=
 "{DataTemplate local:ItemsPage}" />
</ВылетающийЭлемент>
 ```
2. Маршрут ItemsPage (относительный маршрут):
  
```Routing.RegisterRoute(nameof(ItemsPage), typeof(ItemsPage));```  
  
Здесь вам может быть интересно, как мы можем перейти к Group1 или Group2 из корневой группы. Если страница элементов
может использоваться для отображения содержимого либо Group1, либо Group2, как мы можем сообщить ItemsPage, какой
группа для отображения?
  
В навигации Shell данные могут быть переданы на страницу содержимого через параметры запроса. Синтаксис
похоже на то, что мы передаем URL-адресу в веб-браузере. Например, мы можем использовать следующий URL
для поиска .net в поиске Google: https://www.google.com.hk/search?q=.net.
Это достигается добавлением ? после маршрута с парой идентификаторов параметров запроса и значением. в
предыдущем примере ключ — q, а значение — .net.
Когда элемент в списке корневых групп выбран, это может быть запись или группа. Событие клика
запускает метод OnItemSelection() в ItemsViewModel, как показано в листинге 5.2:
  
**Листинг 5.2: ItemsViewModel.cs (https://epa.ms/ItemsViewModel5-2)**  

```Csharp
используя PassXYZ.Vault.Views;
используя System.Collections.ObjectModel;
с помощью System.Diagnostics;
с помощью KPCLib;
используя PassXYZLib;
пространство имен PassXYZ.Vault.ViewModels;
[QueryProperty(имя(ItemId), имя(ItemId))] ➊
открытый класс ItemsViewModel: BaseViewModel {
 частный предмет? _selectedItem = по умолчанию;
 public ObservableCollection<Item> Items { get; }
 общественная команда LoadItemsCommand { получить; }
 общественная команда AddItemCommand { получить; }
 public Command<Item> ItemTapped { get; }
 общедоступная строка ItemId { ➋
 получать {
 вернуть _selectedItem == null? строка.Пусто:
 _selectedItem.Id;
 }
 набор {
 если (!string.IsNullOrEmpty(значение)) {
 var item = DataStore.GetItem (значение, правда);
 если (элемент != ноль) {
 _selectedItem = DataStore.CurrentGroup =
 DataStore.GetItem(значение, правда);
 }
 еще {
 бросить новое исключение ArgumentNullException("ItemId");
 }
 }
 еще {
 _selectedItem = ноль;
 DataStore.CurrentGroup = DataStore.RootGroup;
 }
 ВыполнитьКомандуЗагрузкиЭлементов();
 }
 }
 публичная модель ItemsViewModel()...
 ~ItemsViewModel()...
 общедоступная асинхронная задача ExecuteLoadItemsCommand()...
 async public void OnAppearing()...
 публичный предмет? ВыбранныйЭлемент...
 private async void OnAddItem (object obj)...
 public async void OnItemSelected (элемент элемента) {
 если (элемент == ноль) вернуть;
 если (элемент.IsGroup) {
 ожидание Shell.Current.GoToAsync
 ($"{имя(ItemsPage)}?
 {nameof(ItemsViewModel.ItemId)}={item.Id}"); ➌
 }
 еще {
 ожидание Shell.Current.GoToAsync
 ($"{имя(ItemDetailPage)}?
 {nameof(ItemDetailViewModel.ItemId)}={item.Id}");➍
 }
 }
}
```
В зависимости от типа элемента мы можем перейти к ItemsPage ➌ или ItemDetailPage ➍. В обоих случаях
случаях мы передаем элемент Id в параметр запроса ItemId, который определен как в ItemsViewModel,
и ItemDetailViewModel.
В листинге 5.2 ➊ ItemId определен в ItemsViewModel как атрибут QueryPropertyAttribute.
атрибут. Первый аргумент QueryPropertyAttribute — это имя свойства, которое будет
получить данные. В данном случае это ItemId ➋.
Второй аргумент — это параметр id. Когда мы выбираем группу из списка, модель представления
Вызывается метод OnItemSelected() ➌ и идентификатор элемента выбранной группы передается в качестве
значение параметра запроса ItemId.
Когда ItemsPage загружается с параметром запроса ItemId, устанавливается свойство ItemId ➋.
В сеттере свойства ItemId проверяем, не пусто ли значение параметра запроса. Если оно
пуст, это может быть первый раз, когда мы переходим к маршруту RootPage без параметра запроса.
В этом случае мы устанавливаем для CurrentGroup службы данных значение RootGroup. Если он не пуст, мы будем
найдите элемент и установите его в CurrentGroup. Содержимое CurrentGroup загружается с помощью
Метод ВыполнитьКомандуЗагрузкиЭлементов().
➍ Если мы выберем запись из списка, мы можем перейти к ItemDetailPage с идентификатором элемента как
значение параметра запроса. Мы можем изменить ItemDetailViewModel таким образом, чтобы справиться с этим.
параметр запроса:  
  
```Csharp
публичная строка? Идентификатор товара { ①
 получать {
 вернуть itemId;
 }
 набор {
 если (значение == ноль) генерировать новое исключение ArgumentNullException
 (имя(значение));
 идентификатор элемента = значение;
 ЗагрузитьItemId(значение); ②
 }
}
общедоступная модель ItemDetailViewModel () {
Поля = новый ObservableCollection<Field>();
 идентификатор = по умолчанию;
}
public async void LoadItemId (string itemId) {
 пытаться {
 var item = await DataStore.GetItemAsync(itemId); ③
 если (элемент == ноль) {
 бросить новое исключение ArgumentNullException (имя (ItemId));
 }
 Идентификатор = элемент.Идентификатор;
 Заголовок = элемент.Имя;
 Описание = элемент.Описание;
 PwEntry dataEntry = (PwEntry)элемент; ④
 Поля.Очистить();
 List<Field> fields = dataEntry.GetFields(GetImage:
 Иконки поля.ПолучитьИзображение); ⑤
 foreach (поле поля в полях) {
 Поля.Добавить(поле);
 }
 }
 поймать (исключение) {
 Debug.WriteLine("Не удалось загрузить элемент");
 }
}
```
В классе ItemDetailViewModel у нас есть следующее:
• ItemId ① — это свойство, которое получает параметр запроса.
• В установщике ItemId мы вызываем метод LoadItemId() ② для загрузки элемента.
• В LoadItemId() мы можем вызвать метод службы данных GetItemAsync() ③, чтобы получить
элемент, используя идентификатор элемента.
• Здесь элемент является экземпляром PwEntry ④, поэтому мы можем преобразовать его как PwEntry.
• У нас есть метод расширения под названием GetFields()⑤ в PassXYZLib. Мы используем этот метод
для обновления списка полей.

В последних двух разделах мы узнали об основах навигации и навигации в оболочке. Мы также улучшили
наш дизайн навигации с помощью Shell. Теперь пришло время просмотреть шаблон MVVM и уточнить наши данные.
модель снова, чтобы сделать наше приложение диспетчера паролей лучше.
  
# Улучшаем нашу модель  
  
Мы изучили варианты использования и создали некоторые из них в главе 4 «Изучение MVVM и привязки данных».
раздел, мы усовершенствуем существующие варианты использования и реализуем новые варианты использования, используя знания, которые
мы узнали.
Мы будем работать над следующими вариантами использования.
Пример использования 1. Как пользователь диспетчера паролей я хочу войти в приложение диспетчера паролей, чтобы я мог
получить доступ к моим данным пароля.
Для этого варианта использования мы еще не полностью реализовали вход пользователя; мы завершим это в следующем
глава. В этой главе мы реализуем некоторую псевдологику, включающую все, кроме
слой данных.
В главе 4 «Изучение MVVM и привязки данных» у нас есть следующий вариант использования, который может поддерживать
один уровень навигации.
Вариант использования 3: как пользователь менеджера паролей я хочу видеть список групп и записей, чтобы я мог исследовать
данные моего пароля.
Для поддержки нескольких уровней навигации в этом разделе мы реализуем следующий вариант использования.
Пример использования 6: Как пользователь менеджера паролей, когда я щелкаю группу в текущем списке, я хочу увидеть
группы и записи, принадлежащие этой группе.
Вариант использования 7: как пользователь менеджера паролей, когда я просматриваю свои данные пароля, я хочу вернуться назад
к предыдущей группе или родительской группе.
В вариантах использования 6 и 7 мы хотим перемещаться вперед или назад, используя относительные маршруты.
В шаблоне MVVM мы получаем доступ к нашей модели через сервисы. Эти услуги обычно абстрагируются
как интерфейсы, чтобы они были отделены от фактической реализации. Интерфейс IDataStore
один из них. Для поддержки варианта использования 6 и улучшения варианта использования 1 нам нужно создать новый интерфейс с именем
IUserService для поддержки входа пользователя.  
  
# Понимание модели данных и ее сервисов
  
Чтобы понять сервисы и расширенную модель, давайте рассмотрим расширенный дизайн на рис. 5.7:  
  
![изображение](https://user-images.githubusercontent.com/26972859/231827995-9736dfda-048e-450b-b41f-0945214e3fb1.png)
  
 Рисунок 5.7: Модель и сервис в MVVM
  
На рис. 5.7 представлена ​​диаграмма классов, на которой изображена большая часть нашей разработки в шаблоне MVVM. Мы можем прочитать это
диаграмма классов вместе со следующей таблицей, чтобы понять шаблон MVVM в нашем приложении. Для
простота, я не включил все. Например, вы можете добавить NewItemPage или SignUpPage.
к Рисунку 5.7 и Таблице 5.3 самостоятельно:
  
![изображение](https://user-images.githubusercontent.com/26972859/231828127-ce91a80e-7fb1-485e-9a16-0756d9e795de.png)
  
 Таблица 5.3: Классы и интерфейсы в шаблоне MVVM
  
Для хранения данных приложения мы обычно храним данные в базе данных, которая может быть реляционной или
База данных NoSQL. В нашем случае наша база паролей не является реляционной базой данных. Однако, когда мы
работать над нашим дизайном, мы все еще можем использовать аналогичную логику реляционных баз данных для проектирования нашего бизнеса
логика. У нас есть три класса для представления нашей модели — User, Item и Field.
Item и Field используются для представления ввода пароля и содержимого записи. Мы можем представить
что запись выглядит как строка в таблице, а поле похоже на ячейку. Мы используем PwEntry в
KeePassLib для моделирования ввода пароля. Список записей представляет собой группу, и мы используем PwGroup для моделирования
группа. Здесь группа аналогична таблице в базе данных. Поля с одинаковыми ключевыми значениями в группе
похожи на колонну. Для разработки интерфейса наших служб данных мы можем использовать аналогичную стратегию.
обрабатывать данные в нашей базе данных.
Как мы обрабатываем данные в базе данных? Возможно, вы слышали об операциях CRUD. В нашем случае мы
можно использовать расширенные операции Create, Read, Update, Delete и List (CRUDL) для определения
интерфейс нашего сервиса.
Для обработки записей паролей и групп мы можем использовать интерфейс IDataStore:  
  
```Csharp
открытый интерфейс IDataStore<T>
{
 Т? GetItem(идентификатор строки, bool SearchRecursive = false);
 Task<T?> GetItemAsync(string id, bool SearchRecursive =
 ЛОЖЬ);
 Задача AddItemAsync (элемент T);
 Задача UpdateItemAsync (элемент T);
 Task<bool> DeleteItemAsync(идентификатор строки);
 Задача<IEnumerable<T>> GetItemsAsync(bool forceRefresh =
 ЛОЖЬ);
}
```

  В интерфейсе IDataStore мы определяем следующие операции CRUDL:

  * Создать: мы используем AddItemAsync() для добавления записи или группы

  * Чтение: мы используем GetItem() или GetItemAsync() для чтения записи или группы.

  * Обновление: мы используем UpdateItemAsync() для обновления записи или группы.

  * Удалить: мы используем DeleteItemAsync() для удаления записи или группы.

  * Список: мы используем GetItemsAsync() для получения списка записей и групп в текущей группе.  
  
 Для обработки пользователей мы можем использовать интерфейс IUserService:
  
```Csharp
открытый интерфейс IUserService<T>
{
 T GetUser(имя пользователя в виде строки);
 Задача AddUserAsync(T пользователь);
 Задача UpdateUserAsync(T пользователь);
 Задача DeleteUserAsync(T пользователь);
 Список<строка> GetUsersList();
 Task<bool> LoginAsync(T user);
 недействительный Выход();
}  
```

Мы также можем определить набор операций CRUDL для обработки пользователей:

  * Создать: мы можем создать нового пользователя, используя AddUserAsync().

  * Читать: мы можем получить информацию о пользователе, используя GetUser()

  * Обновление: мы можем обновить пользователя с помощью UpdateUserAsync().

  * Удалить: мы можем удалить пользователя с помощью DeleteUserAsync().

  * Список: мы можем получить список пользователей, используя GetUsersList().

  * Вход и выход: мы можем войти или выйти из системы, используя экземпляр User

  Чтобы еще больше разделить зависимость модели и службы, мы можем использовать универсальные типы в интерфейсе.
определение вместо конкретных типов. Мы используем эти сервисы в наших моделях представления для управления нашими моделями. К
повысить эффективность нашего кода, мы будем инициализировать службу IDataStore в BaseViewModel
чтобы они были автоматически доступны во всех производных моделях представлений:  
  
```Csharp
открытый класс BaseViewModel: INotifyPropertyChanged {
 общедоступный статический IDataStore<Item> DataStore =>
 DependencyService.Get<IDataStore<Item>>();
 логическое значение занято = ложь;
 общедоступный логический элемент IsBusy...
 заголовок строки = строка.пусто;
 общедоступная строка Заголовок...
 ...
}
```
В классе BaseViewModel мы инициализируем службу IDataStore через службу зависимостей.
Мы объясним службы зависимостей и внедрение зависимостей в следующей главе.  
  
# Улучшение процесса входа в систему  
  
Для управления пользователями мы можем добавлять новых пользователей или удалять устаревших пользователей в системе. У нас есть только
один пользователь, который может войти в наше приложение за раз, поэтому мы должны определить одноэлементный класс с именем LoginUser
для моделирования этого случая:
  
**Листинг 5.3: LoginUser.cs (https://epa.ms/LoginUser5-3)**  
  
```Csharp
с помощью System.Diagnostics;
используя PassXYZLib;
пространство имен PassXYZ.Vault.Services;
открытый класс LoginUser : PxUser
{
 private const string PrivacyNotice = "Уведомление о конфиденциальности";
 public static bool IsPrivacyNoticeAccepted...
 частное логическое значение _isFingerprintEnabled = false;
 общественное логическое значение IsFingerprintEnabled =>
 _isFingerprintEnabled;
 общедоступный статический IUserService<User> UserService =>
 DependencyService.Get<IUserService<User>>(); ➊
 публичное переопределение недействительным выходом () {
 UserService.Выход();
 }
 общедоступная асинхронная задача<string> GetSecurityAsync()...
 общедоступная асинхронная задача SetSecurityAsync (string passwd)...
 общедоступная асинхронная задача<bool> DisableSecurityAsync()...
 приватный LoginUser() { } ➋
 частный статический LoginUser? экземпляр = ноль;
 общедоступный статический экземпляр LoginUser { ➌
 получать {
 если (экземпляр == ноль) { экземпляр = новый
 ЛогинПользователь(); }
 вернуть экземпляр;
 }
 } } }
}
```
LoginUser наследуется от класса User через подкласс PxUser.
➊ В LoginUser мы инициализируем интерфейс IUserService через службу зависимостей.
➋ Чтобы реализовать одноэлементный класс, мы делаем конструктор по умолчанию закрытым, чтобы запретить создание
этот класс с помощью нового оператора.
➌ Чтобы получить экземпляр LoginUser, мы должны определить статическое свойство Instance. Пожалуйста, будьте осторожны
что я решил использовать здесь реализацию без многопоточности, чтобы сделать код простым. В производстве
реализации, мы должны использовать блокировку, чтобы сделать его потокобезопасным.
Как только мы реализовали интерфейс IUserService и класс LoginUser, мы можем улучшить
процесс входа в систему. Пока у нас есть только одна кнопка на странице входа. Давайте добавим поле имени пользователя и
поле пароля для LoginPage.xam, как показано в листинге 5.4:  
  
**Листинг 5.4: LoginPage.xaml (https://epa.ms/LoginPage5-4)**

```xml
<?xml версия="1.0" кодировка="utf-8" ?>
<Страница содержания...>
 <ContentPage.Content>
 <StackLayout Padding="30" Spacing="10">
 <Image HorizontalOptions="Центр"
 ВысотаЗапрос="96"...>
 <Label FontSize="Маленький".../>
 <поле кадра="10">
 <Grid x:DataType="viewmodels:LoginViewModel"...> ➊
 <Grid.RowDefinitions...>
 <Grid.ColumnDefinitions...>
 <!-- Строка 1 (имя пользователя) -->
 <Изображение Grid.Row="0" Grid.Column="0"...>
 <Entry x:Name="usernameEntry" Placeholder="{x:Static
ресурсы: Ресурсы.
 field_id_username}" ReturnType="Далее" Text="{Привязка
 CurrentUser.Username}" HorizontalOptions="Заполнить"
 Grid.Row="0" Grid.Column="1" /> ➋
 <ImageButton x:Name="switchUsersButton"...>
 <!-- Строка 2 (Пароль) -->
 <Изображение Grid.Row="1" Grid.Column="0"...>
 <Entry x:Name="passwordEntry" Placeholder="{x:Static
 ресурсы: Ресурсы.
 field_id_password}" IsPassword="true" Text="{Привязка
 CurrentUser.Password}" HorizontalOptions="Заполнить"
 Grid.Row="1" Grid.Column="1" /> ➌
 <!-- Строка 3 (индикатор активности) -->
 <ActivityIndicator IsRunning="{Binding IsBusy}"
 Grid.Row="2" Grid.Column="1" IsVisible="{Привязка
 Занято}" /> ➍
 <!-- Строка 4 (Кнопка входа) -->
 <Button Text="{x:Статические ресурсы:Ресурсы.
 LoginPageTitle}" HorizontalOptions=
 "CenterAndExpand" Command="{Привязка
 LoginCommand}" Grid.Row="3" Grid.Column="1" /> ❺
 </сетка>
 </Рамка>
 <Ярлык x:Name="messageLabel" />
 </СтекМакет>
 </ContentPage.Content>
</ContentPage>
```
В этом новом дизайне пользовательского интерфейса мы сделали следующее:
  
   * ➊ Мы создали макет сетки 4x3 в кадре.

   * В первых двух строках мы использовали два экземпляра Entry для хранения имени пользователя ➋ и пароля.

   * ➌. Мы создали привязку данных между текстовыми полями Entry и свойствами CurrentUser, которые определены в модели представления. Это объект LoginUser.

   * ➍ В третьей строке мы использовали элемент управления ActivityIndicator для отображения статуса входа в систему,
который привязан к свойству IsBusy модели представления.

   * ➎ В последней строке мы определили элемент управления Button для входа в систему. Есть команда
свойство, определенное в Button, которое реализует интерфейс ICommand. Мы использовали привязку данных
чтобы связать это свойство Command с методом в модели представления для выполнения действия входа в систему.
Мы можем видеть улучшенный пользовательский интерфейс входа в систему на рис. 5.8:
  
![изображение](https://user-images.githubusercontent.com/26972859/231829440-dd737dd2-9f5d-4702-a2ea-4faa14828dc7.png)
  
 Рисунок 5.8: Страница входа
  

 # Командный интерфейс
  
Без поддержки свойства Command мы должны создать обработчик события Clicked в
файл кода программной части LoginPage. В обработчике события мы вызываем метод, определенный в модели представления
который вызывает LoginAsync() в IUserService для обработки активности входа. Использование команды
свойство, мы можем напрямую привязаться к свойству LoginCommand в модели представления, поэтому нам не нужно
создайте обработчик событий в файле кода программной части LoginPage. Код выглядит чище и проще.  
  
Давайте рассмотрим улучшенный файл LoginViewModel.cs, чтобы узнать больше деталей:  
  
** Листинг 5.5: LoginViewModel.cs (https://epa.ms/LoginViewModel5-5)**  
  
```Csharp
открытый класс LoginViewModel: BaseViewModel
{
 только для чтения IUserService<User> userService = LoginUser.
Пользовательская служба;
 частное действие<string> _signUpAction;
 публичная команда LoginCommand { получить; }
 публичная команда SignUpCommand { получить; }
 публичная команда CancelCommand { получить; }
 public LoginUser CurrentUser => LoginUser.Instance;
 общедоступная ObservableCollection<пользователь>? Пользователи...
 публичный LoginViewModel () {
 LoginCommand = новая команда (OnLoginClicked,
 Подтвердить логин); ➊
 SignUpCommand = новая команда (OnSignUpClicked,
 Подтвердить регистрацию);
 CancelCommand = новая команда (OnCancelClicked);
 CurrentUser.PropertyChanged +=
 (_, __) => LoginCommand.ChangeCanExecute(); ➋
 CurrentUser.PropertyChanged +=
 (_, __) => SignUpCommand.ChangeCanExecute();
 }
 public LoginViewModel (Action<string> signUpAction) ...
 частное логическое значение ValidateLogin() { ➌
 вернуть !string.IsNullOrWhiteSpace(CurrentUser.Username)
 && !string.IsNullOrWhiteSpace(CurrentUser.Password);
 }
 частное логическое значение ValidateSignUp() ...
 public void OnAppearing() ...
 общедоступный асинхронный недействительный OnLoginClicked () {
 пытаться {
 Занято = Истина;
 если (строка.IsNullOrWhiteSpace
 (ТекущийПользователь.Пароль))...
 логический статус = ожидание userService.LoginAsync
 (Текущий пользователь); ➍
 если (статус) {
 если (AppShell.CurrentAppShell!= ноль) {
 AppShell.CurrentAppShell.SetRootPageTitle
 (Хранилище Данных.КорневаяГруппа.Имя);
 строковый путь = Path.Combine
 (PxDataFile.TmpFilePath,
 ТекущийПользователь.ИмяФайла);
 если (Файл.Существует(путь))...
 await Shell.Current.GoToAsync($"//RootPage");
 }
 еще {
 бросить (новое исключение NullReferenceException
 ("CurrentAppShell имеет значение null"));
 }
 }
 Занято = Ложь;
 }
 поймать (Исключение ex) {
 Занято = Ложь;
 строка msg = ex.Message;
 если (например, System.IO.IOException ioException) {
 msg = Свойства.Ресурсы.сообщение_
 id_recover_datafile;
 }
 Ожидание Shell.Current.DisplayAlert
 (Properties.Resources.LoginErrorMessage, msg,
 Свойства.Ресурсы.alert_id_ok);
 }
 }
}
```
В LoginViewModel (листинг 5.5) мы определили несколько свойств команды. Давайте посмотрим на LoginCommand
чтобы понять, как использовать интерфейс ICommand.  
  
В .NET MAUI класс Command определяется так:

```Csharp
Команда открытого класса: System.Windows.Input.ICommand
```   
➊ Мы используем следующий конструктор для инициализации LoginCommand:   
   
```Csharp
общедоступная команда (выполнение действия, Func<bool> canExecute);
```
Параметр execute, относящийся к типу Action, представляет собой действие, которое необходимо вызвать. Здесь
Присваивается метод OnLoginClicked(). Когда пользователь нажмет кнопку, она будет выполнена.
Мы также назначили еще один метод ValidateLogin()➌ параметру canExecute. Этот
Параметр используется, чтобы указать, может ли эта команда быть выполнена. В ValidateLogin()
метод, мы проверяем, является ли имя пользователя или пароль в CurrentUser пустым. Если кто-то из них
пусто, эта команда не может быть выполнена, и кнопка должна быть недоступна.
Чтобы обнаружить изменение имени пользователя или пароля, мы можем зарегистрировать ChangeCanExecute() в
Обработчик PropertyChanged ➋.
После нажатия пользователем кнопки вызывается метод OnLoginClicked(). В этом методе мы передаем
CurrentUser в LoginAsync()➍ метода IUserService для обработки процесса входа в систему.
На данный момент мы улучшили нашу модель и сервис, чтобы улучшить процесс входа в систему. Если мы вспомним о
диаграмме классов на рис. 5.7 мы изменили исходный код в представлении, модели представления и сервисе.
слои для улучшения нашего приложения. Фактическая модель инкапсулирована в две библиотеки, называемые KPCLib и
PassXYZLib. Мы представили функциональные возможности этих двух библиотек через IdataStore и
Интерфейсы IuserService. Мы улучшили нашу модель, создав фактические классы реализации.
из этих двух интерфейсов. В следующей главе мы продолжим улучшать эти два сервисных интерфейса.
и создайте полнофункциональное приложение.   
   
# Краткое содержание

   В этой главе мы узнали об основах навигации и Shell. Мы использовали Shell в качестве навигации
framework в дизайне нашего приложения. Мы изучили возможности Shell и объяснили, как использовать ее в нашей
дизайн приложения.
После того, как мы завершили большую часть дизайна пользовательского интерфейса, мы улучшили нашу модель, внеся изменения в
два сервисных интерфейса: IDataStore и IUserService. Мы улучшили процесс входа после
внесение изменений в представление, модель представления и слои обслуживания. На сервисном уровне мы по-прежнему используем
Класс MockDataStore. Однако мы не завершили реализацию в IDataStore.
service для выполнения фактических действий по входу в систему. Мы оставим это до следующей главы.   
В следующей главе мы объясним внедрение зависимостей в .NET MAUI, что является основным отличием.
по сравнению с Xamarin.Forms. Мы узнаем, как регистрировать наши сервисы с помощью внедрения зависимостей и
как инициализировать наш сервис с помощью внедрения конструктора или внедрения свойств. Мы также создадим
фактический сервис для замены MockDataStore.   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
  
  
  
  
  
  
  
  

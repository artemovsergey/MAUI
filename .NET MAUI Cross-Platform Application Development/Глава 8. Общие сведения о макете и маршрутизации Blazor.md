# Общие сведения о макете и маршрутизации Blazor

В последней главе мы узнали, как создать страницу входа в систему с помощью Blazor. Внешний вид приложения и навигация
иерархия по-прежнему основана на XAML. В нашем приложении используется смешанная реализация пользовательского интерфейса Blazor и XAML.
Blazor — это другой выбор дизайна пользовательского интерфейса для приложения .NET MAUI. В этой (второй) части книги мы
перестройте весь пользовательский интерфейс с помощью Blazor. Первый шаг дизайна пользовательского интерфейса обычно начинается с реализации
макета и навигации, поэтому в этой главе мы познакомимся с макетом и маршрутизацией Blazor.

В этой главе мы рассмотрим следующие темы:

* Маршрутизация Blazor

* Использование компонентов макета Blazor

# Технические требования

Для тестирования и отладки исходного кода в этой главе вам необходимо установить Visual Studio 2022 на
ваш ПК или Mac. Пожалуйста, обратитесь к настройке среды разработки в Главе 1, Начало работы с
.NET MAUI, для получения подробной информации.


Исходный код для этой главы доступен в следующем репозитории GitHub:

https://github.com/PacktPublishing/.NET-MAUI-Cross-PlatformApplication-Development/tree/main/Chapter08

Исходный код можно загрузить с помощью следующей команды Git:

```
git clone -b Chapter08 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development PassXYZ.Vault2
```

# Понимание маршрутизации на стороне клиента

Маршрутизация и макет Blazor аналогичны концепции Shell и навигации в мире XAML.
В Главе 5, Навигация с использованием .NET MAUI Shell и NavigationPage, когда мы представили навигацию
и Shell, мы обсудили стратегию маршрутизации Shell. Shell обеспечивает навигацию на основе URI.
который использует маршруты для перехода к выбранным страницам. Маршрутизация Blazor очень похожа на это.
Маршрутизация Blazor позволяет переключаться с одной страницы Razor на другую. Оказание
Страницы Razor в BlazorWebView аналогичны веб-приложениям, работающим в браузере.
В классическом веб-приложении, когда мы загружаем HTML-страницу в браузер, HTML-страница извлекается.
с веб-сервера. Когда мы выбираем другой маршрут, мы загружаем новую страницу с сервера. Для
Одностраничные приложения (SPA) работают немного по-другому.
Приложения Blazor WebAssembly — это SPA. Когда приложение запускается, оно загружается в браузере. После этого,
навигация по страницам происходит только на стороне клиента. Это так называемая клиентская маршрутизация. Блейзор
Гибридные приложения также используют маршрутизацию на стороне клиента.

# Настройка BlazorWebView

Для выполнения маршрутизации на стороне клиента маршрутизатор должен быть установлен при запуске приложения. В .NET МАУИ
приложения, точка входа XAML и Blazor настраивается в App.xaml.cs. Мы можем обратиться к изменению
App.xaml.cs здесь (в коде), чтобы переключить реализацию пользовательского интерфейса с XAML на Blazor.
Приложение Blazor Hybrid работает внутри BlazorWebView. Чтобы запустить приложение Blazor Hybrid, нам нужно
сначала настройте экземпляр BlazorWebView. В предыдущей главе мы настроили его в LoginPage, и мы
вернулся в Shell после успешного входа в систему.
Чтобы настроить экземпляр BlazorWebView для всего приложения, нам нужно заменить экземпляр
присваивается свойству MainPage класса App. Для этого мы изменили конструктор
Класс приложения (в App.xaml.cs) выглядит следующим образом:

```Csharp
общедоступное приложение ()
{
 ИнициализироватьКомпонент();
#if MAUI_BLAZOR
 Главная страница = новая главная страница(); ❶
#еще
 Routing.RegisterRoute(имя(ItemsPage),
 typeof(ItemsPage));
 Routing.RegisterRoute(имя(ItemDetailPage),
 typeof(ItemDetailPage));
 Routing.RegisterRoute(имя(NewItemPage),
 typeof(НоваяСтраницаЭлементов));
 Главная страница = новый AppShell();
#endif
}
```
❶ Мы можем определить символ MAUI_BLAZOR, чтобы настроить условную компиляцию, чтобы мы могли
между XAML и пользовательским интерфейсом Blazor в сборке. Чтобы использовать пользовательский интерфейс Blazor, мы устанавливаем для свойства MainPage значение
Экземпляр главной страницы. В классе MainPage мы определяем элемент управления BlazorWebView следующим образом:

```xml
<BlazorWebView HostPage="wwwroot/index.html">
 <BlazorWebView.RootComponents>
 <RootComponent Selector="#app" ComponentType="{x:Type
 местный:главный}" />
 </BlazorWebView.RootComponents>
</BlazorWebView>
```
В BlazorWebView он загружает HTML-страницу (index.html), чтобы начать настройку пользовательского интерфейса Blazor. Давайте посмотрим
как работает настройка маршрутизатора.

# Настройка роутера

Пользовательский интерфейс Blazor — это дизайн пользовательского интерфейса на основе HTML-страницы. Он похож на SPA и начинается со статического HTML.
страница. В BlazorWebView загружаемой страницей HTML является index.html, что очень похоже на
страницу login.html, которую мы представили в предыдущей главе. Компонент Razor верхнего уровня, который
загружается в RootComponent — это основной компонент, который мы можем видеть здесь:

**Листинг 8.1: Main.razor (https://epa.ms/Main8-1)**

```xml
<маршрутизатор AppAssembly="@typeof(Main).Assembly"> ①
 <Найдено Context="routeData"> ②
 <RouteView RouteData="@routeData"
 DefaultLayout="@typeof(MainLayout)" />
 <FocusOnNavigate RouteData="@routeData" Selector="h1" />
 </Найдено>
 <Не найдено> ③
 <LayoutView Layout="@typeof(MainLayout)">
 <p role="alert">Извините, здесь ничего нет
 адрес.</p>
 </LayoutView>
 </Не найдено>
</маршрутизатор>
```
Как видно из листинга 8.1, мы настроили компонент маршрутизатора ① в файле Main.razor.
В компоненте Router он использует отражение для сканирования всех компонентов страницы для построения таблицы маршрутизации.

Параметр AppAssembly указывает сборки для сканирования.

Если есть событие навигации, маршрутизатор проверяет таблицу маршрутизации на наличие соответствующего маршрута. Маршрутизатор
компонент является шаблонным компонентом. Мы обсудим, что такое шаблонный компонент, позже.
глава. Когда маршрут найден, используется шаблон Found. В противном случае шаблон NotFound
используется, когда нет соответствующих маршрутов.

Шаблон Found, ②, использует компонент RouteView для отображения выбранного компонента с его
макет. Макет указывается в атрибуте DefaultLayout. Планировку обсудим в
следующий раздел. Новая загружаемая страница вместе с любыми параметрами маршрута передается с использованием экземпляра
класса RouteData.

Если совпадение найти не удалось, отображается шаблон NotFound, ③. Шаблон не найден
использует компонент LayoutView для отображения сообщений об ошибках. Макет, используемый LayoutView,
указывается с помощью атрибута Layout.

# Определение маршрутов

После настройки маршрутизатора мы можем создавать страницы и определять шаблоны маршрутов на страницах. Маршрутизатор
будет сканировать шаблоны маршрутов, определенные на страницах, для построения таблицы маршрутизации.
На высоком уровне мы можем создать навигационную иерархию и шаблоны маршрутов нашего приложения, обращаясь к рисунку 8.1.

![изображение](https://user-images.githubusercontent.com/26972859/231964172-912c7d9f-9933-4094-a550-7b32ed2cb1c8.png)

Рисунок 8.1: Иерархия навигации по страницам Razor

Мы перечислили основные страницы нашего приложения на рис. 8.1. Каждая страница имеет имя, которое также является именем класса.
страницы Razor. Путь под именем является шаблоном маршрута. Например, для страницы «О программе»
мы можем объявить шаблон маршрута следующим образом:

```
@страница "/о нас"
```
Директива @page состоит из двух частей: имени директивы и шаблона маршрута. В этом примере
шаблон маршрута — «/about», который должен быть заключен в кавычки и всегда начинается с косой черты (/).
Поскольку конечным результатом страницы Razor является HTML-страница, мы можем перейти на страницу Razor точно так же, как
веб-страница с тегом привязки <a>, как показано здесь:

```
<a href="/about">О нас</a>
```

## Передача данных с использованием параметров маршрута

Когда мы переходим на страницу с помощью шаблона маршрута, мы можем передавать данные на страницу с помощью параметров маршрута.
Если мы вспомним, как передавать данные с параметром запроса в Shell, использование параметра маршрута
аналогично параметру запроса.

Как видно на рис. 8.1, после успешного входа в систему отображается страница «Элементы» и список элементов.
в корневой группе отображается как на рисунке 8.2. На этой странице, если мы нажмем на элемент, мы сможем перейти
к выбранному элементу в зависимости от типа элемента. Чтобы найти выбранный элемент, значение идентификатора элемента передается в
новая страница в качестве параметра.

![изображение](https://user-images.githubusercontent.com/26972859/231964651-0375bb82-2280-4c42-a75e-b7741dcaa54e.png)

Рисунок 8.2: Страница элементов в приложении Blazor Hybrid

На странице Items у нас определены следующие шаблоны маршрутов:

```
@страница "/группа"
@page "/group/{SelectedItemId}"  
```
Первый шаблон маршрута используется, когда мы отображаем корневую страницу. Второй используется, когда мы выбираем
группа. Значение идентификатора группы передается на страницу «Элементы» с помощью параметра маршрута SelectedItemId.
Чтобы указать тип параметра маршрута, мы можем добавить к нему ограничения с типом данных, как показано здесь:

@page "/user/{Id:int}"

В директиве предыдущей страницы мы указываем тип данных Id как целое число. Пожалуйста, обратитесь к
соответствующие документы Microsoft, чтобы найти более подробную информацию об ограничениях маршрута. Вы можете найти
соответствующий документ здесь:

https://learn.microsoft.com/en-us/aspnet/core/blazor/fundamentals/
маршрутизация? представление = aspnetcore-6.0 # маршрут-ограничения

# Навигация с помощью NavigationManager

На странице Razor, хотя обычно мы можем перейти на другую страницу с помощью тега привязки <a>,
иногда нам может понадобиться сделать это с помощью кода. Например, когда мы обрабатываем событие, мы можем перенаправить
на страницу в обработчике событий. Именно так обстоит дело на нашей странице входа. Давайте посмотрим, как ориентироваться
на страницу «Элементы» с помощью NavigationManager после успешного входа в систему.
В нашем приложении нам нужно перенаправить на страницу «Элементы», чтобы отобразить корневую группу после входа в систему. Пользовательский интерфейс
Страница входа такая же, как и в предыдущей главе, но мы изменили дескриптор события в Login.
razor.cs на следующий:

```Csharp
пространство имен PassXYZ.Vault.Pages;
публичный частичный класс Login: ComponentBase {
 [Ввести]
 частный IUserService<User> userService { получить; набор; "="
 по умолчанию!;
 [Ввести]
 частный IDataStore<Item> dataStore { get; набор; "="
 по умолчанию!;
 [Ввести]
 частный NavigationManager navigationManager {получить; установить;} ❶
 private LoginUser currentUser => LoginUser.Instance;
 частный асинхронный недействительный OnLogin (MouseEventArgs e) {
 логический статус = ожидание userService.LoginAsync
 (текущий пользователь);
 если (статус) {
 строка path = Path.Combine(PxDataFile.TmpFilePath,
 текущийПользователь.ИмяФайла);
 если (Файл.Существует(путь)) {
 логический результат = ожидание dataStore.MergeAsync (путь);
 }
 navigationManager.NavigateTo ("/ группа"); ❷
 }
 }
}
```
❶ Мы получаем экземпляр NavigationManager, используя внедрение зависимостей.
❷ Мы вызываем метод NavigateTo("/group") класса NavigationManager, чтобы перейти к
Страница предметов.
В этом разделе мы узнали, как использовать маршрутизацию и навигацию. На следующем шаге мы можем реализовать
иерархия навигации похожа на ту, что мы делали с навигацией Shell с пользовательским интерфейсом Blazor.
Верхний уровень иерархии навигации HTML-страницы включает заголовок, панель инструментов, меню и нижний колонтитул.
Мы можем реализовать макет с помощью компонента макета Blazor. Это что-то похожее на вылет
и элементы меню в оболочке, которые мы представили в главе 5 «Навигация с использованием оболочки .NET MAUI».
и Страница навигации.

# Использование компонентов макета Blazor

Большинство веб-страниц обычно содержат фиксированные части, такие как верхний и нижний колонтитулы или меню. Мы можем оформить страницу
использование макета вместе с содержимым страницы для уменьшения избыточного кода. Сама страница содержит
контент, который мы хотим показать пользователям, и макет помогает создавать стили и предоставлять
методы навигации.
Компоненты макета Blazor — это класс, производный от LayoutComponentBase. Все, что мы можем сделать
с обычным компонентом Razor мы можем сделать это и с компонентами макета.
В листинге 8.1 мы видим, что MainLayout используется в качестве макета страниц по умолчанию. Это определено
в листинге 8.2 здесь:

**Листинг 8.2: MainLayout.razor (https://epa.ms/MainLayout8-2)**

```
@наследует LayoutComponentBase ❶
<дел класс = "страница">
 <div class="боковая панель">
 <NavMenu /> ❷
</div>
 <основной>
 @Тело ❸
 </главная>
</div>
```
В компоненте MainLayout ❶ он наследует класс LayoutComponentBase. ❷ Включает
компонент NavMenu для определения меню для навигации. ❸ Внутри тега <main> используется символ @
Синтаксис Body Razor для указания места в разметке макета, где отображается содержимое.

  Давайте подробно рассмотрим компонент NavMenu, так как это метод навигации верхнего уровня в нашем приложении.
Пожалуйста, обратитесь к рисунку 8.3, чтобы увидеть пользовательский интерфейс NavMenu, прежде чем мы рассмотрим код. NavMenu включает
три пункта меню «Домой», «О программе» и «Выход».

![изображение](https://user-images.githubusercontent.com/26972859/231965554-be541599-efa4-42e1-8ea6-14948bf09a24.png)

Рисунок 8.3: Меню навигации

NavMenu — это компонент Razor, определяющий ссылки для навигации. Мы можем просмотреть исходный код
NavMenu в листинге 8.3 здесь:

** Листинг 8.3: NavMenu.razor (https://epa.ms/NavMenu8-3)**

```xml
<div class="верхний ряд ps-3 navbar navbar-dark"> ①
 <div class="container-fluid">
 <a class="navbar-brand" href="">PassXYZ.Vault</a>
<button title="Меню навигации" class="navbar-toggler"
 @onclick="ToggleNavMenu"> ②
 <span class="navbar-toggler-icon"></span>
 </кнопка>
 </div>
</div>
<div class="@NavMenuCssClass" @onclick="ToggleNavMenu">
 <nav class="flex-column">
 <div class="nav-item px-3"> ③
 <NavLink class="nav-link" href="/group"> ④
 <span class="oi oi-home" aria-hidden="true"></span>
 Дом
 </NavLink>
 </div>
 <div class="nav-item px-3">
 <NavLink class="nav-link" href="/about">
 <span class="oi oi-plus" aria-hidden="true"></span>
 О
 </NavLink>
 </div>
 <div class="nav-item px-3">
 <NavLink class="nav-link" href="" Match=
 "NavLinkMatch.Все">
 <span class="oi oi-list-rich" aria-hidden="true">
 </span>
 Выйти
 </NavLink>
 </div>
 </nav>
</div>
@код {
 частный логический свернутьNavMenu = true;
 приватная строка NavMenuCssClass => rollNavMenu ?
 «свернуть»: ноль;
 частная пустота ToggleNavMenu () {
 свернутьNavMenu = !collapseNavMenu;
 }
}
```
В исходном коде компонента NavMenu мы видим, что это компонент Bootstrap navBar.
с некоторой логикой C# в блоке кода. ① NavBar определяется с помощью класса navbar Bootstrap в
Тег <div> выглядит следующим образом:

```<div class="top-row ps-3 navbar navbar-dark">```

Как мы видим на рис. 8.3, есть значок гамбургера ② в левом верхнем углу экрана с помощью <кнопки>.
тег для переключения NavMenu. Пользовательский интерфейс кнопки гамбургера реализован с помощью navbar-toggler.
Bootstrap-класс следующим образом:

```xml
<button title="Меню навигации" class="navbar-toggler"
 @onclick="ПереключитьNavMenu">
 <span class="navbar-toggler-icon"></span>
 </кнопка>
```
Есть три ссылки, определенные как пункты меню с использованием класса Bootstrap nav-item, ③. Ссылка
определяется с помощью NavLink ④ вместо тега привязки <a>. Компонент NavLink ведет себя как
<a> за исключением того, что он переключает активный класс CSS в зависимости от того, соответствует ли его href текущему URL-адресу.
как мы видим здесь:

```xml
<div class="nav-item px-3">
 <NavLink class="nav-link" href="/group">
 <span class="oi oi-home" aria-hidden="true"></span>
 Дом
 </NavLink>
 </div>
```
Мы объяснили MainLayout, который является макетом по умолчанию в нашем приложении. Рассмотрим, как применить
макет к компоненту.

# Применение макета к компоненту

MainLayout используется как компонент макета по умолчанию, поэтому он будет применяться ко всем страницам, если мы не укажем
макет. Иногда нам нужно использовать определенный макет вместо макета по умолчанию. Например, в нашем
app мы используем другой компонент макета на странице входа вместо макета по умолчанию (см. листинг
8.4). MainLayout включает компонент NavMenu. Мы не хотим показывать его на странице входа
так как мы не позволяем пользователю видеть какой-либо другой контент до входа в систему. Давайте посмотрим на изменения в
страница входа после того, как мы применили определенный макет в листинге 8.4:

# Листинг 8.4: Login.razor (https://epa.ms/Login8-4)

```
@страница "/"
@layout LogoutLayout ❶
@namespace PassXYZ.Vault.Pages
<div класс="текст-центр">
 <основной класс="форма-вход">
 <форма>
 <img id="first" class="mb-4" src=
 "passxyz-blue.svg"...>
 <h1 class="h3 mb-3 fw-normal">Пожалуйста, войдите</h1>
 <div class="форма-плавающая">
 <label for="floatingInput">Имя пользователя</label>
 <тип ввода="текст"
 @bind="@currentUser.Имя пользователя"...>
 </div>
 <div class="форма-плавающая">
 <label for="floatingPassword">Пароль</label>
 <input type="пароль" @bind=
 "@currentUser.Пароль"...>
 </div>
 <div class="флажок mb-3">
<метка>
 <input type="checkbox" value="запомнить меня">
 Запомнить меня
 </метка>
 </div>
 <button...>Войти</button>
 <p class="mt-5 mb-3 text-muted">© 2021–2022</p>
 </форма>
 </главная>
</div>
```
Чтобы использовать определенный макет, мы можем использовать директиву @layout Razor, ❶. На странице входа мы используем
Макет LogoutLayout. Код LogoutLayout показан в листинге 8.5 здесь:

**Листинг 8.5: LogoutLayout.razor (https://epa.ms/LogoutLayout8-5)**

```
@наследует LayoutComponentBase
<дел класс = "страница">
 <основной>
 <div class="верхний ряд px-4">
 <a href="#" target="_blank">Вход</a>
 </div>
 <статья класс="контент px-4">
 @Тело
 </статья>
 </главная>
</div>
```
В LogoutLayout мы удалили элемент NavMenu и добавили ссылку для входа, чтобы разрешить новый
пользователя для регистрации.

# Вложенные макеты

Компоненты макета также могут быть вложенными. В MainLayout мы не указали поля для содержимого.
MainLayout подходит для представления списка содержимого на странице элементов или странице сведений об элементе. Однако это
не подходит для содержательных страниц, таких как страница «О нас». Мы можем использовать другой макет для
О странице и этот макет вложен в MainLayout. Мы можем назвать его PageLayout, и мы можем
см. реализацию в листинге 8.6:

# Листинг 8.6: PageLayout.razor (https://epa.ms/PageLayout8-6)

```
@наследует LayoutComponentBase
@layout Основной макет
<статья класс="контент px-4">
 @Тело
</статья>

```
PageLayout — это компонент макета, который использует MainLayout. Он помещает @Body в <article>
тег с примененным стилем «content px-4», чтобы к содержимому можно было применить подходящий стиль
за абзац текста.
На странице About мы можем установить макет PageLayout следующим образом:

```
@страница "/о нас"
@layout PageLayout
```
Теперь мы представили маршрутизацию и макет Blazor. С этими знаниями пришло время реализовать
элементы навигации нашего приложения.

# Реализация элементов навигации

В главе 5 «Навигация с использованием .NET MAUI Shell и NavigationPage», когда мы представили Shell, мы
упомянул абсолютный маршрут и относительный маршрут в Shell. Мы можем определить абсолютные маршруты в визуальном
иерархию навигации и перейти к относительному маршруту через параметры запроса.
Эта стратегия навигации аналогична версии нашего приложения для Blazor. Как мы видим на рис. 8.4, мы
реализовать элементы пользовательского интерфейса Blazor так же, как в нашей версии XAML.

![изображение](https://user-images.githubusercontent.com/26972859/231966410-957e2ae2-8179-435f-9625-0b8a2f6e8453.png)

Рисунок 8.4: Элементы навигации

Страница «Элементы» — это главная страница нашего приложения после входа в систему. На странице «Элементы», на которой список элементов
отображается, следующие элементы пользовательского интерфейса связаны с навигацией:
  

  * Представление списка — пользователь может перемещаться по списку и выбирать элемент.

  * Контекстное меню — оно связано с каждым элементом в представлении списка. Пользователь может редактировать или удалять
элемент с помощью контекстного меню.

  * Кнопка «Назад» — пользователь может использовать ее для перехода назад.

  * Кнопка «Добавить» — пользователь может использовать ее для добавления новых элементов.
В этом разделе мы реализуем предыдущие элементы навигации, используя полученные знания.

# Реализация представления списка

В версии XAML наша навигация начинается со списка элементов после входа пользователя в приложение. Список
представление реализовано с помощью элемента управления .NET MAUI ListView, который использует базовый компонент пользовательского интерфейса для конкретной платформы, поэтому внешний вид такой же, как и для конкретной платформы. В Блейзоре
версии, мы используем веб-интерфейс, поэтому внешний вид и поведение одинаковы на разных платформах.
Чтобы реализовать представление списка с помощью веб-интерфейса, у нас есть много вариантов. В этой книге мы придерживаемся
Загрузочный фреймворк. Способ, которым мы собираемся это сделать, такой же, как и в предыдущей главе. Мы можем
повторно используйте дизайн пользовательского интерфейса из примеров Bootstrap. В этой книге мы используем Bootstrap 5.1, поэтому мы можем
обратитесь к следующему примеру группы списков, показанному на рис. 8.5.

![изображение](https://user-images.githubusercontent.com/26972859/231966606-f2fa80af-ea7a-488b-b74e-b3e14bfc72e2.png)

Рисунок 8.5: Группа списка начальной загрузки

Предыдущий пример можно найти по следующему URL-адресу:

https://getbootstrap.com/docs/5.1/components/list-group/
 
Группу списков Bootstrap можно использовать для создания компонента ListView, похожего на пользовательский интерфейс, в XAML. Сделать это,
мы можем применить класс CSS list-group к тегам HTML, таким как <ul> или <div>, чтобы создать список
группа. Внутри группы списка CSS-класс list-group-item применяется к элементу списка в группе.

В версии XAML мы поддерживаем операции CRUD с помощью контекстного меню. Однако нет
контекстное меню доступно в группе списка Bootstrap, поэтому нам нужно реализовать контекстное меню самостоятельно.
Чтобы реализовать контекстное меню в группе списка, мы можем использовать раскрывающийся компонент Bootstrap.
Чтобы использовать компонент раскрывающегося списка, нам нужно включить зависимость JavaScript в index.html.
следующее:

```xml
<script src="_framework/blazor.webview.js"
 автозапуск = "ложь"></скрипт>
<script src="css/bootstrap/bootstrap.bundle.min.js">
 </скрипт>  
```
Мы добавили файл JavaScript bootstrap.bundle.min.js после blazor.webview.js. 
Файл JavaScript bootstrap.bundle.min.js является частью пакета выпуска Bootstrap.

Чтобы создать новый компонент Razor, Items, мы можем щелкнуть правой кнопкой мыши папку Pages в Visual Studio.
и выберите Add -> Razor Component…, чтобы создать его. Мы добавляем следующий код в листинг 8.7 и
назовите файл Razor Items.razor:

**Листинг 8.7: Items.razor (https://epa.ms/Items8-7)**

```
@страница "/группа"
@page "/group/{SelectedItemId}"
<!-- Кнопка "Назад" и заголовок -->
<div class="контейнер">...
<!-- Список с контекстным меню -->
<div class="list-group"> ❶
 @foreach (элемент var в элементах) {
 <div class="выпадающий список-группа-элемент
 список-группа-элемент-действие...> ❷
 <img src="@item.GetIcon()"...>
 <a href="@item.GetActionLink()"
 class="элемент-группы-списка...>
 <div class="d-flex">
 <дел>
 <h6 class="mb-0">@item.Name</h6>
 <p class="mb-0 opacity-75">@item.Description
 </p>
 </div>
 </div>
 </a>
 <button class="opacity-50 btn btn-light
 выпадающее меню"
 тип = «кнопка» id = «itemsContextMenu»
 data-bs-toggle="выпадающий" aria-expanded="false">
 <span class="oi oi-menu" aria-hidden="true"></span>
 </кнопка> ❸
 <ul class="выпадающее меню"
 aria-labeledby="itemsContextMenu"> ❹
 <li>
 <button class="dropdown-item"
 data-bs-toggle = "модальный"
 data-bs-target="#editModel"> Изменить </button>
 </li>
 <li>
 <button class="dropdown-item"
 data-bs-toggle = "модальный"
 data-bs-target="#deleteModel"> Удалить </button>
 </li>
 </ul>
 </div>
 }
</div>
<!-- Модальное окно редактирования -->
<div class="modal fade" id="editModel" tabindex="-1"
 aria-labeledby="editModelLabel" aria-hidden="true">...
<!-- Удаление модального окна -->
<div class="modal fade" id="deleteModel" tabindex="-1"
 aria-labeledby="deleteModelLabel" aria-hidden="true">...
<!-- Новая модальная форма -->
<div class="modal fade" id="newItemModel" tabindex="-1" arialabeledby="newItemModelLabel" aria-hidden="true">...
```
В Items.razor, ❶, мы можем скопировать пример кода группы списков Bootstrap, который использует тег <div>
применив к нему класс CSS list-group.
  
❷ Мы настраиваем элемент группы списка в соответствии с нашими требованиями, как показано на рис. 8.6. Список
элемент группы создается внутри цикла foreach с использованием тега <div>, который включает в себя значок, имя,
описание и контекстное меню:

```
<div class="выпадающий список-группа-элемент список-группа-элемент-действие...>
```
Мы применяем раскрывающийся список, элемент группы списка и действие элемента группы списка, классы CSS, чтобы
тег <div>, так что это элемент группы списка, включающий контекстное меню с использованием раскрывающегося списка.

![изображение](https://user-images.githubusercontent.com/26972859/231967189-602c82a2-7c6b-4b22-9185-036cba73db0c.png)

Рисунок 8.6: Элемент группы списка

Внутри элемента группы списка мы используем тег <img> для отображения значка элемента:

```
<img src="@item.GetIcon()"...>
```
Мы можем получить источник значка, используя метод расширения GetIcon() из класса Item. Создавать
метод расширения, мы добавляем новый файл класса в общую папку и называем его ItemEx.cs
как показано в листинге 8.8.
                          
Тег привязки <a> используется для отображения имени и описания элемента. Внутри <a> имя
и описание определяются так:

```
Класс <a href="@item.GetActionLink()"=
 "элемент-группы-списка...>
 <div class="d-flex">
 <дел>
 <h6 class="mb-0">@item.Name</h6>
 <p class="mb-0 opacity-75">@item.Description
 </p>
 </div>
 </div>
 </a>
```
Мы можем получить ссылку на элемент, используя метод расширения GetActionLink(), который также
определено в листинге 8.8.
Контекстное меню представляет собой раскрывающийся компонент Bootstrap, включающий тег <button>, ❸ и
неупорядоченный список с использованием тега <ul>, ❹. Эта кнопка отображается в виде значка гамбургера с помощью кнопки «Открыть».
Знаковый шрифт.

Открытые значки Iconic
  
Мы используем значки Open Iconic в дизайне пользовательского интерфейса Blazor. Open Iconic — это набор иконок с открытым исходным кодом,
223 значка в форматах SVG, веб-шрифта и растра. В дизайне XAML мы используем FontAwesome, который
также можно использовать в Blazor с Bootstrap. Однако нам нужна дополнительная конфигурация, прежде чем мы
может использовать его. Open Iconic включен в шаблон Blazor вместе с Bootstrap. Мы можем использовать
это напрямую без какой-либо дополнительной настройки. Например, чтобы отобразить значок гамбургера в
контекстное меню, мы можем использовать следующий тег HTML:

```<span class="oi oi-menu" aria-hidden="true"></span>```

В раскрывающемся меню есть две контекстные кнопки действий: «Изменить» и «Удалить». Мы применяем
класс CSS dropdown-item для кнопок. Кнопка контекстного действия вызывает диалоговое окно для выполнения
операции CRUD, так что есть два модальных CSS-атрибута Bootstrap, data-bs-toggle и
data-bs-targe, примененный к нему. Мы обсудим, как обрабатывать операции CRUD, в следующей главе.

Давайте рассмотрим методы расширения Item, которые мы будем использовать для поддержки пользовательского интерфейса списка в листинге 8.8:

**Листинг 8.8: ItemEx.cs (https://epa.ms/ItemEx8-8)**

```Csharp
с помощью KeePassLib;
с помощью KPCLib;
используя PassXYZLib;
пространство имен PassXYZ.Vault.Shared {
 открытый статический класс ItemEx {
 общедоступная статическая строка GetIcon (этот элемент) { ①
 если (элемент.IsGroup) {
 // Группа
if(item is group PwGroup) { if(group.
CustomData.Exists(PxDefs.PxCustomDataIconName)) {
 вернуть $"/images/{group.CustomData.Get
 (PxDefs.PxCustomDataIconName)}";
 }
 }
 }
 еще {
 // Вход
 if(элемент является записью PwEntry) {
 если (запись.CustomData.Exists
 (PxDefs.PxCustomDataIconName)) {
 Вернуть $"/images/{entry.CustomData.Get
 (PxDefs.PxCustomDataIconName)}";
 }
 }
 }
 // 2. Получить пользовательский значок
 вернуть элемент.GetCustomIcon();
 }
 /// <сводка>
 /// Получить ссылку действия элемента.
 /// </резюме>
 общедоступная статическая строка GetActionLink (этот элемент
 элемент, строка? действие = по умолчанию) { ②
 строка itemType = (item.IsGroup)?
 PxConstants.Group : PxConstants.Entry;
 вернуть (действие == ноль)? $"/{itemType}/{item.Id}":
 $"/{itemType}/{action}/{item.Id}";
 }
 /// <сводка>
 /// Получить родительскую ссылку элемента.
 /// </резюме>
 общедоступная статическая строка? GetParentLink(данный элемент) {③
Элемент? родитель = по умолчанию;
 если (item == null) вернуть null;
 если (элемент.IsGroup) {
 Группа PwGroup = (PwGroup)элемент;
 если (group.ParentGroup == null) вернуть null;
 родитель = группа.ParentGroup;
 }
 еще {
 Запись PwEntry = (PwEntry)элемент;
 если (entry.ParentGroup == null) вернуть null;
 родитель = запись.ParentGroup;
 }
 вернуть $"/{PxConstants.Group}/{parent.Id}";
}
 }
}
```
В листинге 8.8 мы определяем статический класс ItemEx для реализации метода расширения класса Item.
В этом классе мы определили три метода расширения для получения URL-адреса, необходимого для навигации:

  * GetIcon(), ① – возвращает URL изображения значка

  * GetActionLink(), ② – вернуть URL-адрес выбранного элемента в зависимости от типа элемента

  * GetParentLink(), ③ – возвращает URL родительского элемента

  В предыдущей реализации пользовательского интерфейса представления списка у нас есть список, включающий записи паролей и
группы. Когда элемент выбран, мы на самом деле щелкаем по тегу привязки <a>. Свойство href элемента <a> равно
устанавливается на возвращаемое значение метода GetActionLink(). Возвращаемое значение этого метода равно
в формате шаблона маршрута "/{itemType}/{item.Id}", который можно использовать для навигации
к выбранному элементу. Справа от каждого элемента есть кнопка контекстного меню. Если мы нажмем
на нем показан список контекстных действий, и мы можем выбрать действие для редактирования или удаления текущего элемента.
Теперь мы можем обрабатывать большинство действий навигации, но еще не хватает двух действий. Когда мы
войти в дочернюю группу, мы не можем вернуться назад, а также не можем добавить новый элемент. Мы добавим эти
две функции в следующем разделе.

# Добавление нового элемента и возврат назад

Чтобы поддерживать навигацию назад и добавление нового элемента, мы можем добавить кнопку «Назад» и кнопку «Добавить» в
строка заголовка для имитации страницы навигации версии XAML, как показано на рис. 8.7:

![изображение](https://user-images.githubusercontent.com/26972859/231967775-3838e1fa-332c-4e01-843b-6e3d72e38929.png)

Рисунок 8.7: Строка заголовка страницы «Элементы»

Как мы видим в строке заголовка здесь, включены три элемента пользовательского интерфейса:
  
   * Название – название текущей группы товаров

  * Кнопка «Назад» — эту кнопку можно использовать для перехода назад, но она не будет отображаться, если нет родительской группы.

  * Кнопка «Добавить» — эту кнопку можно использовать для добавления нового элемента

  Чтобы проверить реализацию, мы можем расширить код кнопки «Назад» и части «Заголовок» в листинге 8.7, как показано здесь:

```
<!-- Кнопка "Назад" и заголовок -->
<div класс="контейнер">
 <дел класс = "строка">
 <див класс="кол-12">
 <h1>
 @if (selectedItem!.GetParentLink() != ноль) {
 <a class="btn btn-outline-dark" href=
 "@selectedItem!.GetParentLink()"><span
 class="oi oi-chevron-left"
 ария-скрытый="true"></span></a> ❶
 }
 @(" " + Название)
 <button type="button" class="btn btn-outline-dark
 float-end" data-bs-toggle="modal" data-bs-
 target="#newItemModel"><span class="oi
 oi-plus" aria-hidden="true"></span></button> ❷
 </h1>
 </div>
</div>
</div>
```
Кнопка «Назад» ❶ реализована в виде тега привязки <a>. Атрибут href тега привязки
устанавливается на возвращаемое значение метода расширения Item, GetParentLink(). Эта функция возвращает
ссылка родительского элемента в формате шаблона маршрута, поэтому мы можем вернуться назад, используя эту ссылку. Если
отсутствует родительская группа, такая как корневая группа, кнопка «Назад» не отображается.

Кнопка «Добавить» ❷ реализуется с помощью тега <button>. Кнопка «Добавить» отображается на
в правой части строки заголовка. Чтобы нажать эту кнопку справа от экрана, мы можем использовать Bootstrap
класс, float-end. Когда пользователь нажимает эту кнопку, отображается диалоговое окно нового элемента. Диалог
box устанавливается с использованием следующих атрибутов:

```data-bs-toggle="modal" data-bs-target="#newItemModel"```

В Items.razor используются три модальных диалога Bootstrap, как показано в листинге 8.7.

```
<!-- Модальное окно редактирования -->
<div class="modal fade" id="editModel" tabindex="-1"
 aria-labeledby="editModelLabel" aria-hidden="true">...
<!-- Удаление модального окна -->
<div class="modal fade" id="deleteModel" tabindex="-1"
 aria-labeledby="deleteModelLabel" aria-hidden="true">...
<!-- Новая модальная форма -->
<div class="modal fade" id="newItemModel" tabindex="-1" arialabeledby="newItemModelLabel" aria-hidden="true">...
```
Мы используем эти диалоги для выполнения операций CRUD. Для реализации этих диалогов мы также повторно используем код
из бутстрапа. Это довольно просто сделать таким образом, но при этом задействовано много дублированного кода.
Для экономии места в листинге 8.7 они свернуты. В следующей главе мы объясним реализацию
диалоговых окон модели и преобразовать код в повторно используемые компоненты Razor.

# Краткое содержание

В этой главе мы представили маршрутизацию и макет Blazor. Это компоненты, которые мы
можно использовать для построения навигационной иерархии нашего приложения. К концу этой главы мы можем выполнить
базовая навигация, как в XAML-версии нашего приложения.
Когда мы создавали пользовательские интерфейсы в этой главе, мы видели, что техника проектирования пользовательского интерфейса Blazor такая же, как
веб-дизайн пользовательского интерфейса. Мы можем повторно использовать код из существующего фреймворка, такого как Bootstrap.

Если мы хотим создать пользовательский интерфейс самостоятельно, мы можем сначала поработать над первоначальным дизайном на игровой площадке. После
мы довольны дизайном пользовательского интерфейса, мы можем скопировать код HTML и CSS в наш файл Razor для создания
Компонент Razor. Разработчики внешнего интерфейса используют множество игровых площадок, таких как CodePen,
JSFiddle, CodeSandbox и StackBlitz.

В этой главе мы повторно использовали примеры Bootstrap для создания наших пользовательских интерфейсов. Несмотря на то, что это прямой
способ реализации веб-интерфейса, создается много повторяющихся кодов. В следующей главе мы будем
усовершенствовать наш код и преобразовать код в повторно используемые компоненты Razor. Будем внедрять CRUD
операции по добавлению, редактированию и удалению элементов с помощью этих компонентов Razor.






































































































































































































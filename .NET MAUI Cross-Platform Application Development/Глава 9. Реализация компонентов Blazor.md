# Глава 9. Реализация компонентов Blazor

В последней главе мы узнали о маршрутизации и макете Blazor. Затем мы построили навигационную структуру
путем создания маршрутизации и макета нашего приложения. После того, как мы создали структуру навигации, мы создали
страницы верхнего уровня. С реализацией страниц Razor мы можем исследовать базу данных паролей.
аналогично тому, что мы можем исследовать в версии XAML. Страницы Razor — это компоненты Razor, но
они не подлежат повторному использованию. Компоненты Razor — это строительные блоки пользовательского интерфейса Blazor. В этой главе мы
представит компоненты Razor. Чтобы понять компоненты Razor, мы представим привязку данных
и жизненный цикл компонента Razor. Узнав об этих концепциях, мы уточним наш код и
конвертировать повторяющийся код в повторно используемые компоненты Razor. Наконец, мы будем использовать компоненты Razor.
которые мы создаем для реализации операций CRUD в нашем приложении.

В этой главе мы рассмотрим следующие темы:

* Представляем компоненты Razor

* Привязка данных

* Понимание жизненного цикла компонентов Razor

* Реализация CRUD-операций

# Технические требования

Для тестирования и отладки исходного кода в этой главе вам необходимо установить Visual Studio 2022 на
ваш ПК или Mac. Пожалуйста, обратитесь к разделу Настройка среды разработки в Главе 1, Получение
Начал с .NET MAUI, подробнее.

Исходный код этой главы доступен в следующем репозитории GitHub:

https://github.com/PacktPublishing/.NET-MAUI-Cross-PlatformApplication-Development/tree/main/Chapter09

Исходный код можно загрузить с помощью следующей команды git:

```
git clone -b chapter09 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development PassXYZ.Vault2
```

# Понимание компонентов Razor

Несмотря на то, что мы создали и использовали компоненты Razor в последних двух главах, мы не
поближе познакомьтесь с компонентами Razor. В этом разделе мы продолжим улучшать приложение с последней
главу и углубитесь в компоненты Razor, чтобы узнать некоторые ключевые понятия об этих компонентах.
Приложения Blazor создаются с использованием компонентов Razor. Первым компонентом Razor в нашем приложении является Main.
определяется в Main.razor, как показано здесь:

```
<Router AppAssembly="@typeof(Main).Assembly">
 <Found Context="routeData">
 <RouteView RouteData="@routeData"
 DefaultLayout="@typeof(MainLayout)" />
<FocusOnNavigate RouteData="@routeData"
 Selector="h1" />
 </Found>
 <NotFound>
 <LayoutView Layout="@typeof(MainLayout)">
 <p role="alert">
 Sorry, there's nothing at this address.
 </p>
 </LayoutView>
 </NotFound>
</Router>
```
Компонент Router устанавливается в компоненте Main и отвечает за маршрутизацию страниц.
и выбирает компонент макета по умолчанию. Все остальные страницы Razor загружаются компонентами маршрутизатора.
Страницы Razor, загружаемые Router, имеют определенные шаблоны маршрутов и используются для представления пользовательского интерфейса для
пользователи. В нашем проекте страницы Razor находятся в папке Pages. Есть также многоразовые бритвы
компонентов, и они являются строительными блоками страниц Razor. Эти компоненты Razor находятся в
Общая папка.

По сути, каждый файл с расширением .razor является компонентом Razor и скомпилирован в
Класс C# при его выполнении. Имя класса — это имя файла. Имя папки используется как часть
пространство имен. Например, компонент Login Razor находится в папке Pages, поэтому имя папки,
Pages, используется как часть пространства имен. Итак, полное имя класса Login — PassXYZ.Vault.
Страницы.Войти.
Мы используем регистр Pascal для имени класса в C#, поэтому имя папки и имя файла Razor должны использовать Pascal.
также случай.

Что такое футляр Паскаля, верблюжий футляр и змеиный футляр?
Паскаль, верблюд и змея обычно используются в соглашениях об именах в программировании.
языки. Вот некоторые примеры:

* Camel case использует прописные и строчные буквы в имени переменной. Первая буква строчная,
например, логинПользователь.

* Pascal также использует прописные и строчные буквы в имени переменной, но первая буква
в верхнем регистре, например LoginUser.

* Змеиный регистр использует только строчные буквы и отделяет каждое слово символом подчеркивания, например, login_
пользователь.

Компоненты Razor можно создать в одном файле или разделить на файл Razor (.razor) и
файл кода программной части C# (.cs). В файле кода программной части C# определен разделяемый класс, содержащий все
логика программирования. Мы сделали это, когда создавали компонент Login в Главе 7, Знакомство с
Разработка гибридных приложений Blazor.

![изображение](https://user-images.githubusercontent.com/26972859/231969636-33f60dcd-f112-4f4f-bd88-77525f5cd7d2.png)

Рисунок 9.1: Соглашение об именах компонентов Razor

Когда мы создавали компонент Login, мы использовали CSS-стиль Bootstrap для оформления. Компоненты бритвы
может поддерживать изоляцию CSS, что может упростить CSS и избежать конфликтов с другими компонентами или
библиотеки. Кроме того, он может включать собственный стиль CSS в файл .razor.css.

# Наследование

Поскольку компонент Razor является классом C#, он включает в себя все функции класса C#. Компонент Razor может
быть дочерним классом другого компонента Razor. В главе 8 «Понимание макета и маршрутизации Blazor»
когда мы создавали компоненты макета, мы могли видеть, что все компоненты макета являются производными классами
МакетКомпонентБаза. Как мы можем видеть в MainLayout.razor в следующем коде, мы используем
директива @inherits для указания базового класса LayoutComponentBase:

```
@inherits LayoutComponentBase
<div class="page">
 <div class="sidebar"><NavMenu/></div>
 <main>@Body</main>
</div>
```
Все компоненты Razor являются производными от класса ComponentBase, поэтому можно создать класс Razor.
компонент, производный от класса ComponentBase с использованием файла C# без разметки Razor
файл. Например, мы можем создать компонент Razor с именем AppName в классе C#, как показано здесь:

```Csharp
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
namespace PassXYZ.Vault.Pages;
public class AppName : ComponentBase
{
 protected override void BuildRenderTree
 (RenderTreeBuilder builder)
 {
 base.BuildRenderTree(builder);
 builder.OpenElement(0, "div");
 builder.AddContent(1, "PassXYZ.Vault");
 builder.CloseElement();
 }
}
```
AppName — это компонент Razor, созданный без файла разметки Razor (.razor), но это то же самое.
как и другие компоненты Razor, как показано здесь:

```
...
<AppName/>
...
```
В этом разделе мы представили компоненты Razor. Мы научимся упаковывать компоненты Razor
в библиотеке в следующем разделе.

# Создание библиотеки классов Razor

В нашем проекте мы создаем повторно используемые компоненты в папке Shared. Эти компоненты можно использовать повторно
другими компонентами, такими как компоненты макета или NavMenu.

Мы также можем инкапсулировать компоненты Razor в отдельную библиотеку в виде библиотеки классов Razor.
Компоненты в библиотеке классов Razor не зависят от проекта, поэтому их можно использовать в любом Blazor.
проект. Мы можем использовать их в приложениях Blazor Hybrid, Blazor WebAssembly или Blazor Server.

В этой книге мы создаем компоненты Razor с помощью Bootstrap. Существует множество классов Razor с открытым исходным кодом.
библиотеки, созданные поверх Bootstrap в GitHub. Некоторые из них достаточно хороши для коммерческого продукта
разработка. Вот некоторые примеры:

* BootstrapBlazor — https://github.com/dotnetcore/BootstrapBlazor
* Blazorise – https://github.com/Megabit/Blazorise
* Havit.Blazor — https://github.com/havit/Havit.Blazor/

Эти проекты с открытым исходным кодом построены как библиотеки классов Razor, поэтому их можно повторно использовать аналогично
другие библиотеки .NET. Библиотеки классов Razor можно публиковать в виде пакетов NuGet, чтобы мы могли их импортировать.
в наши проекты Blazor.

В этом разделе мы создадим библиотеку классов Razor, аналогичную ранее упомянутой библиотеке с открытым исходным кодом.
проекты. Мы поместим компоненты Razor, которые можно повторно использовать, в нашу библиотеку классов Razor. Эта библиотека может
быть опубликован в виде пакета NuGet.

Мы можем создать библиотеку классов Razor с помощью Visual Studio или командной строки dotnet.
Чтобы создать библиотеку классов Razor с помощью Visual Studio, мы можем добавить новый проект в наше решение, как показано ниже.
на рисунке 9.2, выполнив следующие шаги:

1. Найдите и выберите библиотеку классов Razor в шаблонах проекта.
2. Нажмите «Далее» и назовите проект PassXYZ.BlazorUI.
3. На следующем экране нажмите «Создать», чтобы создать его.

![изображение](https://user-images.githubusercontent.com/26972859/231970087-dde84124-64d7-440d-947d-244ea8faba1e.png)

Рисунок 9.2: Создание библиотеки классов Razor

Чтобы создать проект с помощью командной строки dotnet, мы можем изменить каталог на папку решения.
и выполните следующую команду в командной строке:

```dotnet new razorclasslib -n PassXYZ.BlazorUI```

Команда dotnet new создаст новый проект с использованием шаблона razorclasslib.
и назовите проект PassXYZ.BlazorUI. Чтобы добавить проект в решение, мы можем использовать
следующая команда:

```dotnet sln add PassXYZ.BlazorUI\PassXYZ.BlazorUI.csproj```

Нам нужно удалить неиспользуемые файлы Component1.* и ExampleJsInterop.cs из каталога.
Проект PassXYZ.BlazorUI.

Чтобы использовать компоненты Razor в нашем проекте, нам нужно добавить ссылку на проект в файл PassXYZ.
Проект хранилища. Мы можем добавить его в Visual Studio, щелкнув правой кнопкой мыши узел проекта и выбрав Добавить
-> Справочник по проекту. Мы также можем отредактировать файл проекта PassXYZ.Vault.csproj, чтобы добавить
следующая строка:

```xml
<ItemGroup>
 <ProjectReference
 Include="..\PassXYZ.BlazorUI\PassXYZ.BlazorUI.csproj"
 />
</ItemGroup>
```
Чтобы использовать эту библиотеку, нам нужно обновить файл PassXYZ.Vault\_Imports.razor, чтобы добавить
следующая строка:

```@использование PassXYZ.BlazorUI```

# Использование статических ресурсов в библиотеке классов Razor

Мы используем Bootstrap в наших компонентах Razor, поэтому нам нужно включить файлы Bootstrap CSS и JavaScript.
в библиотеке классов Razor. С точки зрения приложения Blazor мы можем поместить эти статические активы либо в
папку wwwroot проекта или папку wwwroot библиотеки компонентов. Использование Bootstrap CSS
файл в качестве примера, если мы поместим его в проект wwwroot, мы можем ссылаться на него в index.html с помощью
следующий путь:

```<script src="css/bootstrap/bootstrap.bundle.min.js"/>```

Если мы решим поместить его в папку wwwroot библиотеки компонентов, мы можем обратиться к нему по следующему пути:

```<script src="_content/PassXYZ.BlazorUI/css/bootstrap/bootstrap.bundle.min.js"/>```

Разница в том, что нам нужно обратиться к URL-адресу в библиотеке компонентов, начиная с _content/{LibraryProjectName}.

После того, как мы создали проект библиотеки классов Razor, мы можем добавить в него дополнительные компоненты.

# Создание повторно используемых компонентов Razor

В этом разделе мы можем создавать повторно используемые компоненты, оптимизируя наш код. На протяжении всего процесса мы
может лучше понять особенности компонентов Razor и способы их повторного использования.
Мы создали версию Blazor Hybrid нашего приложения PassXYZ.Vault в главе 7 «Введение в Blazor Hybrid».
App Development, и мы добавили в него функции компоновки и маршрутизации в Главе 8, Понимание

Макет Blazor и маршрутизация. Наше приложение теперь может просматривать и обновлять базу данных паролей. До сих пор мы
не реализовали большинство операций CRUD. Мы добавим эти функции после доработки
наши компоненты Razor в этой главе.

Для навигации по базе паролей мы создали два компонента Razor — Items и ItemDetail.
— в главе 7 «Введение в .NET MAUI Blazor». Класс Items используется для отображения списка паролей.
записи и группы в текущей группе, а класс ItemDetail используется для отображения содержимого
ввода пароля.

Если мы посмотрим на расположение Items и ItemDetail, как показано на рис. 9.3, внешний вид
обе страницы очень похожи:

![изображение](https://user-images.githubusercontent.com/26972859/231970589-85462e26-5bd1-4c75-b7da-f8717e51e4ff.png)

Рисунок 9.3: Макет пользовательского интерфейса Items и ItemDetail

Макет обеих страниц включает боковую панель, заголовок и представление списка. Боковая панель определяется в
Компонент макета. Представление заголовка и списка реализовано как в Items, так и в ItemDetail.
с частично дублированным кодом. Мы оптимизируем наш код и абстрагируем дублированный код в
повторно используемые компоненты в этой и следующей главах.

В шапке есть две кнопки «Добавить» и «Назад». Кнопку «Назад» можно использовать для перехода назад
в родительскую группу, а кнопку «Добавить» можно использовать для добавления нового элемента или поля.

В элементе представления списка мы можем использовать контекстное меню для выполнения операций на уровне элементов, таких как редактирование или
удалить. Контекстное меню включает пункты меню для выполнения определенных действий, связанных с выбранным
элемент или поле. Для операций редактирования или удаления CRUD после выбора пункта меню открывается модальное диалоговое окно.
Отображается связанное с действием.

В текущей реализации как Items, так и ItemDetail включают все элементы пользовательского интерфейса в один.
Разметка бритвы. Мы начнем совершенствовать код, разбивая его на более мелкие повторно используемые компоненты, чтобы сделать нашу
реализация чистая.

В этой главе мы преобразуем модальные диалоги в компоненты Razor и преобразуем заголовок и
представления списка в компоненты Razor в следующей главе. Начнем с модальных диалогов. Для поддержки добавить,
редактировать и удалять, нам нужны два типа диалоговых окон:

* Диалог редактора — добавление или редактирование элементов или полей

* Диалоговое окно подтверждения — для подтверждения перед удалением элемента или поля

В главе 8 «Понимание макета и маршрутизации Blazor» мы использовали код HTML и CSS из
Примеры Bootstrap для реализации модальных диалогов. Мы еще не исследовали их подробно, так как
наши файлы разметки выглядят длинными и сложными. Мы проанализируем код и превратим его в компоненты Razor
в этой главе.

# Создание базового компонента модального диалога

Чтобы улучшить диалоги редактора и подтверждения, мы можем сначала создать базовый модальный диалог. Используя эту базу
модальный диалог, мы можем создать либо редактор, либо диалог подтверждения.
Чтобы создать новый компонент Razor в проекте PassXYZ.BlazorUI, мы можем щелкнуть правой кнопкой мыши
на узле проекта и выберите Добавить -> Новый элемент… -> Компонент Razor в шаблоне проекта. Мы
назовите компонент Razor как ModalDialog и создайте для него файл кода программной части C#. После этого мы
введите код из листинга 9.1 в ModalDialog.razor и из листинга 9.2 в ModalDialog.razor.cs.
Код пользовательского интерфейса извлекается из кода Items или ItemDetail в Главе 8, Понимание
Blazor Layout and Routing, как показано в листинге 9.1:

** Листинг 9.1: ModalDialog.razor (https://epa.ms/ModalDialog9-1)**

```xml
<div class="modal fade" id=@Id tabindex="-1"
 aria-labelledby="ModelLabel" aria-hidden="true">
 <div class="modal-dialog"><div class="modal-content">
 <div class="modal-header"> ❶
 <h5 class="modal-title" id="ModelLabel">@Title</h5> ❷
 <button type="button" class="btn-close" ❸
 data-bs-dismiss="modal" aria-label="Close"/>
 </div>
 <div class="modal-body"> ❹
 <form class="row gx-2 gy-3">
 @ChildContent ❺
 <div class="col-12">
 <button type="button" class="btn btn-secondary"
 data-bs-dismiss="modal" @onclick=
 "OnClickClose">
 @CloseButtonText ❻
 </button>
 <button type="submit" class="btn btn-primary"
 data-bs-dismiss="modal" @onclick=
 "OnClickSave">
 @SaveButtonText ❼
 </button>
 </div>
 </form>
 </div>
 </div></div>
</div>
```
Из кода разметки в листинге 9.1 видно, что это типичный фрагмент HTML-кода в Bootstrap.
стиль. Мы встроили переменные C# в HTML для создания пользовательского интерфейса компонента.
Этот базовый диалоговый пользовательский интерфейс включает заголовок ❶ и тело ❹. На странице есть заголовок ❷ и кнопка закрытия ❸.
заголовок. Внутри тела мы видим дочернюю область содержимого ❺ и две кнопки (Закрыть ❻/Сохранить ❼). Мы
можно обратиться к рисунку 9.4, чтобы увидеть макет этого базового модального диалога.

![изображение](https://user-images.githubusercontent.com/26972859/231970938-5e06e4d7-5dcf-4883-8ede-89b2fb5076df.png)

Рисунок 9.4: Базовое диалоговое окно

Несмотря на то, что код HTML и CSS очень похож на пример Bootstrap, мы заменили все
содержимое жесткого кода с переменными C#. Если мы используем этот компонент модального диалога для создания нового компонента,
следующий пример:

```xml
<ModalDialog Id=@id Title="Please confirm" OnSaveAsync=
 @OnDelete
 SaveButtonText="Save" CloseButtonText="Close">
 Do you want to delete UserName?
</ModalDialog>
<button class="dropdown-item" data-bs-toggle="modal"
 data-bs-target="#@Id">Please confirm</button>
```
В предыдущем коде разметки мы определяем модальный диалог с помощью компонента <ModalDialog>.
ярлык. Каждое модальное диалоговое окно имеет уникальный идентификатор для его идентификации. Мы можем отобразить диалоговое окно после нажатия
кнопка. В кнопке мы предоставляем идентификатор модального диалога, чтобы идентифицировать его.
Внутри тега компонента <ModalDialog> мы присвоили значение нескольких определенных атрибутов.
в компоненте ModalDialog, такие как идентификатор, заголовок, текст кнопок, обработчик событий и т.д.

# Привязка данных

Вместо того, чтобы назначать строку или данные непосредственно атрибуту элемента HTML, мы можем назначить
переменная к нему. Это функция привязки данных компонента Razor. Мы научимся использовать данные
обязательно в этом разделе.
При привязке данных, когда мы присваиваем переменную атрибуту элемента DOM, данные передаются из
Компоненты Razor для элементов DOM. Когда мы отвечаем на событие DOM, данные передаются из DOM.
элементы в компоненты Razor. Поскольку мы можем использовать компонент Razor точно так же, как элемент DOM,
поток данных между дочерним и родительским компонентами Razor аналогичен обмену данными между Razor
компоненты и элементы DOM.
Например, мы можем привязать переменную id к атрибуту Id ModalDialog, и мы можем обрабатывать
событие нажатия кнопки с помощью обработчика события OnDelete:

```
<ModalDialog Id=@id Title="Please confirm" OnSaveAsync=
 @OnDelete
 SaveButtonText="Save" CloseButtonText="Close">

```
В предыдущем примере данные передаются от переменной id к атрибуту Id ModalDialog.
Когда вызывается обработчик события OnDelete, данные передаются из ModalDialog обратно в
текущий контекст. Атрибуты ModalDialog, Id и OnSaveAsync, определены в файле кода программной части C#. Давайте рассмотрим файл кода программной части C# для ModalDialog в следующем разделе.

# Параметры компонента
  
Мы можем определить атрибуты компонентов Razor, используя параметры компонента. Чтобы определить компонент
параметры, мы должны создать публичные свойства с атрибутом [Parameter].
В классе ModalDialog, как показано в листинге 9.2, мы объявляем семь параметров компонента: Id, Title,
ChildContent, OnClose, OnSaveAsync, CloseButtonText и SaveButtonText.
Мы можем использовать эти параметры компонента в привязке данных:

**Листинг 9.2: ModalDialog.razor.cs (https://epa.ms/ModalDialog9-2)**

```Csharp
using Microsoft.AspNetCore.Components;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
namespace PassXYZ.BlazorUI;
public partial class ModalDialog : IDisposable
{
 [Parameter]
 public string? Id { get; set; } ❶
 [Parameter]
 public string? Title { get; set; } ❷
 [Parameter]
 public RenderFragment ChildContent { get; set; } ❸
 [Parameter]
 public Func<Task>? OnClose { get; set; } ❹
 [Parameter]
 public Func<Task<bool>>? OnSaveAsync { get; set; } ❺
 [Parameter]
 [NotNull]
 public string? CloseButtonText { get; set; } ❻
 [Parameter]
 [NotNull]
 public string? SaveButtonText { get; set; } ❼
 private async Task OnClickClose() {
 if (OnClose != null) { await OnClose(); }
 }
 private async Task OnClickSave() {
 if (OnSaveAsync != null) { await OnSaveAsync(); }
 }
 void IDisposable.Dispose() {
 GC.SuppressFinalize(this);
 }
}
```
Параметры компонента ModalDialog определяются следующим образом:

  * Id ❶ — используется для идентификации модального диалога.

  * Заголовок ❷ — это заголовок модального диалога.

  * ChildContent ❸ — сюда следует вставить содержимое дочернего компонента.

Два обработчика событий — OnClose ❹ и OnSaveAsync ❺ — определены для обработки действий по нажатию кнопки.
Мы можем настроить текст обеих кнопок, используя CloseButtonText ❻ и SaveButtonText ❼.
Мы можем обращаться с параметрами компонента так же, как с атрибутами HTML. Мы можем назначить поле C#, свойство или
вернуть значение метода в параметр компонента ModalDialog.
После создания базового компонента ModalDialog мы можем создать редактор и диалоговое окно подтверждения.
компоненты, использующие его.

Давайте создадим новый модальный диалог ConfirmDialog, чтобы запросить подтверждение удаления элемента.
Чтобы создать новый компонент ConfirmDialog в проекте PassXYZ.BlazorUI, мы можем
щелкните правой кнопкой мыши узел проекта и выберите «Добавить» -> «Новый элемент…» -> «Компонент Razor» в
шаблон проекта. Мы можем назвать компонент Razor ConfirmDialog и ввести следующий код
как показано в листинге 9.3:

**Листинг 9.3: ConfirmDialog.razor (https://epa.ms/ConfirmDialog9-3)**

```xml
<ModalDialog Id=@Id Title=@($w"Deleting {Title}") OnSaveAsync=
@OnSavew
 SaveButtonText="Confirm" CloseButtonText="Cancel">
 Please confirm to delete @Title?
</ModalDialog>
@code {w
 [Parameter]
 public string Id { get; set; } = "confirmDialog"w; ①
 [Parameter]
 public string? Title { get; set; } ②
 [Parameter]
 public Action? OnConfirmClick { get; set; }
 async Task<bool> OnSave() {
 OnConfirmClick?.Invoke();
 return true;
 }
}
```

Мы определяем параметры компонентов Id ① и Title ② в ConfirmDialog и передаем их
значения в базовый класс через привязку данных. Мы также подписываемся на событие OnSaveAsync с помощью
Обработчик события OnSave. Мы также определяем собственный обработчик событий OnConfirmClick в качестве компонента.
параметр, на который могут подписываться другие компоненты.
  
В ConfirmDialog мы фактически привязываем параметры через вложенные компоненты. В этом случае данные
должны течь в направлениях, предложенных здесь:

  * Уведомления об изменениях поднимаются вверх по иерархии

  * Новые значения параметров спускаются вниз по иерархии

  Значения атрибутов Id и Title назначаются компонентами, использующими ConfirmDialog,
и их значения передаются в ModalDialog. События кнопки «Сохранить» или «Закрыть» запускаются в
компонента ModalDialog, и они поднимаются по цепочке к ConfirmDialog и вышестоящим уровням.
компоненты. Если мы используем кнопку «Сохранить» в качестве примера, событие происходит в указанном здесь направлении:
onclick (DOM) ->se OnSaveAsync (ModalDialog) -> OnConfirmClick
(Диалог подтверждения)

  Он начинается с события onclick в DOM. ModalDialog определяет собственное событие OnSaveAsync.
который запускается обработчиком события onclick. ConfirmDialog определяет собственное событие,
OnConfirmClick, который запускается обработчиком событий OnSaveAsync.

# Вложенные компоненты

ConfirmDialog — один из примеров вложенных компонентов. Как мы видим, мы можем встроить
компоненты внутри компонентов, объявляя их с использованием синтаксиса HTML. Встроенные компоненты
выглядят как теги HTML, где имя тега — это тип компонента. Например, мы можем использовать
ModalDialog внутри ConfirmDialog, как показано здесь:

```xml
<ModalDialog ...>Подтвердите удаление @Title?</ModalDialog>  
```

Вложенные компоненты — это способ построения иерархии компонентов в Blazor. Наследование и состав
два способа расширения и повторного использования класса в объектно-ориентированном языке программирования. В
Blazor, композиция используется во вложенных компонентах для расширения функциональных возможностей. Наследование – это
отношение, в то время как композиция есть отношение. Во вложенных компонентах родительский компонент
имеет дочерний компонент.
  
В документах Microsoft Blazor и ASP.NET Core термины предок и потомок или родитель
и child используются для объяснения взаимосвязи вложенных компонентов. Здесь родитель и ребенок не
отношение наследования, а отношение композиции. Лучшим термином может быть внешний компонент
или внутренний компонент. Тем не менее, чтобы соответствовать документации Microsoft, я не буду
выбрать другой термин в обсуждении. Просто имейте в виду, что когда мы обсуждаем вложенные компоненты
и привязка данных, отношение предка и потомка является отношением или композицией.
В нашем предыдущем примере компонент ConfirmDialog является внешним компонентом, а ModalDialog
является внутренним компонентом. Связь заключается в том, что в ConfirmDialog есть ModalDialog.

# Рендеринг дочернего контента

Когда мы создаем вложенные компоненты, во многих случаях один компонент может установить содержимое.
другого компонента. Внешний компонент предоставляет содержимое между внутренним компонентом
открывающие и закрывающие теги. В ConfirmDialog он устанавливает содержимое ModalDialog следующим образом:

```xml
<ModalDialog Id=@Id Title=@($"Deleting {Title}")
 OnSaveAsync=@OnSave
 SaveButtonText="Confirm" CloseButtonText="Cancel">
 Please confirm to delete @Title?
</ModalDialog> 
```
Это делается с помощью специального параметра компонента, называемого ChildContent.
Тип рендерфрагмента. В приведенном выше коде подтвердите удаление @Title?
string устанавливается в параметр ChildContent ModalDialog.
ConfirmDialog по-прежнему является относительно простым примером вложенных компонентов. давайте посмотрим на другой
например, EditorDialog, чтобы изучить дополнительные функции компонентов Razor. Как мы упоминали ранее, мы
необходимо два диалоговых окна для обработки действий добавления, редактирования и удаления. ConfirmDialog используется для подтверждения
с пользователями перед удалением элемента или поля. Чтобы добавить или отредактировать элемент или поле, нам нужно диалоговое окно
которые могут предоставить функции редактирования.
Мы можем сделать то же самое для создания нового компонента EditorDialog. После выбора Добавить -> Новый элемент…
-> Компонент Razor в шаблоне проекта, мы можем назвать компонент Razor EditorDialog
и создайте для него файл кода программной части C#. После этого мы вводим код из листинга 9.4 в EditorDialog.
razor и Листинг 9.5 в EditorDialog.razor.cs.

Давайте рассмотрим код разметки Razor EditorDialog, как показано в листинге 9.4:

**Листинг 9.4: EditorDialog.razor (https://epa.ms/EditorDialog9-4)**

```xml
<ModalDialog Id=@Id Title=@Key OnSaveAsync=@OnSaveClicked
 SaveButtonText ="Save" CloseButtonText="Close">
 @if (IsKeyEditingEnable) { ❶
 <input type="text" class="form-control" id="keyField"
 @bind="Key" placeholder=@KeyPlaceHolder required> ❷
 }
 @ChildContent
 <div>
 <textarea class="form-control" id="valueField"
 style="height: 100px"
 placeholder=@ValuePlaceHolder
 @bind="Value" required /> ❸
 </div>
</ModalDialog>
```
EditorDialog построен с использованием ModalDialog. Его можно использовать для редактирования пары ключ-значение. Когда мы
создать новую пару ключ-значение, мы хотим отредактировать как ключ, так и значение. Когда мы редактируем существующий
пару ключ-значение, мы можем захотеть внести изменения только в поле значения. Это два варианта использования, которые
мы хотим поддерживать в EditorDialog. Состояние определяется с помощью параметра компонента
называется IsKeyEditingEnable ❶. Ключевая часть пользовательского интерфейса отображается как <input> ❷
элемент, когда мы хотим создать новую пару ключ-значение. Когда мы редактируем существующую пару ключ-значение,
ключ отображается как заголовок в области заголовка, и мы редактируем значение в элементе <textarea> ❸.
Это основная функциональность нашего компонента EditorDialog.
Мы можем видеть пользовательский интерфейс на рис. 9.5. С левой стороны отображается диалоговое окно, когда мы хотим добавить новый
поле. Нам нужно указать имя поля и содержимое. С правой стороны отображается диалоговое окно, когда
мы хотим отредактировать существующее поле URL. Имя поля отображается в заголовке, и мы можем изменить
содержимое в <textarea>:

![изображение](https://user-images.githubusercontent.com/26972859/231972261-4346f582-03ed-4816-9e4a-e1da0d9eaedb.png)

Рисунок 9.5: Редактирование поля
  
В компоненте EditorDialog, когда мы редактируем ключ и значение, используя <input> и
<textarea> элементы HTML, отображается начальное значение. Начальное значение устанавливается из Razor
компонент в DOM. После внесения изменений данные перетекают из DOM в Razor.
компонент. Это двусторонняя привязка данных

# Двусторонняя привязка данных
  
Двустороннюю привязку данных можно создать с помощью атрибута директивы @bind Razor. С этим синтаксисом
Атрибут элемента HTML может быть привязан к полю, свойству, значению выражения или результату метода. В листинге
9.4 значение элемента <input> привязывается к свойству Key в компоненте EditorDialog:

```html
<input type="text" class="form-control" id="keyField" @bind="Key" placeholder=@KeyPlaceHolder required>
```
При двусторонней привязке данных значение <input> элемента DOM обновляется всякий раз, когда свойство Key
изменен. Свойство Key также обновляется, когда пользователь обновляет значение <input> в DOM.
В предыдущем примере вместо использования атрибута директивы @bind мы можем заменить атрибут @bind
атрибут директивы с двумя односторонними привязками данных, как вы можете видеть в следующем коде:

```html
<input type="text" class="form-control" id="keyField"
 value="@Key"
 @onchange="@((ChangeEventArgs e) => Key = e?.Value?
 .ToString())"
 placeholder=@KeyPlaceHolder required>
```
Когда наш компонент EditorDialog визуализируется, значение элемента <input> берется из
Ключевое свойство. Когда пользователь вводит значение в текстовое поле и меняет фокус элемента,
событие onchange запускается, и свойству Key присваивается измененное значение.
Для элемента <input> событием по умолчанию атрибута директивы @bind является событие onchange.
Мы можем изменить событие с помощью атрибута @bind:event="{event}". Заполнитель {событие}
должно быть событием DOM. Например, мы можем изменить событие onchange на событие oninput.
со следующим фрагментом кода:

```html
<input type="text" class="form-control" id="keyField"
 @bind="Key" @bind:event="oninput" placeholder=@KeyPlaceHolder
required>

```

## Связывание с параметрами компонента

В предыдущем разделе мы обсудили двустороннюю привязку данных между компонентом Razor и DOM.
элемент. Поскольку компонент Razor можно использовать аналогично элементу DOM, мы можем создать
двусторонняя привязка данных между двумя компонентами Razor. Обычно это тот случай, когда нам нужно
для связи между родительским и дочерним (внутренним или внешним) компонентами.
Мы можем связать параметр компонента внутреннего компонента со свойством внешнего компонента.
с синтаксисом @bind-{PROPERTY}. Заполнитель {PROPERTY} — это свойство для привязки. Мы
объяснил, что атрибут директивы @bind можно заменить двумя настройками односторонней привязки данных,
которые включают назначение переменной атрибуту значения <input> и назначение обработчика событий для
событие onchange. Обработчик события может быть автоматически добавлен компилятором для @bind, но
не для @bind-{PROPERTY}. Нам нужно определить собственное событие EventCallback<TValue>.
тип для привязки к параметрам компонента. Название события должно быть {PARAMETER NAME}Changed.
Давайте используем наш компонент EditorDialog, чтобы объяснить, как использовать @bind-{PROPERTY}
директивный атрибут.
В нашем коде мы редактируем поле с помощью EditorDialog в компоненте ItemDetail или редактируем элемент
используя то же самое в компоненте Items. Давайте используем редактирование поля в качестве примера:

```xml
<EditorDialog Id=@_dialogEditId
 @bind-Key="listGroupField.Key" ❶
 @bind-Value="listGroupField.Value" ❷
 IsKeyEditingEnable=@_isNewField OnSave="UpdateFieldAsync"
 KeyPlaceHolder="Field name" ValuePlaceHolder="Field
 content">
 @if (_isNewField) {
 <div class="form-check">
 <input class="form-check-input" type="checkbox"
 @bind="listGroupField.IsProtected"
 id="flexCheckDefault">
 <label class="form-check-label"
 for="flexCheckDefault">
 Password
 </label>
 </div>
 }
</EditorDialog>
```
В предыдущем коде компонента ItemDetail мы можем создать привязку данных Key ❶ и
Значение ❷ в listGroupField типа Field. Нам нужно реализовать {ПАРАМЕТР
NAME}Измененные события в коде C# EditorDialog, как показано здесь, в листинге 9.5:

**Листинг 9.5: EditorDialog.razor.cs (https://epa.ms/EditorDialog9-5)**

```Csharp
namespace PassXYZ.BlazorUI;
public partial class EditorDialog {
 [Parameter]
 public string? Id { get; set; }
 bool _isKeyEditingEnable = false;
 [Parameter]
 public bool IsKeyEditingEnable ...
 [Parameter]
 public EventCallback<bool>? IsKeyEditingEnableChanged {
 get; set; }
 string _key = string.Empty;
 [Parameter]
 public string Key { ❶
 get => _key;
 set {
 if(_key != value) {
 _key = value;
 KeyChanged?.InvokeAsync(_key); ❸
 }
 }
 }
 [Parameter]
 public EventCallback<string>? KeyChanged { get; set; } ❷
 [Parameter]
 public string? KeyPlaceHolder { get; set; }
 string _value = string.Empty;
 [Parameter]
 public string Value ...
 [Parameter]
 public EventCallback<string>? ValueChanged { get; set; }
 [Parameter]
 public string? ValuePlaceHolder { get; set; }
 [Parameter]
 public RenderFragment ChildContent { get; set; } =
 default!;
 [Parameter]
 public Action<string, string>? OnSave { get; set; }
 async Task<bool> OnSaveClicked() {
 OnSave?.Invoke(Key, Value);
 return true;
 }
}
```
В листинге 9.5 мы используем свойство Key в качестве примера для объяснения процесса параметризации компонента.
привязка. Свойство Key определяется как параметр компонента с атрибутом [Parameter].
Связанное событие определяется как KeyChanged типа EventCallback<TValue>. Когда
пользователь изменяет ввод текста и изменяет фокус элемента, вызывается установщик свойства Key.
Внутри установщика свойства Key он запускает событие KeyChanged, которое информирует внешний
Компонент ItemDetail. В результате связанная переменная listGroupField.Key обновляется.

# Взаимодействие с каскадными значениями и параметрами
  
Мы можем использовать привязку данных для передачи данных между родительским и дочерним компонентами. Привязка данных хороша для
передать данные промежуточному дочернему компоненту. Иногда мы можем захотеть передать данные компонентам
несколько уровней в глубину. Если мы используем привязку данных в этой ситуации, то мы должны создать несколько уровней
цепочка привязки данных. Сложность увеличивается с цепными уровнями. Например, если мы хотим пройти
данные из Items в ModalDialog, мы должны сначала создать привязку данных к ConfirmDialog. Затем,
необходимо создать другой уровень привязки данных между ConfirmDialog и ModalDialog.
В Items нам нужно передать диалоговое окно Id в ModalDialog. Нам нужно использовать диалоговое окно Id, чтобы идентифицировать
экземпляр диалога, который мы хотим отобразить. Как мы видим далее, мы определяем ConfirmDialog в Items
компонент. Id определяется в Items и передается в ConfirmDialog с помощью параметра компонента:

```xml
<ConfirmDialog Id="@_dialogDeleteId" Title=
 @listGroupItem.Name
 OnConfirmClick="DeleteItemAsync" />
```
Затем ConfirmDialog должен передать его ModalDialog:

```xml
<ModalDialog Id=@Id Title=@($"Deleting {Title}")
 OnSaveAsync=@OnSave
 SaveButtonText="Confirm" CloseButtonText="Cancel">
 Please confirm to delete @Title?
</ModalDialog>
```
В ModalDialog Id используется как атрибут элемента <div>:

```xml
<div class="modal fade" id=@Id tabindex="-1"
 aria-labelledby="ModelLabel" aria-hidden="true"> ...
```
Чтобы избежать многоуровневой привязки данных, мы можем использовать каскадные значения и параметры в качестве метода
поток данных вниз по иерархии компонентов.

CascadingValue — это компонент платформы Blazor. Внешний компонент обеспечивает
каскадное значение с помощью CascadingValue, а внутренний компонент может получить его с помощью
Атрибут [Каскадный Параметр]. Чтобы продемонстрировать использование, мы можем изменить код
Элементы компонента следующим образом:

```xml
<CascadingValue Value="@_dialogDeleteId" Name="Id">
 <ConfirmDialog Title=@listGroupItem.Name
 OnConfirmClick="DeleteItemAsync" />
</CascadingValue>
```
Мы используем каскадное значение с тегом <CascadingValue>. В теге <CascadingValue> мы
передать переменную_dialogDeleteId в атрибут Value и строку «Id» в Name
атрибут. Поскольку этот идентификатор не используется ConfirmDialog напрямую, параметр компонента Id может
быть удалены из ConfirmDialog.
В ModalDialog мы меняем свойство Id с параметра компонента на параметр, используя
атрибут [CascadingParameter]:

```Csharp
[CascadingParameter(Name = "Id")]
public string Id { get; set; } = default!;
```
Если у нас есть только одно каскадное значение, нам не нужно указывать имя каскадного значения. Компилятор
может помочь нам найти его по типу данных. Однако, чтобы избежать двусмысленностей, мы можем назвать каскадное значение
с помощью атрибута Имя. Давайте посмотрим на окончательные изменения в компоненте Items с помощью каскадного
значение для ConfirmDialog и EditorDialog:

```xml
<CascadingValue Value="@_dialogEditId" Name="Id">
 <EditorDialog @bind-Key="listGroupItem.Name"
 @bind-Value="listGroupItem.Notes"
 IsKeyEditingEnable=true
 OnSave="UpdateItemAsync" KeyPlaceHolder="Item name"
 ValuePlaceHolder="Please provide a description">
 @if (_isNewItem) {
 <select @bind="newItem.SubType" class="form-select"
 aria-label="Group">
 <option selected value=@ItemSubType.Group>
 @ItemSubType.Group</option>
 <option value=@ItemSubType.Entry>
  @ItemSubType.Entry</option>
 <option value=@ItemSubType.PxEntry>
 @ItemSubType.PxEntry</option>
 <option value=@ItemSubType.Notes>
 @ItemSubType.Notes</option>
 </select>
 }
 </EditorDialog>
</CascadingValue>
<CascadingValue Value="@_dialogDeleteId" Name="Id">
 <ConfirmDialog Title=@listGroupItem.Name
 OnConfirmClick="DeleteItemAsync" />
</CascadingValue>
```
Как мы видим, после того, как мы используем каскадное значение, ConfirmDialog и EditorDialog больше не нужны.
для обработки поля Id напрямую. Код стал более лаконичным, чем в предыдущей версии.
В этом разделе мы обсудили, как создавать повторно используемые компоненты. Некоторые компоненты Razor могут иметь
зависимости от данных или сетевых сервисов. Нам нужно предпринять дополнительные действия во время создания или
разрушение компонентов. Мы можем сделать это как часть управления жизненным циклом компонентов Razor.
Давайте рассмотрим жизненный цикл компонентов Razor в следующем разделе.
  
# Понимание жизненного цикла компонента

Компонент Razor имеет жизненный цикл, как и любой другой объект. Имеется набор синхронных и
асинхронные методы жизненного цикла, которые можно переопределить, чтобы помочь разработчикам выполнять дополнительные операции
во время инициализации и рендеринга компонента.

Мы можем просмотреть жизненный цикл компонента Razor на рис. 9.6:

![изображение](https://user-images.githubusercontent.com/26972859/231973462-56886bf8-f528-47f9-ade5-7a4391694eea.png)

Рисунок 9.6: Жизненный цикл компонента Razor

На рис. 9.6 видно, что мы можем добавлять обработчики на этапах инициализации и рендеринга. 
следующие методы могут быть переопределены для перехвата событий инициализации:

* Сетпараметерсасинк
* OnInitialized и OnInitializedAsync
* Онпараметрссет и онпараметрссетасинк

SetParametersAsync и OnInitialized(Async) вызываются только при первом рендеринге.
OnParametersSet(Async) вызывается каждый раз при изменении параметра.
Для настройки рендеринга можно переопределить следующие методы:
  
* Долженрендерить
* OnAfterRender и OnAfterRenderAsync

Мы подробно рассмотрим эти методы жизненного цикла и покажем, как мы их используем в нашем коде.

# SetParametersAsync

SetParametersAsync — это первый хук после создания объекта, и он имеет следующую сигнатуру:

```
public override Task SetParametersAsync(ParameterView parameters)
```
Параметр ParameterView содержит параметры компонента или каскадный параметр.
ценности. SetParametersAsync устанавливает значение каждого свойства с помощью [Parameter] или
Атрибут [Каскадный Параметр]. Эту функцию можно переопределить, чтобы добавить логику, которая требует
выполняться до установки параметров. Следующий хук после SetParametersAsync
OnInitialized{Async}.

# OnInitialized и OnInitializedAsync

OnInitialized и OnInitializedAsync вызываются при инициализации компонента.
Они имеют следующие подписи, соответственно:

```
protected override void OnInitialized()
protected override async Task OnInitializedAsync()
```
Переопределив эти две функции, мы можем добавить здесь логику для инициализации нашего компонента. Пожалуйста
известно, что они вызываются только один раз, сразу после создания компонента. Для отнимающих много времени
задачи инициализации, можно использовать асинхронный метод, например загрузку данных с помощью RESTful
вызовы API. Как видно на рис. 9.6, после завершения асинхронного метода DOM требуется
для повторного рендеринга.

# OnParametersSet and OnParametersSetAsync

Когда параметры компонента установлены или изменены, OnParametersSet и OnParametersSetAsync
вызываются. Мы видим, что есть две версии для обработки как синхронных, так и асинхронных
случаи. Асинхронную версию OnParametersSetAsync можно использовать для выполнения трудоемких задач. После завершения асинхронной задачи необходимо снова отобразить DOM.
для отражения любых изменений.
  
Методы имеют следующие сигнатуры соответственно:

```
protected override void OnParametersSet()
protected override async Task OnParametersSetAsync()
```

Эти два метода будут вызываться всякий раз, когда параметры компонента или каскадные параметры
измененный. Их можно вызывать несколько раз, тогда как OnInitialized{Async} вызывается только один раз.
Как мы видим на рис. 9.6, DOM может отображаться несколько раз на этапе инициализации.
из-за чего могут быть вызваны асинхронные вызовы. Методы, задействованные в процессе рендеринга,
ShouldRender и OnAfterRender{Async}.

# ShouldRender

Метод ShouldRender возвращает логическое значение, указывающее, должен ли компонент
быть оказано. Как видно на рис. 9.6, при первом рендеринге этот метод игнорируется, поэтому компонент должен
быть отрендерены хотя бы один раз. Этот метод имеет следующую сигнатуру:

```
protected override bool ShouldRender()
```

# OnAfterRender и OnAfterRenderAsync

OnAfterRender и OnAfterRenderAsync вызываются после завершения рендеринга компонента.
Они имеют следующие подписи, соответственно:

```Csharp
protected override void OnAfterRender(bool firstRender)
protected override async Task OnAfterRenderAsync(bool firstRender)
```
Их можно использовать для выполнения дополнительных задач инициализации с отображаемым содержимым, таких как вызов
Код JavaScript в компоненте. Этот метод имеет логический параметр firstRender, который позволяет
нам прикрепить обработчики событий JavaScript только один раз. Существует асинхронная версия этого метода,
но платформа не будет планировать дальнейший цикл рендеринга после завершения асинхронной задачи.
Чтобы посмотреть на влияние методов жизненного цикла, мы можем запустить тест, чтобы добавить все методы жизненного цикла в
Компонент ConfirmDialog, как вы можете видеть здесь:

```Csharp
public ConfirmDialog()
{
 Debug.WriteLine($"ConfirmDialog-{Id}: is created");
}
public override Task SetParametersAsync
 (ParameterView parameters)
{
 Debug.WriteLine($"ConfirmDialog-{Id}:
 SetParametersAsync called");
 return base.SetParametersAsync(parameters);
}
protected override void OnInitialized()
 => Debug.WriteLine($"ConfirmDialog-{Id}: OnInitialized
 called - {Title}");
protected override async Task OnInitializedAsync() =>
 await Task.Run(() => {
 Debug.WriteLine($"ConfirmDialog-{Id}: OnInitializedAsync
 called - {Title}");
});
protected override void OnParametersSet()
 => Debug.WriteLine($"ConfirmDialog-{Id}: OnParametersSet
 called - {Title}");
protected override async Task OnParametersSetAsync() =>
 await Task.Run(() => {
Debug.WriteLine($"ConfirmDialog-{Id}:
 OnParametersSetAsync called - {Title}");
});
protected override void OnAfterRender(bool firstRender)
 => Debug.WriteLine($"ConfirmDialog-{Id}: OnAfterRender
 called with firstRender = {firstRender}");
protected override async Task OnAfterRenderAsync(bool
 firstRender) => await Task.Run(() => {
 Debug.WriteLine($"ConfirmDialog-{Id}:
 OnAfterRenderAsync called - {Title}");
});
protected override bool ShouldRender() {
 Debug.WriteLine($"ConfirmDialog-{Id}: ShouldRender called
 - {Title}");
 return true;
}
```
Мы переопределяем все методы жизненного цикла в ConfirmDialog и добавляем вывод отладки, чтобы показать ход выполнения.
После того, как мы запустим наше приложение, мы увидим следующий вывод:

```
ConfirmDialog-: is created
ConfirmDialog-: SetParametersAsync called
ConfirmDialog-deleteModel: OnInitialized called -
ConfirmDialog-deleteModel: OnInitializedAsync called -
ConfirmDialog-deleteModel: OnParametersSet called -
ConfirmDialog-deleteModel: OnParametersSetAsync called -
ConfirmDialog-deleteModel: ShouldRender called -
ConfirmDialog-deleteModel: ShouldRender called -
ConfirmDialog-deleteModel: OnAfterRender called with
 firstRender = True
ConfirmDialog-deleteModel: OnAfterRenderAsync called -
ConfirmDialog-deleteModel: OnAfterRender called with
 firstRender = False
ConfirmDialog-deleteModel: OnAfterRenderAsync called -
ConfirmDialog-deleteModel: OnAfterRender called with
 firstRender = False
ConfirmDialog-deleteModel: OnAfterRenderAsync called -
```
Предыдущий вывод — это тот, когда мы просто запускаем наше приложение и отображается страница «Элементы». Мы можем
убедитесь, что каскадный параметр Id не задан до вызова метода SetParametersAsync.
Поскольку мы переопределяем асинхронные методы, существует несколько параллельных циклов рендеринга.
ShouldRender и OnAfterRender{Async} вызываются несколько раз из-за рендеринга
происходящие параллельно.
Давайте рассмотрим другой случай, когда мы нажимаем контекстное меню на странице «Элементы». Когда мы нажимаем на
контекстное меню элемента, такого как Google, ConfirmDialog инициализируется снова. Выход
следующее:

```
ConfirmDialog-deleteModel: SetParametersAsync called
ConfirmDialog-deleteModel: OnParametersSet called - Google
ConfirmDialog-deleteModel: ShouldRender called - Google
ConfirmDialog-deleteModel: OnParametersSetAsync called –
 Google
ConfirmDialog-deleteModel: ShouldRender called - Google
ConfirmDialog-deleteModel: OnAfterRender called with
 firstRender = False
ConfirmDialog-deleteModel: OnAfterRenderAsync called –
 Google
ConfirmDialog-deleteModel: OnAfterRender called with
 firstRender = False
ConfirmDialog-deleteModel: OnAfterRenderAsync called –
 Google
```
Метод SetParametersAsync вызывается снова, так как параметр компонента Title
измененный. Мы видим, что в последующих вызовах для параметра компонента Title установлено значение Google.

В нашем коде мы используем OnParametersSet для загрузки списка элементов в Items.razor.cs и загрузки
список полей в ItemDetail.razor.cs. Давайте рассмотрим OnParametersSet в ItemDetail.
razor.cs:

```Csharp
protected override void OnParametersSet() {
 base.OnParametersSet();
 if (SelectedItemId == null) { ❶
throw new InvalidOperationException(
 "ItemDetail: SelectedItemId is null");
 }
 selectedItem = DataStore.GetItem(SelectedItemId, true); ❷
 if (selectedItem == null) {
throw new InvalidOperationException(
 "ItemDetail: entry cannot be found with SelectedItemId");
 }
 else {
 if (selectedItem.IsGroup) {
 throw new InvalidOperationException(
 "ItemDetail: SelectedItemId should not be a group
 here.");
 }
 fields.Clear();
 List<Field> tmpFields = selectedItem.GetFields(); ❸
 foreach (Field field in tmpFields) {
 fields.Add(field);
 }
 notes = selectedItem.GetNotesInHtml();
 }
}
```
❶ В OnParametersSet проверяем, является ли параметр компонента SelectedItemId
нулевой. Это идентификатор выбранного элемента. ❷ Если он не нулевой, мы можем найти элемент, вызвав метод
Метод IDataStore с именем GetItem(). ❸ Получив экземпляр выбранного элемента, мы можем
получить список полей, вызвав метод GetFields().

В Items.razor.cs реализация OnParametersSet очень похожа на эту. Ты можешь
обратитесь к следующей ссылке GitHub, чтобы узнать подробности:
https://epa.ms/Items9-6
На данный момент у нас есть почти полнофункциональное приложение для управления паролями, и пользовательский интерфейс этого приложения построен на
Блейзор. Мы создали многоразовые компоненты модального диалога для поддержки контекстного меню, чтобы мы могли выполнять
CRUD-операции. Последняя часть головоломки — это реализация операций CRUD.

# Реализация CRUD-операций

Как только мы подготовили модальные диалоги, которые будут использоваться в операциях CRUD из предыдущих разделов,
мы можем реализовать операции CRUD в этом разделе.

# CRUD-операции с элементами

Чтобы добавить или обновить элемент, мы можем использовать метод UpdateItemAsync() в Items.razor.cs.
для обработки обоих случаев. Чтобы определить, хотим ли мы создать новый элемент или обновить существующий, мы
определите частное поле _isNewItem следующим образом:

```
bool _isNewItem = false;
```

Далее мы увидим, как добавить или изменить элемент.

# Добавление нового элемента

Чтобы добавить новый элемент, мы можем нажать кнопку + в заголовке страницы «Элементы», как показано на рис. 9.7:

![изображение](https://user-images.githubusercontent.com/26972859/231975375-81c64323-505d-4b88-8223-e8dd86d9cf53.png)

Рисунок 9.7: Добавление нового элемента

Разметку Razor для этого заголовка страницы можно посмотреть здесь:

```
<div class="container"><div class="row">
 <div class="col-12"><h1>
 @if (selectedItem?.GetParentLink() != null) {
  <a class="btn btn-outline-dark"
 href="@selectedItem?.GetParentLink()">
 <span class="oi oi-chevron-left"
 aria-hidden="true"></span></a> ❶
 }
 @(" " + Title) ❷
<button type="button"
 class="btn btn-outline-dark float-end"
 data-bs-toggle="modal"
 data-bs-target="#@_dialogEditId"
 @onclick="@(() => _isNewItem=true)">
 <span class="oi oi-plus" aria-hidden="true">
 </span></button> ❸
 </h1></div>
</div></div>
```
В заголовке страницы отображается кнопка «Назад» ❶, заголовок ❷ и кнопка «Добавить» ❸. Кнопка «Назад»
отображается, если родительская ссылка существует.

При нажатии кнопки «Добавить» отображается модальное диалоговое окно с идентификатором, определенным в _dialogEditId.
переменная. Обработчик события onclick просто устанавливает для _isNewItem значение true, поэтому событие модального диалога
обработчик знает, что это действие по добавлению нового элемента.

# Редактирование или удаление элемента

Чтобы отредактировать или удалить элемент, мы можем щелкнуть контекстное меню элемента, как показано на рисунке 9.8:

![изображение](https://user-images.githubusercontent.com/26972859/231975651-7e855be4-f06f-4722-ad99-fcb8361293bf.png)

Рисунок 9.8: Редактирование или удаление элемента

После того, как мы нажмем на кнопку контекстного меню, отобразится список пунктов меню. Давайте рассмотрим
разметка для контекстного меню в Items.razor выглядит следующим образом:

```
<div class="list-group">
 @foreach (var item in items) {
<div class="dropdown list-group-item list-group-item-action
 d-flex gap-1 py-2" aria-current="true">
 <img src="@item.GetIcon()" alt="twbs" width="32"
 height="32"
 class="rounded-circle flex-shrink-0 float-start">
 <a href="@item.GetActionLink()" class="..."> ...
 <button class="opacity-50 btn btn-light
 dropdown-toggle" type="button"
 id="itemsContextMenu"
 data-bs-toggle="dropdown" aria-expanded="false"
 @onclick="@(() => listGroupItem=item)"> ❶
 <span class="oi oi-menu" aria-hidden="true"></span>
 </button>
 <ul class="dropdown-menu" aria-labelledby=
 "itemsContextMenu">
 <li><button class="dropdown-item"
 data-bs-toggle="modal"
 data-bs-target="#@_dialogEditId"
 @onclick="@(() => _isNewItem=false)"> ❷
 Edit</button></li>
 <li><button class="dropdown-item"
 data-bs-toggle="modal"
 data-bs-target="#@_dialogDeleteId"> ❸
 Delete</button></li>
 </ul>
 </div>
 }
</div>
```
Существует кнопка контекстного меню ❶, определенная в предыдущем коде разметки. При нажатии этой кнопки
два пункта меню, Редактировать ❷ и Удалить ❸, будут отображаться. Поскольку код разметки контекста
меню работает в цикле foreach, нам нужно получить ссылку на выбранный элемент, чтобы отредактировать или удалить его. В
логика кода программной части C#, переменная listGroupItem используется для ссылки на выбранный элемент. Мы
может поймать ссылку в обработчике события onclick кнопки контекстного меню.
Когда выбран пункт меню «Правка», нам нужно установить переменную _isNewItem в значение false, чтобы
обработчик событий модального диалога может знать, что мы редактируем существующий элемент.
Со всеми предыдущими настройками давайте рассмотрим обработчик событий в модальных диалогах. Давайте рассмотрим
Сначала обработчик событий UpdateItemAsync() в Items.razor.cs:

```Csharp
private async void UpdateItemAsync(string key, string value) {
 if (listGroupItem == null) { return; }
 if (string.IsNullOrEmpty(key) || string.IsNullOrEmpty
 (value))
 { return; }
 listGroupItem.Name = key;
 listGroupItem.Notes = value;
 if (_isNewItem) { ①
 // Add new item
 if (listGroupItem is NewItem aNewItem) {
 Item? newItem = DataStore.CreateNewItem
 (aNewItem.SubType);
 if (newItem != null) {
 newItem.Name = aNewItem.Name;
 newItem.Notes = aNewItem.Notes;
 items.Add(newItem);
 await DataStore.AddItemAsync(newItem);
 }
 }
 }
 else {
 // Update the current item
 await DataStore.UpdateItemAsync(listGroupItem);
 }
}
```

Обработчик событий UpdateItemAsync() может обрабатывать как добавление, так и редактирование элемента. Как мы можем
видите, он проверяет переменную _isNewItem ①, чтобы определить, хотим ли мы добавить или отредактировать элемент. После
что он вызывает методы IDataStore для обработки действий добавления или обновления.
Далее рассмотрим обработчик события удаления элемента:

```Csharp
private async void DeleteItemAsync() {
 if (listGroupItem == null) return;
 if (items.Remove(listGroupItem)) {
 _ = await DataStore.DeleteItemAsync
 (listGroupItem.Id);
 }
}
```
В обработчике события DeleteItemAsync() он просто удаляет элемент из списка и вызывает
Методы IDataStore для обработки действия удаления.

# CRUD-операции полей

Операции CRUD с полями аналогичны тому, что мы сделали для элементов. Чтобы добавить или обновить поле,
мы можем использовать метод UpdateFieldAsync() в ItemDetail.razor.cs для обработки обоих
случаи. Чтобы определить, хотим ли мы создать новое поле или обновить существующее поле, мы определяем частный
Поле _isNewField выглядит следующим образом:

```Csharp
bool _isNewField = false;
```
Пользовательский интерфейс операций CRUD также аналогичен тому, что мы объяснили в предыдущем разделе. Пожалуйста
Обратитесь к рисунку 9.9, чтобы увидеть кнопку «Добавить» и элементы контекстного меню:

![изображение](https://user-images.githubusercontent.com/26972859/231976158-e0d39a4b-416a-4b19-b968-5a2d17828dac.png)

Рисунок 9.9: Добавление, редактирование или удаление поля

Мы можем просмотреть код разметки Razor заголовка страницы в IwwtemDetail.razor следующим образом:

```
<div class="container">
 <div class="row"><div class="col-12">
 <h1>
 @if (selectedItem?.GetParentLink() != null) {
 <a class="btn btn-outline-dark"
 href="@selectedItem?.GetParentLink()">
 <span class="oi oi-chevron-left"
 aria-hidden="true"></span></a>
  }
 @(" " + selectedItem!.Name)
 <button type="button" class="btn btn-outline-dark
 float-end"
 data-bs-toggle="modal" data-bs-
 target="#@_dialogEditId"
 @onclick="@(() => _isNewField=true)">
 <span class="oi oi-plus"
 aria-hidden="true"></span></button>
 </h1>
 </div></div>
</div>

```

Как мы видим, предыдущий исходный код также похож на код в Items.razor, за исключением
Переменная _isNewItem заменена на _isNewField. Мы можем улучшить этот заголовок страницы, сделав его многоразовым.
компонент позже.
Как и в предыдущем разделе, давайте рассмотрим исходный код группы списка и контекстного меню:

```
<div class="list-group">
 @foreach (var field in fields) {
 @if(field.ShowContextAction == null) {
 <div class="dropdown list-group-item ...
 aria-current="true">
 <span class="oi oi-pencil" aria-hidden="true">
 </span>
 <div class="d-flex gap-2 w-100
 justify-content-between"> ...
 <button class="opacity-50 btn btn-light
 dropdown-toggle" type="button"
 id="itemDetailContextMenu"
 data-bs-toggle="dropdown" aria-expanded="false"
 @onclick="@(() => listGroupField=field)"> ❶
 <span class="oi oi-menu" aria-hidden="true">
 </span>
 </button>
 <ul class="dropdown-menu"
 aria-labelledby="itemDetailContextMenu">
  <li><button class="dropdown-item"
 data-bs-toggle="modal"
 data-bs-target="#@_dialogEditId"
 @onclick="@(() => _isNewField=false)"> ❷
 Edit
 </button></li>
 <li><button class="dropdown-item"
 data-bs-toggle="modal"
 data-bs-target="#@_dialogDeleteId"> ❸
 Delete
 </button></li>
 @if (field.IsProtected) {
 <li><button class="dropdown-item"
 @onclick="OnToggleShowPassword"> ❹
 @if (field.IsHide) { <span>Show</span> }
 else { <span>Hide</span> }
 </button></li>
 }
 </ul>
 </div>
 }
 }
</div>
```
Предыдущий исходный код ItemDetail.razor включает кнопку контекстного меню ❶ и три
кнопки для пунктов меню Добавить ❷, Изменить ❸ и Показать ❹. Вы можете видеть, что исходный код также
аналогичен элементу в Items.razor, который включает в себя группу списков и контекстное меню. Мы будем уточнять
это повторно используемый компонент в следующей главе. Разница в контекстном меню в том, что мы добавляем
пункт меню, чтобы отобразить или скрыть поле, если поле является защищенным полем, например, пароль. Мы используем
обработчик события onclick, OnToggleShowPassword(), чтобы установить свойство поля IsHide для переключения
видимость поля пароля.
Наконец, давайте рассмотрим обработчики событий модальных диалогов в ItemDetail.razor.cs:

```Csharp
private async void UpdateFieldAsync(string key, string
 value) {
 if (selectedItem == null || listGroupField == null) {
 throw new NullReferenceException("Selected item is
 null");
  }
 if (string.IsNullOrEmpty(key) ||
 string.IsNullOrEmpty(value)) { return; }
 listGroupField.Key = key;
 listGroupField.Value = value;
 if (_isNewField) {
 // Add a new field
Field newField =
 selectedItem.AddField(listGroupField.Key,
 ((listGroupField.IsProtected) ?
 listGroupField.EditValue :
 listGroupField.Value),
 listGroupField.IsProtected);
 fields.Add(newField);
 }
 else {
 // Update the current field
 var newData = (listGroupField.IsProtected) ?
 listGroupField.EditValue : listGroupField.Value;
selectedItem.UpdateField(listGroupField.Key,
 newData, listGroupField.IsProtected);
 }
 await DataStore.UpdateItemAsync(selectedItem);
}
```
The UpdateFieldAsync() event handler handles both adding and editing a field. It is called with
two parameters – key and value. The corresponding arguments are passed from the modal dialog
and we use them to set the field of listGroupField. The handler checks the _isNewField
variable to detect whether we want to add or edit a field. After that, it calls IDataStore methods
to process add or update actions.
To remove a field, the following DeleteFieldAsync() event handler is invoked:

```Csharp
private async void DeleteFieldAsync() {
 if (listGroupField == null || selectedItem == null) {
 throw new NullReferenceException(
 "Selected item or field is null");
 }
 listGroupField.ShowContextAction = listGroupField;
 selectedItem.DeleteField(listGroupField);
 await DataStore.UpdateItemAsync(selectedItem);
}
```
In the DeleteFieldAsync() event handler, we just delete the field from the selected item and
call the IDataStore method to update the database.
With the implementation of CRUD operations, we have concluded this section. Now, we have a new
version of the password manager app using Blazor UI. The difference between this version and the
one in Part 1 of this book is that we use Blazor to build all UIs. The look and feel of Blazor UI are
similar to web apps, while XAML UI is the same as native apps.

# Summary

In this chapter, we introduced how to create Razor components. We learned about data binding
and the component lifecycle. After that, we created a set of modal dialog components to clean up
our code. With Razor components, we can remove duplicated code and improve the UI design. We
implemented CRUD operations in the event handlers of modal dialogs. We now have a new version
of the password manager app.
During the code analysis, we can see that we still have redundant code in the two main components,
Items and ItemDetail. Even though we optimized modal dialogs, we still have duplicated code
in the list group and context menu. We will convert them to Razor components in the next chapter.











































































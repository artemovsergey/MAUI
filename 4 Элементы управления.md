# Размеры и позиционирование элементов на странице

## Ширина и высота

В обычном случае ширина и высота устанавливается контейнером компоновки. Тем не менее в некоторых случаях может потребоваться явным образом установить высоту и ширину. И для этого у визуальных элементов применяются свойства WidthRequest и HeightRequest - они устанавливают соответственно предпочтительную ширину и высоту:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <Grid>
        <Button Text="Click" WidthRequest="100" HeightRequest="50" />
    </Grid>
</ContentPage>
```
В данном случае для кнопки устанавливается предпочтительная ширина в 100 единиц и предпочтительная высота в 50 единиц

!(https://metanit.com/sharp/maui/pics/4.47.png)

Аналог в коде C#:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    public StartPage()
    {
        Button button = new Button 
        { 
            WidthRequest = 100, 
            HeightRequest = 50, 
            Text = "Click"
        };
        Content = new Grid { Children = { button } };
    }
}
```
# Отступы

Для установки отступов у элементов применяются свойства Margin и Padding. Свойство Margin определяет внешний отступ элемента от других элементов или контейнера. А свойство Padding устанавливает внутрение отступы - от внутреннего содержимого элемента до его границ. Оба этих свойства представляют структуру Thickness, которая позволяет определить отступы с помощью одного из своих конструкторов:

```Csharp
public Thickness(double uniformSize);
public Thickness(double horizontalSize, double verticalSize);
public Thickness(double left, double top, double right, double bottom);
```
Первая версия конструктора задает общий отступ от всех четерех сторон. Вторая форма задает отдельные отступы по горизонтали и вертикали. И третья форма конкретизирует отступы от всех четырех сторон.

Например, установим отступы в коде C#:

```Csharp
class StartPage : ContentPage
{
    public StartPage()
    {
        var stackLayout = new StackLayout
        {
            Padding = new Thickness(60),
            Children = 
            {
                new BoxView { Color = Colors.Blue, Margin = new Thickness (50), HeightRequest = 100 },
                new BoxView { Color = Colors.Red, Margin = new Thickness (50), HeightRequest = 100 }
            }
        };
        Content = stackLayout;
    }
}
```
Здесь для контейнера StackLayout задается внутренний отступ в 60 единиц (Padding = new Thickness(60)). То есть вложенные элементы будут иметь отступы от границ StackLayout в 60 единиц.

Кроме того, для каждого из двух BoxView задано свойство Margin, которое устанавливает внешний отступ в 50 единиц.

!(https://metanit.com/sharp/maui/pics/4.1.png)

Аналогичный пример в XAML:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="60">
        <BoxView Color="Blue" Margin="50" HeightRequest="100" />
        <BoxView Color="Red"  Margin="50" HeightRequest="100" />
    </StackLayout>
</ContentPage>
```
Подобным образом можно использовать и другие конструкторы структуры Thickness для установки отступов. Например, используем все три конструктора в коде C#:


```Csharp
public class StartPage : ContentPage
{
    public StartPage()
    {
        var stackLayout = new StackLayout
        {
            Padding = new Thickness(0, 20, 0, 0),
            Children = {
                new BoxView { Color = Colors.Green, Margin = new Thickness (20) },
                new BoxView { Color = Colors.Blue, Margin = new Thickness (10, 25) },
                new BoxView { Color = Colors.Red, Margin = new Thickness (0, 20, 15, 5) }
            }
        };
        Content = stackLayout;
    }
}
```
Определение в XAML:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="0,20,0,0">
        <BoxView Color="Green" Margin="20" />
        <BoxView Color="Blue" Margin="10, 15" />
        <BoxView Color="Red" Margin="0, 20, 15, 5" />
    </StackLayout>
</ContentPage>
```
В отношении отступов надо учитывать следующий момент: так как на устройствах с iOS верхняя панель занимает 20 единиц, то для iOS желательно устанавливать отступ сверху размером как минимум в 20 единиц, чтобы текст метки не налазил на верхнюю панель.

В этом случае мы можем глобально установить отступ сверху для всех платформ в 20 или более единиц. Либо можно задать отступ непосредственно только для iOS:

```Csharp
public class MainPage : ContentPage
{
    public MainPage()
    {
        Label header = new Label() { Text = "Hello METANIT.COM!" };
             
        Content = header;
        if (DeviceInfo.Platform == DevicePlatform.iOS)
            Padding = new Thickness(0, 20, 0, 0);
    }
}
```
В данном случае с помощью значения DeviceInfo.Platform мы можем получить данные о текущей платформе в виде структуры DevicePlatform, на которой запущено приложение, и сравнить ее. Значение "DevicePlatform.iOS" означает, что текущая платформа - iOS. И в этом случае можно установить определенный отступ.

# Выравнивание по горизонтали и вертикали

Все элементы, используемые при создании интерфейса, наследуются от класса View, который определяет два свойства HorizontalOptions и VerticalOptions. Они управляют выравнивание элемента соответственно по горизонтали и по вертикали.

В качестве значения они принимают структуру LayoutOptions. Данная структура имеет ряд свойств, которые хранят объекты опять же LayoutOptions:

Start: выравнивание по левому краю (выравнивание по горизонтали) или по верху (выравнивание по вертикали)

Center: элемент выравнивается по центру

End: выравнивание по правому краю (выравнивание по горизонтали) или по низу (выравнивание по вертикали)

Fill: элемент заполняет все пространство контейнера

Зададим выравнивание в коде C#:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            Label header = new Label() { Text = "Hello METANIT.COM!" };
            header.VerticalOptions = LayoutOptions.Center;
            header.HorizontalOptions = LayoutOptions.Center;
 
            Content = header;
        }
    }
}
```
в данном случае метка header располагается ровно по центру (как по горизонтали, так и по вертикали) родительского контейнера, в качестве которого здесь выступает сама страница StartPage.

!(https://metanit.com/sharp/maui/pics/4.2.png)

Пример в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
 
    <Label Text="Hello METANIT.COM" VerticalOptions="Center" HorizontalOptions="Center" />
 
</ContentPage>
```

## Работа с цветом

За установку цвета фона и текста элементов отвечают свойства BackgroundColor и TextColor соответственно. В качестве значение они принимают объект класса Microsoft.Maui.Graphics.Color:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            Label header = new Label() { Text = "Hello METANIT.COM" };
            header.HorizontalTextAlignment = TextAlignment.Center;
            header.VerticalTextAlignment = TextAlignment.Center;
 
            header.BackgroundColor = Colors.LightBlue;  // фоновый цвет
            header.TextColor = Colors.DarkBlue;         // цвет текста
            Content = header;
        }
    }
}
```
В данном случае для определения цвета применялись встроенные готовые цвета из статического класса Colors.

!(https://metanit.com/sharp/maui/pics/4.3.png)

Или в XAML:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <Label Text="Hello METANIT.COM"
           VerticalOptions="Center" HorizontalOptions="Center"
           BackgroundColor="LightBlue" TextColor="DarkBlue"
           />
</ContentPage>
```

Кроме встроенных готовых цветов типа Colors.DarkBlue (так называемых именнованных цветов) также для установки цвета мы можем указать и другие значения, можно использовать один из конструкторов класса Color. Некоторые из них:

- new Color(float grayShade): устанавливает тон серого цвета

- new Color(float r, float g, float b): устанавливает компоненты красного, зеленого и синего. Каждая компонента должна иметь значения в диапазоне от 0.0 до 1.0

- new Color(byte r, byte g, byte b): устанавливает компоненты красного, зеленого и синего. Каждая компонента должна иметь значения в диапазоне от 0 до 255

- new Color(float r, float g, float b, float a): добавляет еще один параметр - a, который передает прозрачность и имеет значение от 0.0 (полностью прозрачный) до 1.0 (не прозрачный)

- new Color(byte r, byte g, byte b, byte a): устанавливает компоненты красного, зеленого, синего и прозрачности

Использование конструктора:

```Csharp
Label header = new Label() { Text = "Hello METANIT.COM" };
 
header.BackgroundColor = new Color(178, 223, 219);
header.TextColor = new Color(0, 77, 64);
```

!(https://metanit.com/sharp/maui/pics/4.4.png)


Также для установки цвета мы можем использовать ряд статических методов:

- Color.FromArgb(string hex): возвращает объект Color, созданный по переданному в качестве параметра шестнадцатеричному значению. В качестве значения в метод передается строка в формате "#AARRGGBB", "#RRGGBB", "#ARGB" или "RGB", где A - показатель прозрачности, R - значение для красного цвета, G - значение для зеленого компонента и B - представляет синий цвет

- Color.FromRgb(double r, double g, double b): возвращает объект Color, для которого также устанавливаются компоненты красного, зеленого и синего

- Color.FromRgb(int r, int g, int b): аналогичен предыдущей версии метода, только теперь компоненты красного, зеленого и синего имеют целочисленные значения от 0 до 255

- Color.FromRgba(double r, double g, double b, double a): добавляет параметр прозрачности со значением от 0.0 (полностью прозрачный) до 1.0 (не прозрачный)

- Color.FromRgba(int r, int g, int b, int a): добавляет параметр прозрачности со значением от 0 (полностью прозрачный) до 255 (не прозрачный)

- Color.FromHsla(double h, double s, double l, double a): устанавливает последовательно параметры h (hue - тон цвета), s (saturation - насыщенность), l (luminosity - яркость) и прозрачность.

Например:

```Csharp
Label header = new Label() { Text = "Hello METANIT.COM" };
 
header.BackgroundColor = Color.FromArgb("#B2DFDB");
header.TextColor = Color.FromArgb("#aa004D40");
```
В xaml мы можем задавать цвет с помощью шестнадцатеричных значений также, как в HTML/CSS:

```Csharp
<Label Text="Hello METANIT.COM" BackgroundColor="#B2DFDB" TextColor="#aa004D40" />
```

# Управление цветом

Стоит отметить, что у класса Color определено ряд дополнительных методов, которые позволяют управлять цветом. В частности, ряд методов позволяются выполнять преобразования

- ToHex: возвращает шестнадцатеричное значение текущего цвета в виде строки.

- ToArgbHex: возвращает шестнадцатеричное значение текущего цвета в виде строки в формате ARGB

- ToRgbaHex: возвращает шестнадцатеричное значение текущего цвета в виде строки в формате RGBA

- ToInt: возвращает числовое ARGB-представление текущего цвета в виде значения int

- ToUint: возвращает числовое ARGB-представление текущего цвета в виде значения uint

- ToRgb: преобразует текущей цвет в отдельные компоненты RGB типа byte

- ToRgba: преобразует текущей цвет в отдельные компоненты RGBA типа byte

- ToHsl: преобразует текущей цвет в отдельные компоненты HSL типа float

Кроме того, у класса Color есть ряд дополнительных методов для управления отдельными аспектами цвета

- AddLuminosity: добавляет цвету яркость

- MultiplyAlpha: умножает альфа-компоненту (прозрачность) цвета на переданное значение типа float

- WithAlpha: заменяет альфа-компоненту цвета

- WithHue: заменяет тон цвета

- WithLuminosity: заменяет яркость цвета

- WithSaturation: заменяет насыщенность цвета

Применение некоторых методов:

```Csharp
Label header = new Label() { Text = "Hello METANIT.COM" };
 
Color customColor = Colors.Teal;
customColor = customColor.WithAlpha(0.5f);
customColor = customColor.WithHue(0.5f);
customColor = customColor.WithLuminosity(0.9f);
 
header.BackgroundColor = customColor;
```

# Стилизация текста

Для стилизации текста у элементов управления .NET MAUI имеют ряд свойств:

- FontFamily: устанавливает применяемое семейство шрифтов в виде значения типа string

- FontSize: устанавливает высоту шрифта в виде значения double

- FontAttributes: устанавливает дополнительные визуальные эффекты шрифта - выделение жирным или курсивом

- FontAutoScalingEnabled: указывает, будет ли для шрифта использоваться масштабирование, установленное в системе. Принимает значение bool - если масштабирование применяется, то используется значение true. По умолчанию значение true.

Для установки семейства используемых шрифтов свойству FontFamily в качестве значения передается название шрифта. Однако при установке шрифта надо учитывать, что данный шрифт должен поддерживаться на всех используемых платформах. Например, установка в коде:

```Csharp
Label header = new Label() { Text = ".NET MAUI in Arial" };
header.FontFamily = "Arial";
```

Установка в XAML:

```xml
<Label Text=".NET MAUI in Arial" FontFamily="Arial" />
```
# Свойство FontSize

Для установки высоты шрифта используется значение типа double:

```Csharp
Label header = new Label() { Text = ".NET MAUI" };
header.FontSize = 26;
```

Установка в XAML:

```xml
<Label Text=".NET MAUI" FontSize="26" />
```

# FontAttributes

FontAttributes позволяет выделить текст жирным или курсивом. Для этого он принимает значение из перечисления FontAttributes:

- Bold: выделение жирным

- Italic: выделение курсивом

Применение:

```Csharp
Label label1 = new Label
{
    Text = "Bold",
    FontAttributes = FontAttributes.Bold
};
 
Label label2 = new Label
{
    Text = "Bold и Italics",
    // сочетание значений
    FontAttributes = FontAttributes.Bold | FontAttributes.Italic
};
```

В xaml:

```xml
<Label Text="Bold" FontAttributes="Bold" />
<Label Text="Bold и Italics" FontAttributes="Bold, Italic" />
```

# Регистрация шрифтов

Использование своих или каких-то кастомных шрифтов на сегодняшний день достаточно распространенная задача. Механизм MAUI предельно ее упрощает. Прежде всего, если мы хотим использовать кастомные шрифты в формате TTF (True Type Format) или OTF (Open Type Font), нам надо добавить их файлы в проект в папку Resources/Fonts. Так, в проекте по умолчанию в этой папке уже есть два шрифта:

!(https://metanit.com/sharp/maui/pics/4.5.png)

Для регистрации добавленныъ шрифтов применяется метод ConfigureFonts() объекта MauiAppBuilder (по умолчанию это делается в файле MauiProgram.cs). В метод ConfigureFonts передается объект IFontCollection (коллекция шрифтов), у которого можно вызвать метод AddFont для добавления шрифта:

```Csharp
var builder = MauiApp.CreateBuilder();
builder
    .UseMauiApp<app>()
    .ConfigureFonts(fonts =>
    {
        fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
        fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold");
});
</app>
```

В метод AddFont передается название файла шрифта и его псевдоним.

После регистрации шрифта мы сможем обращаться к нему в коде C# или XAML через его псевдоним. Например, второй добавленный шрифт имеет псевдоним "OpenSansSemibold", используем его

```Csharp
Label label1 = new Label
{
    Text = "OpenSansSemibold",
    FontSize = 22,
    FontFamily = "OpenSansSemibold" // устанавливаем шрифт по его псевдониму
};
```

# Выравнивание текста внутри элемента

Элементы управления, которые реализуют интерфейс ITextAlignment, позволяют настроить выравнивание текста. Выравнивание текста по горизонтали и вертикали задается с помощью свойств HorizontalTextAlignment и VerticalTextAlignment соответственно. В качестве значения эти свойства принимают одну из констант перечисления TextAlignment:

- Start: текст выравнивается по левому краю по горизонтали или по верху по вертикали

- Center: текст выравнивается по центру

- End: текст выравнивается по правому краю по горизонтали или по низу по вертикали

Пример на c#:

```Csharp
Label header = new Label() { Text = "Hello METANIT.COM!" };
header.HorizontalTextAlignment = TextAlignment.Center;
header.VerticalTextAlignment = TextAlignment.Center;
```

В xaml:

```xml
<Label Text="Hello METANIT.COM!" VerticalTextAlignment="Center" HorizontalTextAlignment="Center" />
```

# Кнопки

Класс Button представляет кнопку. Кнопка отображает некоторый текст и может реагировать на нажатия.

Кнопка имеет много различных свойств, из которых следует выделить следующие:

- FontFamily: шрифт, который используется для текста на кнопке

- FontSize: размер текста на кнопке

- FontAttributes: выделение жирным или курсивом текста на кнопке

- FontAutoScalingEnabled: указывает, будет ли текст кнопки масштабироваться в соответствии с настройками системы

- LineBreakMode: объект типа LineBreakMode, который указывает, как будет переноситься текст кнопки

- TextColor: цвет шрифта

- BorderColor: цвет границы

- BorderWidth: ширина границы

- ImageSource: позволяет задать изображение на кнопке

Для взаимодействия с пользователем у класса Button определено ряд событий, в частности:

- Clicked: событие нажатия пальцем или указателем мыши на кнопку. Событие срабатывает, когда пользователь убирает палец или мышь с кнопки

- Pressed: событие нажатия пальцем или указателем мыши на кнопку. Событие срабатывает, когда палец пользователя или мышь находятся на кнопке

- Released: событие нажатия пальцем или указателем мыши на кнопку. Событие срабатывает, когда пользователь убрал палец или мышь с кнопки

Создадим кнопку в коде:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            Grid grid = new Grid(); 
 
            Button button = new Button
            {
                Text = "Нажми",
                FontSize = 22,
                BorderWidth = 1,
                BackgroundColor = Colors.LightPink,
                TextColor = Colors.DarkRed,
                HorizontalOptions = LayoutOptions.Center,
                VerticalOptions = LayoutOptions.Center
            };
            button.Clicked += OnButtonClicked;
 
            grid.Children.Add(button);
            Content = grid;
        }
 
        private void OnButtonClicked(object sender, System.EventArgs e)
        {
            Button button = (Button)sender;
            button.Text = "Нажато!";
        }
    }
}
```

С помощью метода OnButtonClicked здесь определяется обработчик нажатия кнопки. Обработчик во многим аналогичен стандартным обработчикам в Windows Forms. Он принимает два параметра: объект типа object (источника события) и System.EventArgs (аргумент события, хранящий некоторую дополнительную информацию). В данном случае по нажатию просто изменяем текст и цвет фона кнопки.

Аналогичная кнопка в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <Grid>
        <Button Text="Нажми" FontSize="22" BorderWidth="1"
                BackgroundColor="LightPink" TextColor="DarkRed"
        HorizontalOptions="Center" VerticalOptions="Center"
        Clicked="OnButtonClicked" />
    </Grid>
</ContentPage>
```

И тогда в файле отделенного кода MainPage.xaml.cs еще надо прописать обработчик OnButtonClicked:

```Csharp
namespace HelloApp
{
    public partial class MainPage : ContentPage
    {
        public MainPage()
        {
            InitializeComponent();
        }
        private void OnButtonClicked(object sender, System.EventArgs e)
        {
            Button button = (Button)sender;
            button.Text = "Нажато!";
        }
    }
}
```

# Label

Label представляет обычную текстовую метку, которая выводит информацию с помощью свойства Text. Label удобен для создания заголоков и меток к элементам ввода. Основные свойства Label:

- CharacterSpacing: расстояние между символами в тексте в виде значения типа double

- FontAttributes: определяет стиль текста

- FontAutoScalingEnabled: значение типа bool, устанавливает, будет ли к тексту применяться системное масштабирование

- FontFamily: семейство шрифтов в виде строки

- FontSize: размер шрифта (значение типа double)

- FormattedText: представляет отформатированный текст в виде объекта FormattedString

- LineBreakMode: значение типа LineBreakMode, которое определяет, как будет производиться перенос строки, если текст не вмещается

- LineHeight: высота строки (значение типа double)

- MaxLines: максимальное допустимое количество строк

- Padding: внутренний отступ

- Text: текст метки

- TextColor: цвет текста

- TextDecorations: декорации текста (его подчеркивание или вчеркивание) (значение типа TextDecorations)

- TextTransform: объект типа TextTransform, который определяет преобразование текста

- TextType: значение типа TextType, которое определяет тип текста - обычный текст или html

- HorizontalTextAlignment: значение TextAlignment, которое определяет выравнивание текста по горизонтали

- VerticalTextAlignment: значение типа TextAlignment, которое определяет выравнивание текста по вертикали

Пример простейшей метки

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            Grid grid = new Grid();
 
            Label label = new Label
            {
                Text = "Hello METANIT.COM!",
                TextDecorations = TextDecorations.Underline,
                CharacterSpacing = 2,
                FontAttributes = FontAttributes.Bold,
                FontFamily = "Helvetica",
                FontSize = 22,
                VerticalOptions = LayoutOptions.Center,
                HorizontalOptions = LayoutOptions.Center
            };
 
            grid.Children.Add(label);
            Content = grid;
        }
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.7.png)


Аналогичный пример в XAML:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <Grid>
        <Label FontSize="22" Text = "Hello METANIT.COM!"
             TextDecorations = "Underline" CharacterSpacing = "2"
             FontAttributes = "Bold" FontFamily = "Helvetica"
            HorizontalOptions="Center" VerticalOptions="Center"
         />
    </Grid>
</ContentPage>
```

# Форматирование текста

Свойство Text элемента Label позволяет устанавливать простой текст, который мы можем стилизовать с помощью ранее рассмотренных свойств. Однако текст с каким-то более сложным форматированием так не задать. И для этого в элементе Label определено вспомогательное свойство FormattedText, которое допускает сложное форматирование.

Свойство FormattedText хранит не просто строку текста, а объект типа FormattedString, который инкапсулирует объекты типа Span. Каждый объект Span как раз и представляет кусок некоторым образом стилизованного текста. Для стилизации объекта Span применются все те же свойства:

- Text

- FontFamily

- FontSize

- FontAttributes

- TextColor

- BackgroundColor

Например,создадим текст со сложным форматированием в коде:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            Grid grid = new Grid();
 
            Label header = new Label();
 
            FormattedString formattedString = new FormattedString();
            formattedString.Spans.Add(new Span
            {
                Text = "Сегодня ",
                FontSize = 22
            });
            formattedString.Spans.Add(new Span
            {
                Text = "хорошая",
                TextColor = Colors.DarkRed,
                BackgroundColor = Colors.LightPink,
            });
            formattedString.Spans.Add(new Span
            {
                Text = " погода!",
                FontAttributes = FontAttributes.Bold
            });
            header.FormattedText = formattedString;
 
            header.VerticalOptions = LayoutOptions.Center;
            header.HorizontalOptions = LayoutOptions.Center;
 
            grid.Children.Add(header);
            Content = grid;
        }
    }
}
```

Аналогичный код в XAML:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <Grid>
        <Label HorizontalOptions="Center" VerticalOptions="Center">
            <Label.FormattedText>
                <FormattedString>
                    <Span Text="Сегодня " FontSize="22" />
                    <Span Text="хорошая " BackgroundColor="LightPink" TextColor="DarkRed" />
                    <Span Text="погода!" FontAttributes="Bold" />
                </FormattedString>
            </Label.FormattedText>
        </Label>
    </Grid>
</ContentPage>
```

!(https://metanit.com/sharp/maui/pics/4.8.png)


# Перевод строки

Для переноса текста на новую строку используется значение "\n". Например:

```Csharp
header.Text= "Его пример другим наука;\n"+
             "Но, боже мой, какая скука\n" +
             "С больным сидеть и день и ночь,\n" +
             "Не отходя ни шагу прочь!\n";
```

!(https://metanit.com/sharp/maui/pics/4.9.png)

В XAML тоже не сложно задать многострочный текст:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <Grid>
        <Label HorizontalOptions="Center" VerticalOptions="Center" FontSize="22">
            <Label.Text>
                <x:String>
Его пример другим наука;
Но, боже мой, какая скука
С больным сидеть и день и ночь,
Не отходя ни шагу прочь!
                </x:String>
            </Label.Text>
        </Label>
    </Grid>
</ContentPage>
```
В данном случае применяется сложное свойство Label.Text, которое в качестве значения принимает объект String. Причем для элемента String применяется префикс x - x:String, то есть определение данного типа берется из пространства имен "http://schemas.microsoft.com/winfx/2009/xaml"

# Обработка нажатия

Кнопки определяют событие нажатия, которое мы можем обработать. Однако у Label подобного события нет. Но что делать, если мы вдруг хотим обрабатывать нажатие на заголовок? В этом случае мы можем воспользоваться специальным классом TapGestureRecognizer, который позволяет обрабатывать нажатия:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            Grid grid = new Grid();
 
            Label label = new Label 
            {
                Text = "Hello METANIT.COM",
                VerticalOptions = LayoutOptions.Center,
                HorizontalOptions = LayoutOptions.Center,
                FontSize = 22
            };
             
            TapGestureRecognizer tapGesture = new TapGestureRecognizer
            {
                NumberOfTapsRequired = 2
            };
 
            int count = 0;  // счетчик нажатий
            tapGesture.Tapped += (s, e) =>
            {
                count++;
                label.Text = $"Вы нажали {count} раз";
            };
            label.GestureRecognizers.Add(tapGesture);
 
            grid.Children.Add(label);
            Content = grid;
        }
    }
}
```

TapGestureRecognizer представляет специальный класс, который позволяет распознать нажатия. С помощью свойства NumberOfTapsRequired мы можем установить, сколько нажатий необходимо. В данном случае мы устанавливаем двойное нажатие. И именно по двойному нажатию будет генерироваться событие Tapped, в обработчике которого изменяется значение переменной count и текст метки.

И чтобы связать объект TapGestureRecognizer с меткой, необходимо добавить этот объект в коллекцию GestureRecognizers:

```Csharp
label.GestureRecognizers.Add(tapGesture);
```

!(https://metanit.com/sharp/maui/pics/4.10.png)


# Текстовые поля

Текстовые поля ввода в .NET MAUI представлены несколькими классами:

Entry: однострочное текстовое поле

Editor: многострочное текстовое поле

Тектовое поле Entry
Класс Entry представляет текстовое поле для ввода однострочной информации. Для управления внешним видом элемента можно использовать следующие свойства:

- CharacterSpacing: расстояние между символами в тексте в виде значения типа double

- ClearButtonVisibility: значение типа ClearButtonVisibility, которое указывает, надо ли отображать рядом с полем кнопку для очистки содержимого в поле

- CursorPosition: значение типа int, которое определяет положение курсора внутри поля

- FontAttributes: определяет стиль текста

- FontAutoScalingEnabled: значение типа bool, устанавливает, будет ли к тексту применяться системное масштабирование

- FontFamily: семейство шрифтов в виде строки

- FontSize: размер шрифта (значение типа double)

- Keyboard: объект типа Keyboard, который позволяет установить тип клавиатуры

- IsPassword: значение типа bool, которое указывает, предназначено ли поле для ввода пароля

- IsTextPredictionEnabled: значение типа bool, которое указывает, будет ли применяться предсказание ввода и его автоисправление

- Placeholder: -плецсхолдер - текст, который отображается, если поле пусто

- PlaceholderColor: цвет плейсхолдера

Text: текст элемента

- TextColor: цвет текста

- SelectionLength: значение типа int, которое определяет количество выделенных символов

- MaxLength: максимальное допустимое количество символов

-IsReadOnly: значение типа bool, которое указывает, доступно ли поле только для чтения. По умолчанию значение false, то есть поле доступно для редактирования

- IsSpellCheckEnabled: значение типа bool, которое указывает, включена ли проверка орфографии

- TextTransform: объект типа TextTransform, который определяет преобразование текста

- HorizontalTextAlignment: значение TextAlignment, которое определяет выравнивание текста по горизонтали

- VerticalTextAlignment: значение типа TextAlignment, которое определяет выравнивание текста по вертикали

Простейшее поле ввода:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            StackLayout stackLayout = new StackLayout();
 
            Entry entry = new Entry 
            { 
                Placeholder = "Введите Email", 
                FontFamily="Helvetica", 
                FontSize=22,
                MaxLength = 20
            };
 
            stackLayout.Children.Add(entry);
            Content = stackLayout;
        }
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.11.png)

Аналог в XAML:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout>
        <Entry Placeholder = "Введите Email" FontFamily="Helvetica"
                FontSize="22" MaxLength ="20" />
    </StackLayout>
</ContentPage>
```

# Формат клавиатуры

Среди свойств текстового поля ввода одним из наиболее интересных является свойство Keyboard. Оно позволяет задать формат клавиатуры для ввода символов. Например, если необходимо ввести в поле какую-то числовую информацию, то гораздо было бы проще с точки зрения юзабилити предоставить пользователю сразу числовую раскладку клавиатуры. Данное свойство в качестве значения принимает объект класса Keyboard. Готовые раскладки клавиатуры можно получить с помощью одного из статических свойств класса Keyboard:

- Default: раскладка по умолчанию

- Text: для набора текста

- Chat: для набора текста и эмодзи

- Url: для набора url-адресов

- Email: для набора электронных адресов

- Telephone: для набора номера телефона

- Numeric: для ввода чисел

Каждое значение предоставляет свою раскладку клавиатуры, предназначенную для ввода определенной информации. Например

```Csharp
Entry entry = new Entry 
{ 
    Keyboard = Keyboard.Telephone
};
```

Или в XAML

```xml
<Entry Keyboard="Telephone" />
```

в данном случае при вводе нам автоматически представляется раскладка, содержащая только те символы, которые используются при наборе телефонного номера.

# Флаги KeyboardFlags

Для настройки ввода также можно применять константы перечисления KeyboardFlags:

KeyboardFlags

- None: для клавиатуры не добавляется никакой дополнительной функциональности

- CapitalizeSentence: указывает, что первая буква первого слова каждого предложения автоматически будет заглавной

- Spellcheck: указывает, что для введенного текста будет применяться проверка правописания

- Suggestions: при вводе слова будут предлагаться завершения слова

- CapitalizeWord: первая буква каждого слова автоматически будет заглавной

- CapitalizeCharacter: каждый введенный символ будет автоматически делаться заглавным

- CapitalizeNone: автоматическая капитализация отключена

- All: будут автоматически применяться значения CapitalizeSentence, Spellcheck и Suggestions

Применение в коде C#:

```Csharp
Entry entry = new Entry();
entry.Keyboard = Keyboard.Create(KeyboardFlags.Suggestions | KeyboardFlags.CapitalizeCharacter);

```

Здесь одновременно применяются два значения - Suggestions и CapitalizeCharacter.

Аналог в XAML:

```xml
<Entry>
    <Entry.Keyboard>
        <Keyboard x:FactoryMethod="Create">
            <x:Arguments>
                <KeyboardFlags>Suggestions,CapitalizeCharacter</KeyboardFlags>
            </x:Arguments>
        </Keyboard>
    </Entry.Keyboard>
</Entry>
```

# Обработка ввода пользователя

Для обработки ввода пользователя класс Entry предоставляет два события:

- TextChanged: возникает при вводе символов в поле

- Completed: возникает при завершении ввода

Например, обработаем ввод пользователя таким образом, чтобы вводимые в элемент Entry символы сразу же отображались в элементе Label

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        Label nameLabel;
        Entry nameEntry;
        public StartPage()
        {
            StackLayout stackLayout = new StackLayout();
 
            nameEntry = new Entry { FontSize = 22 };
            nameEntry.TextChanged+= nameEntry_TextChanged;
            nameLabel = new Label { FontSize = 22 };
 
            stackLayout.Children.Add(nameEntry);
            stackLayout.Children.Add(nameLabel);
            Content = stackLayout;
        }
 
        void nameEntry_TextChanged(object sender, TextChangedEventArgs e)
        {
            nameLabel.Text = nameEntry.Text;
        }
    }
}
```

Стоит отметить, что .NET MAUI предоставляет встроенную систему привязки, которая позволяет упростить такие случаи, тем не менее таким образом мы можем динамически перехватывать и обрабатывать ввод пользователя.

!(https://metanit.com/sharp/maui/pics/4.12.png)

Аналогичный пример в xaml:

```xml
<!--?xml version="1.0" encoding="utf-8" ?-->
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout>
        <Entry x:Name="nameEntry" FontSize="22" TextChanged="nameEntry_TextChanged" />
        <Label x:Name="nameLabel" FontSize="22" />
    </StackLayout>
</ContentPage>
```

И обработчик события в файле связанного кода:

```Csharp
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
    }
    void nameEntry_TextChanged(object sender, TextChangedEventArgs e)
    {
        nameLabel.Text = nameEntry.Text;
    }
}
```

В качестве параметра в метод передается объект типа TextChangedEventArgs, который имеет два свойства:

- OldTextValue: старое значение поля

- NewTextValue: новое значение поля

При необходимости мы можем их получить и использовать

```Csharp
void nameEntry_TextChanged(object sender, TextChangedEventArgs e)
{
    string oldText = e.OldTextValue;
    string newText = e.NewTextValue;
}
```

# Editor

В отличие от Entry Editor представляет собой многострочное поле ввода, но принципы его работы аналогичны. Он также имеет все те же свойства и события. Например:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            StackLayout stackLayout = new StackLayout();
 
            Editor textEditor = new Editor { HeightRequest = 200, FontSize = 16 };
            stackLayout.Children.Add(textEditor);
            Content = stackLayout;
        }
    }
}
```

По умолчанию размер поля Editor фактически представляет размер одной строки. И в данном случае, чтобы растянуть текстовое поле по высоте, у него устанавливается высота - свойство HeightRequest

!(https://metanit.com/sharp/maui/pics/4.13.png)

Реализация в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout>
        <Editor FontSize="16" HeightRequest="200" />
    </StackLayout>
</ContentPage>
```

# BoxView

BoxView представляет прямоугольную область. Обычно BoxView применяется для создания окрашенных областей, либо в качестве декоративного примитивного графического оформления к другим элементам.

Основные свойства класса BoxView:

- Color: представляет цвет элемента в виде структуры Color.

- CornerRadius: представляет радиус границы BoxView в виде значения типа float.

- WidthRequest: представляет ширину элемента (по умолчанию равна 40 единицам).

- HeightRequest: представляет высоту элемента (по умолчанию равна 40 единицам).

Создание BoxView в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <Grid>
        <BoxView Color="LightBlue" WidthRequest="150" HeightRequest="150" CornerRadius="8"
                 HorizontalOptions="Center" VerticalOptions="Center" />
    </Grid>
</ContentPage>
```

!(https://metanit.com/sharp/maui/pics/4.14.png)

Аналогичный пример в коде C#:

```Csharp
namespace HelloApp
{
    public partial class StartPage : ContentPage
    {
        public StartPage()
        {
            BoxView boxView = new BoxView
            {
                Color = Colors.LightBlue,
                CornerRadius = 8,
                WidthRequest = 150,
                HeightRequest = 150,
                HorizontalOptions = LayoutOptions.Center,
                VerticalOptions = LayoutOptions.Center
            };
            Grid grid = new Grid();
            grid.Add(boxView);
 
            Content = grid;
        }
    }
}
```

namespace HelloApp
{
    public partial class StartPage : ContentPage
    {
        public StartPage()
        {
            BoxView boxView = new BoxView
            {
                Color = Colors.LightBlue,
                CornerRadius = 8,
                WidthRequest = 150,
                HeightRequest = 150,
                HorizontalOptions = LayoutOptions.Center,
                VerticalOptions = LayoutOptions.Center
            };
            Grid grid = new Grid();
            grid.Add(boxView);
 
            Content = grid;
        }
    }
}

Также можно использовать BoxView для создания прямоугольного графического декоративного орнамента там, где не нужна сложная графика, а стандартные свойства элементов не позволяют это сделать. Нередко подобным образом BoxView используется в контейнере AbsoluteLayout, так как тот позволяет определить фиксированное положение, но и в других контейнерах также можно применять. Например, нам надо начертить двойную линию:

!(https://metanit.com/sharp/maui/pics/4.15.png)

Пример в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="20">
        <Label Text="METANIT.COM" FontSize="22" HorizontalOptions="Center"  />
        <BoxView Color="Gray"  HeightRequest="2" HorizontalOptions="Fill" Margin="1" />
        <BoxView Color="Gray"  HeightRequest="2" HorizontalOptions="Fill" Margin="1" />
        <Label Text="Руководство по .NET MAUI" FontSize="18" HorizontalOptions="Center"  />
    </StackLayout>
</ContentPage>
```

Аналогичный пример в C#:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            Label label1 = new Label
            {
                Text = "METANIT.COM",
                FontSize = 22,
                HorizontalOptions = LayoutOptions.Center
            };
            Label label2 = new Label
            {
                Text = "Руководство по .NET MAUI",
                FontSize = 18,
                HorizontalOptions = LayoutOptions.Center
            };
            BoxView boxView1 = new BoxView
            {
                Color = Colors.Gray,
                HeightRequest = 2,
                Margin = new Thickness(1),
                HorizontalOptions = LayoutOptions.Fill
            };
            BoxView boxView2 = new BoxView
            {
                Color = Colors.Gray,
                HeightRequest = 2,
                Margin = 1,
                HorizontalOptions = LayoutOptions.Fill
            };
            StackLayout stackLayout = new StackLayout 
            { 
                Children = { label1, boxView1, boxView2, label2 },
                Margin = new Thickness(20),
            };
            Content = stackLayout;
        }
    }
}
```

# ScrollView

При создании стека или любого другого элемента компоновки может сложиться ситуация, когда не все элементы будут помещаться на экране. В этом случае необходимо создать прокрутку с помощью элемента ScrollView.

Основные свойства класса ScrollView:

- Content: представляет содержимое области прокрутки - любой объект типа View.

- ContentSize: значение типа Size, которое хранит размер содержимого. Данное свойство доступно только для чтения.

- HorizontalScrollBarVisibility: значение типа ScrollBarVisibility, которое устанавливает горизонтальную прокрутку.

- Orientation: хранит значение типа ScrollOrientation, которое устанавливает направление прокрутки. По умолчанию имеет значение Vertical.

- ScrollX: значение типа double, которое задает X-позицию скорола. Значение по умолчанию - 0. Данное свойство доступно только для чтения.

- ScrollY: значение типа double, которое задает Y-позицию скорола. Значение по умолчанию - 0. Данное свойство доступно только для чтения

- VerticalScrollBarVisibility: значение типа ScrollBarVisibility, которое устанавливает вертикальную прокрутку.

По умолчанию для объекта ScrollView применяется вертикальная прокрутка. Простейший пример ScrollView в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <ScrollView>
        <StackLayout Padding="20">
            <Label FontSize="18">
                <Label.Text>
                    <x:String>
«Мой дядя самых честных правил,
Когда не в шутку занемог,
Он уважать себя заставил
И лучше выдумать не мог.
Его пример другим наука;
Но, боже мой, какая скука
С больным сидеть и день и ночь,
Не отходя ни шагу прочь!
Какое низкое коварство
Полуживого забавлять,
Ему подушки поправлять,
Печально подносить лекарство,
Вздыхать и думать про себя:
Когда же черт возьмет тебя!»
 
Так думал молодой повеса,
Летя в пыли на почтовых,
Всевышней волею Зевеса
Наследник всех своих родных.
Друзья Людмилы и Руслана!
С героем моего романа
Без предисловий, сей же час
Позвольте познакомить вас:
Онегин, добрый мой приятель,
Родился на брегах Невы,
Где, может быть, родились вы
Или блистали, мой читатель;
Там некогда гулял и я:
Но вреден север для меня.
                    </x:String>
                </Label.Text>
            </Label>
        </StackLayout>
    </ScrollView>
</ContentPage>
```

!(https://metanit.com/sharp/maui/pics/4.16.png)

Аналогичный пример в коде C#:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            Label textLabel = new Label
            {
                FontSize = 18,
                Text = "«Мой дядя самых честных правил,  ...."
            };
            StackLayout stackLayout = new StackLayout 
            { 
                Children = { textLabel},
                Margin = new Thickness(20),
            };
            ScrollView scrollView = new ScrollView { Content = stackLayout };
            Content = scrollView;
        }
    }
}
```
ScrollView может также быть вложенным элементом внтри других элементов управления и контейнеров компоновки. В этом случае рекомендуется явным образом устанавливать для ScrollView высоту с помощью свойства HeightRequest. Например:

```xml
<!--?xml version="1.0" encoding="utf-8" ?-->
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="20, 20,0,0">
        <Label Text="Евгений Онегин" FontSize="22" />
        <ScrollView HeightRequest="300">
            <Label FontSize="18">
                <Label.Text>
                    <x:String>
«Мой дядя самых честных правил........
                    </x:String>
                </Label.Text>
            </Label>
        </ScrollView>
    </StackLayout>
</ContentPage>
```

В данном случае для ScrollView устанавливается высота в 300 единиц

!(https://metanit.com/sharp/maui/pics/4.17.png)

Аналог в C#:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            StackLayout outerStackLayout = new StackLayout { Padding = new Thickness(20, 20, 0, 0) };
 
            Label header = new Label { Text = "Евгений Онегин", FontSize = 22 };
            Label textLabel = new Label
            {
                FontSize = 18,
                Text = "«Мой дядя самых честных правил,..."
            };
            ScrollView scrollView = new ScrollView { Content = textLabel , HeightRequest = 300 };
            outerStackLayout.Add(header);
            outerStackLayout.Add(scrollView);
            Content = outerStackLayout;
        }
    }
}
```
Если же ScrollView помещается в контейнер Grid, то для высоты строки грида, где расположен ScrollView, рекомендуется использовать значение "*". В этом случае ScrollView будет получать все оставшееся пространство:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <Grid Padding="20, 20,0,0" RowDefinitions="Auto, *">
        <Label Text="Евгений Онегин" FontSize="22" Grid.Row="0" />
        <ScrollView Grid.Row="1">
            <Label FontSize="18">
                <Label.Text>
                    <x:String>
«Мой дядя самых честных правил...
                    </x:String>
                </Label.Text>
            </Label>
        </ScrollView>
    </Grid>
</ContentPage>
```

Аналог в c#:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            Grid grid = new Grid { Padding = new Thickness(20, 20, 0, 0) };
            grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Star });
 
            Label headerLabel = new Label { Text = "Евгений Онегин", FontSize = 22 };
            Label textLabel = new Label
            {
                FontSize = 18,
                Text = "«Мой дядя самых честных правил..."
            };
            ScrollView scrollView = new ScrollView { Content = textLabel };
            grid.Add(headerLabel, row:0);
            grid.Add(scrollView, row: 1);
            Content = grid;
        }
    }
}
```

## Направление прокрутки

С помощью свойства Orientation у элемента ScrollView можно задать направление прокрутки. Это свойство принимает одну из констант перечисления ScrollOrientation:

- Vertical: вертикальная прокрутка, значение по умолчанию

- Horizontal: горизонтальная прокрутка

- Both: сочетание вертикальной и горизонтальной прокрутки

- Neither: отсутствие прокрутки

Например, определение горизонтальной прокрутки:

```Csharp
ScrollView scrollView = new ScrollView {  Orientation = ScrollOrientation.Horizontal };
```

XAML:

```xml
<ScrollView Orientation="Horizontal">
```

## Программная прокрутка

Класс ScrollView определяет метод ScrollToAsync, который позволяет программно прокручивать содержимое элемента. Он имеет две версии:

```Csharp
public Task ScrollToAsync(double x, double y, bool animated);
public Task ScrollToAsync(Element element, ScrollToPosition position, bool animated);
```

Первая версия производит переход к точке с определенными координатами x (первый параметр) и y (второй параметр). Третий параметр при значении true указывает, что надо использовать анимацию.

Вторая версия принимает элемент, к которому выполняется переход, в виде объекта Element и константу перечисления ScrollToPosition, которая устанавливает позицию скрола:

- MakeVisible: указывает, что элемент может прокручиваться, пока он остается в видимой области ScrollView.

- Start: элемент может прокручиваться до начала ScrollView
- Center: элемент может прокручиваться до центра ScrollView
- End: элемент может прокручиваться до конца ScrollView

Применим первую версию

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        ScrollView scrollView = new ScrollView();
 
        public StartPage()
        {
            StackLayout stackLayout = new StackLayout { Padding = 20 };
            Label textLabel = new Label
            {
                FontSize = 18,
                Text = "«Мой дядя самых честных правил...."
            };
 
            Button button = new Button { Text = "В начало" };
            button.Clicked += Button_Clicked;
            stackLayout.Add(textLabel);
            stackLayout.Add(button);
 
            scrollView.Content = stackLayout;
 
            Content = scrollView;
        }
 
        private async void Button_Clicked(object sender, EventArgs e)
        {
            await scrollView.ScrollToAsync(0, 20, true);
        }
    }
}
```

Здесь метод ScrollToAsync по нажатию на кнопку переходит к точке с x=0 и y=20

# Работа с изображениями. Элемент Image

Класс Image позволяет выводить изображения. .NET MAUI поддерживает все основные форматы типа png, jpg, gif и svg.

Основные свойства класса Image:

Aspect: представляет объект типа Aspect, который определяет режим масштабирования изображения.

IsAnimationPlaying: хранит значение типа bool, определяет будет ли выполняться анимация GIF. По умолчанию равно false, то есть анимация отключена.

IsLoading: хранит значение типа bool, указывает на статус загрузки изображения. По умолчанию равно false.

IsOpaque: хранит значение типа bool, указывает, будет ли изображение рассматриваться как прозрачное. По умолчанию значение false.

Source: хранит значение типа ImageSource, которое определяет источник изображения.

Ключевым свойством является свойство ImageSource, которое представляет объект одноименного класса. Именно это свойство и определяет источник изображения. В качестве источника изображения может использовать локальный файл, файл в интернете, встроенный в приложение ресурс, либо поток. И для использования разных источников в классе ImageSource определен ряд методов:

FromFile(): возвращает объект типа FileImageSource, который считывает данные из локального файла.

FromUri(): возвращает объект типа UriImageSource, который считывает данные по определенному адресу Uri.

FromResource(): возвращает объект типа ResourceImageSource, который считывает данные из ресурса из текущей сборки.

FromStream(): возвращает объект типа StreamImageSource, который считывает данные изображения из потока.

Рассмотрим различные варианты загрузки изображения.

# Загрузка из локального файла

Для упрощения работы с локальными файлами изображений их можно поместить в проект в папку Resources\Images. При добавлении файла в эту папку его свойство Build action автоматически получает значение MauiImage. Такой файл будет автоматически добавляться в пакет приложения. Для управления такими файлами в процессе построения в файле проекта мы можем найти соответствующие элементы:

```xml
<Project Sdk="Microsoft.NET.Sdk">
 
    <!-- Остальное содержимое -->
 
    <ItemGroup>
        <!-- Остальное содержимое -->
        <!-- Images -->
        <MauiImage Include="Resources\Images\*" />
        <MauiImage Update="Resources\Images\dotnet_bot.svg" BaseSize="168,208" />
    </ItemGroup>
</Project>
```
здесь элемент

<MauiImage Include="Resources\Images\*" />

Как раз указывает, что файлы из данной папки будут добавляться в выходной пакет приложения.

При использовании локальных файлов следует учитывать, что для соответствия правилам наименования в Android название файла изображения должно быть в нижнем регистре, содержать алфавитно-цифровые символы или подчеркивание и начинаться и заканчиваться на алфавитный символ.

Например, добавим в проект в папку Resources\Images какой-нибудь файл изображения. В моем случае это файл forest.png:

!(https://metanit.com/sharp/maui/pics/4.18.png)

Для загрузки этого файла используем метод ImageSource.FromFile():

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    public StartPage()
    {
        Image image = new Image
        {
            Source = ImageSource.FromFile("forest.png")
        };
 
        Content = image;
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.19.png)

Также мы можем сократить код:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    public StartPage()
    {
        Image image = new Image { Source = "forest.png" };
 
        Content = image;
    }
}
```
В XAML это выглядело бы следующим образом:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <Image Source="forest.png" />
</ContentPage>
```

## Загрузка файла из сети

Для получения изображения из сети применяется метод ImageSource.FromUri(), в который передается сетевой адрес:

```Csharp
Image image = new Image
{
    Source = ImageSource.FromUri(new Uri("https://news.microsoft.com/wp-content/uploads/2014/12/452292672.jpg"))
};
```

Также можно сократить данный код:

```Csharp
Image image = new Image { Source = "https://news.microsoft.com/wp-content/uploads/2014/12/452292672.jpg" };
```

На уровне XAML все остается также, только меняется адрес:

```Csharp
<Image Source="https://news.microsoft.com/wp-content/uploads/2014/12/452292672.jpg" />
```
При получении изображения по сети может возникнуть вопрос кэширования изображения. По умолчанию для загружаемых изображений включено кэширование на 1 день. Однако мы можем переопределить это поведение с помощью двух свойств объекта UriImageSource

- CacheValidity: объект типа TimeSpan, который определяет продолжительность кэширования. Значение по умолчанию - 1 день.

- CachingEnabled: значение типа bool, которое определяет, будет ли применяться кэширование. Значение по умолчанию - true (то есть кэширование включено).

Пример настройки кэширования в xaml:

```xml
<Image>
    <Image.Source>
        <UriImageSource Uri="https://news.microsoft.com/wp-content/uploads/2014/12/452292672.jpg"
                        CacheValidity="2:00:00.0" />
    </Image.Source>
</Image>
```
В данном случае устанавливается срок кэширования в 2 дня.

Аналогичный пример в коде C#:

```Csharp
Image image = new Image();
image.Source = new UriImageSource
{
    Uri = new Uri("https://news.microsoft.com/wp-content/uploads/2014/12/452292672.jpg"),
    CacheValidity = new TimeSpan(2,0,0,0)
};
```

# Загрузка встроенного ресурса

Встроенные ресурсы изображений встраиваются в сборку и затем могут загружаться с помощью идентификатора данных ресурсов. Например, добавим в корень проекта какой-нибудь файл изображения (в моем случае это файл forest.jpg)

!(https://metanit.com/sharp/maui/pics/4.20.png)

Чтобы обозначит файл как встроенный ресурс, в окне свойств для этого файла для поля Build Action устанавливается значение Embedded resource

Для загрузки встроенного ресурса применяется метод ImageSource.FromResource(), в который передается идентификатор ресурса. Идентификатор состоит из имени проекта и пути к ресурсу внутри данного проекта. Например, выше файл forext.jpng расположен в корне проекта HelloApp, соответственно идентификатором данного ресурса будет HelloApp.forest.jpg. Если бы файл находился бы в проекте в папке Assets/Images, тогда его идентификатором было бы HelloApp.Assets.Images.forest.jpg. Так, в случае выше ресурс изображения будет загружаться следующим образом:

```Chsarp
Image image = new Image
{
    Source = ImageSource.FromResource("HelloApp.forest.jpg")
};
```

# Масштабирование изображения

С помощью свойства Aspect можно определить режим масштабирования изображения. В качестве значения оно принимает одну из констант перечисления Aspect:

- AspectFit: изображение масштабируется с сохранением аспектного отношения между шириной и высотой, но ширина и высота не могут быть больше ширины и высоты Image

- AspectFill: изображение масштабируется с сохранением аспектного отношения между шириной и высотой, заполняя все пространство Image

- Fill: изображение масштабируется без сохранения аспектного отношения между шириной и высотой, заполняя все пространство Image

- Center: изображение центрируется по центру и масштабируется с сохранением аспектного отношения между шириной и высотой

Применим эти значения:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    public StartPage()
    {
        Grid grid = new Grid { Padding = 2 };
        grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Star });
        grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Star });
        grid.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Star });
        grid.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Star });
 
        var fileName = "forest.png";
        grid.Add(new Image { Source = fileName, Aspect = Aspect.AspectFit }, 0, 0);
        grid.Add(new Image { Source = fileName, Aspect = Aspect.AspectFill }, 1, 0);
        grid.Add(new Image { Source = fileName, Aspect = Aspect.Fill }, 0,1);
        grid.Add(new Image { Source = fileName, Aspect = Aspect.Center });
        Content = grid;
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.21.png)

Применение Aspect в XAML:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <Grid RowDefinitions="*, *" ColumnDefinitions="*, *">
        <Image Source="forest.png" Aspect="AspectFit" />
        <Image Source="forest.png" Aspect="AspectFill" Grid.Column="1" Grid.Row="0" />
        <Image Source="forest.png" Aspect="Fill" Grid.Column="0" Grid.Row="1" />
        <Image Source="forest.png" Aspect="Center"  Grid.Column="1" Grid.Row="1" />
    </Grid>
</ContentPage>
```

# Frame

Контейнер Frame, как правило, выполняет декоративные функции и используется для оформления или создания фона для вложенного элемента.

Среди свойств класса Frame следует выделить следующие:

BorderColor: представляет цвет границы фрейма с помощью структуры Color.

CornerRadius: представляет радиус границы фрейма в виде значения типа float.

HasShadow: хранит значение типа bool, которое указывает, будет ли фрейм отбрасывать тень.

Стоит учитывать, что фрейм может вмещать только один элемент. Ключевым моментом использования фреймов является возможность установить некоторое внешнее оформление для вложенного элемента, например, с помощью установки цвета границы, ее радиуса, цвета фона.

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <Grid Padding="20">
        <Frame BorderColor="Gray" BackgroundColor="#e1e1e1">
            <Label HorizontalTextAlignment="Center" VerticalTextAlignment="Center" Text="Hello METANIT.COM" />
        </Frame>
    </Grid>
</ContentPage>
```

!(https://metanit.com/sharp/maui/pics/4.22.png)

Аналогичный пример в коде C#:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    public StartPage()
    {
        Grid grid = new Grid() { Padding = 20 };
        Frame frame = new Frame
        {
            BorderColor = Colors.Gray,
            Content = new Label 
            { 
                Text = "Hello METANIT.COM", 
                HorizontalTextAlignment = TextAlignment.Center, 
                VerticalTextAlignment = TextAlignment.Center 
            },
            BackgroundColor = Color.FromArgb("#e1e1e1")
        };
        grid.Add(frame);
        Content = grid;
    }
}
```

Frame может применяться для скругления вдлложенных элементов:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="20">
        <Frame Margin="10" HorizontalOptions="Start"
               IsClippedToBounds="True" CornerRadius="90"
               HeightRequest="100" WidthRequest="100">
            <Image Source="forest.png" Aspect="AspectFill" Margin="-20"
                HeightRequest="100" WidthRequest="100"  />
        </Frame>
    </StackLayout>
</ContentPage>
```

!(https://metanit.com/sharp/maui/pics/4.24.png)

Также можно применять Frame для создания стилизованных карточек:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <Grid Padding="20">
        <Frame BorderColor="Gray" BackgroundColor="#e1e1e1">
            <StackLayout>
                <Label HorizontalTextAlignment="Center" FontSize="22" Text=".NET MAUI" />
                <BoxView HeightRequest="2" Color="DarkGray" />
                <Label FontSize="16" Text=".NET MAUI - технология, предназначенная для создания кроссплатформенных приложений." />
            </StackLayout>
        </Frame>
    </Grid>
</ContentPage>
```

!(https://metanit.com/sharp/maui/pics/4.23.png)


# Выбор даты и времени. DatePicker и TimePicker

## DatePicker

DatePicker предназначен для выбора дат. Для его управления могут использоваться следующие свойства:

MaximumDate: максимальная возможная дата, по умолчанию равна 31 декабря 2100

MinimumDate: минимальная возможная дата, по умолчанию равна 1 января 1900

Date: выбранная дата - значение структуры DateTime, по умолчанию равна значению DateTime.Today

Format: определяет формат даты, принимает стандартные для .NET форматы .По умолчанию равен "D" - то есть дата отображается в расширенном формате

Для этого класса также определено событие DateSelected, которое срабатывает при выборе новой даты:

```Csharp
public event EventHandler<DateChangedEventArgs> DateSelected;
```
В качестве второго параметра обработчик события принимает объект DateChangedEventArgs, у которого можно выделить два свойства: NewDate (выбранная дата) и OldDate (старая дата)

Пример простейшего DatePicker:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    Label label;
     
    public StartPage()
    {
        label = new Label { Text = "Выберите дату" };
        DatePicker datePicker = new DatePicker
        {
            Format = "d",
            MaximumDate = DateTime.Now.AddDays(5),
            MinimumDate = DateTime.Now.AddDays(-5)
        };
        datePicker.DateSelected += DateSelected;
        StackLayout stack = new StackLayout { Children = { label, datePicker }, Padding=20 };
        Content = stack;
    }
    void DateSelected(object sender, DateChangedEventArgs e)
    {
        label.Text = $"Вы выбрали {e.NewDate.ToString("d")}";
    }
}
```
Но при создании элемента надо учитывать, что в конечном счете .NET MAUI использует стандартные механизмы для отображения этого элемента на каждой конкретной платформе. Так, на Windows он будет выглядеть следующим образом:

!(https://metanit.com/sharp/maui/pics/4.25.png)

При установке дат в XAML необходимо передавать значение в формате, которое бы будет понятно для DateTime.Parse(). Наиболее простой способ заключается в использовании краткого формата даты "MM/dd/yyyy". Так, аналогичный пример в xaml выглядел бы следующим образом:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="20">
        <Label x:Name="label" Text="Выберите дату"/>
        <DatePicker Format="d" DateSelected="DateSelected">
            <DatePicker.MinimumDate>7/10/2022</DatePicker.MinimumDate>
            <DatePicker.MaximumDate>7/20/2022</DatePicker.MaximumDate>
        </DatePicker>
    </StackLayout>
</ContentPage>
```

И в этом случае нам надо задать обработчик события выбора даты с файле кода:

```Csharp
namespace HelloApp;
 
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
    }
    void DateSelected(object sender, DateChangedEventArgs e)
    {
        if (label is { }) 
            label.Text = $"Вы выбрали {e.NewDate.ToString("d")}";
    }
}
```

# TimePicker

TimePicker представляет элемент управления для отображения времени.Среди его свойств можно отметить следующие:

- Time: выбранное время, представляет структуру TimeSpan и по умолчанию равно 0

-   Format: определяет формат даты, принимает стандартные для .NET форматы .По умолчанию равен "t" - сокращенная запись времени

Для обработки выбора можно использовать событие PropertyChanged.

Простейший TimePicker:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    Label label;
    TimePicker timePicker;
 
    public StartPage()
    {
        label = new Label { Text = "Выберите время", FontSize= 20 };
        timePicker = new TimePicker() { Time = new TimeSpan(17, 0, 0) };
        timePicker.PropertyChanged += TimePicker_PropertyChanged;
 
        StackLayout stack = new StackLayout { Children = { label, timePicker }, Padding=20  };
        Content = stack;
    }
 
    private void TimePicker_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        if (e.PropertyName == "Time")
        {
            label.Text = $"Вы выбрали {timePicker.Time}";
        }
    }
}
```

Конкретное отображение TimePickera также будет зависеть от конкретной платформы. Например, на Windos элемент будет выглядеть так:

!(https://metanit.com/sharp/maui/pics/4.26.png)

Создание TimePicker в xaml:

```xml
<!--?xml version="1.0" encoding="utf-8" ?-->
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="20">
        <Label x:Name="label" Text="Выберите дату" FontSize="20" />
        <TimePicker x:Name="timePicker" Time="17:00:00" PropertyChanged="TimePicker_PropertyChanged" />
    </StackLayout>
</ContentPage>
```

И обработка события в файле связанного кода

```Csharp
namespace HelloApp;
 
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
    }
    private void TimePicker_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        if (e.PropertyName == "Time")
        {
            label.Text = $"Вы выбрали {timePicker.Time}";
        }
    }
}
```

# Stepper и Slider

## Stepper

Класс Stepper позволяет выбрать числовое значение из некоторого диапазона значений. Среди свойств класса можно отмеимит следующие:

Increment: шаг увеличения от одного значения к другому, по умолчанию равно 1.

Minimum: минимальное значение диапазона, по умолчанию равно 0.

Maximum: максимальное значение диапазона, по умолчанию равно 100.

Value: текущее значение элемента, может находиться в диапазоне от Minimum до Maximum, по умолчанию равно 0.

Все эти свойства представляют тип double.

Для отслеживания измененя значения класс Stepper определяет событие ValueChanged - оно генерируется каждый раз при изменении значения свойства Value. В качестве параметра оно принимает объект ValueChangedEventArgs, который имеет два свойства: OldValue (старое значение) и NewValue (новое значение). При этом значение свойства NewValue эквивалентно значению свойства Value объекта Stepper.

Определим простейший объект Stepper:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    Label header;
    public StartPage()
    {
        header = new Label { FontSize = 18, Margin = 5 };
 
        Stepper stepper = new Stepper
        {
            Minimum = 0,
            Maximum = 10,
            Increment = 0.1,
            VerticalOptions = LayoutOptions.Start
        };
        stepper.ValueChanged += OnStepperValueChanged;
        Content = new StackLayout { Children = { stepper, header }, Orientation = StackOrientation.Horizontal };
    }
    void OnStepperValueChanged(object sender, ValueChangedEventArgs e)
    {
        header.Text = $"Выбрано: {e.NewValue:F1}";
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.27.png)

Stepper в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Orientation="Horizontal">
        <Stepper Minimum ="0" Maximum="10" Increment ="0.1" VerticalOptions = "Start"
                 ValueChanged="OnStepperValueChanged" />
        <Label x:Name="header"  FontSize="18" Margin="5" />
    </StackLayout>
</ContentPage>
```

А в файле связанного кода прописать обработчик OnStepperValueChanged:

```Csharp
namespace HelloApp;
 
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
    }
    void OnStepperValueChanged(object sender, ValueChangedEventArgs e)
    {
        header.Text = $"Выбрано: {e.NewValue:F1}";
    }
}
```

# Slider

Slider представляет собой горизонтальный ползунок и во многих аспектах он похож на Stepper. Среди его свойств можно выделить следующие:

Minimum: минимальное значение ползунка, представляет тип double, значение по умолчанию - 0

Maximum: максимальное значение ползунка, представляет тип double, значение по умолчанию - 1

Value: текущее значение ползунка, представляет тип double, значение по умолчанию - 0

ThumbColor: цвет указателя текущего значения, представляет тип Color

MinimumTrackColor: цвет ползунка до указателя значения, представляет тип Color

MaximumTrackColor: цвет ползунка после указателя значения, представляет тип Color

Как и Stepper, класс Slider для отслеживания измененя значения определяет событие ValueChanged, которое генерируется каждый раз при изменении значения свойства Value (в том числе при изменении программным образом). В качестве параметра оно принимает объект ValueChangedEventArgs, который имеет два свойства: OldValue (старое значение) и NewValue (новое значение). При этом значение свойства NewValue эквивалентно значению свойства Value объекта Stepper.

В дополнение для отслеживания перемщения позунка класс Slider определяет события DragStarted (возникает, когда пользователь начинает перемещать ползунок) и DragCompleted (возникает, когда пользователь завершает перемещать ползунок).

Например, определение в коде C#

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    Label header;
    public StartPage()
    {
        header = new Label { FontSize = 18, Margin = 5 };
 
        Slider slider = new Slider
        {
            Maximum = 50,
            Minimum = 0,
            Value = 30,
            ThumbColor = Colors.DeepPink,
            MinimumTrackColor = Colors.DeepPink,
            MaximumTrackColor = Colors.LightPink
        };
        slider.ValueChanged += OnSliderValueChanged;
        Content = new StackLayout { Children = { header, slider}, Padding=20 };
    }
    void OnSliderValueChanged(object sender, ValueChangedEventArgs e)
    {
        header.Text = $"Выбрано: {e.NewValue:F1}";
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.28.png)

Аналогичный слайдер в xaml:

```xml
<StackLayout Padding="20">
    <Label x:Name="header"  FontSize="18" Margin="5" />
    <Slider Minimum ="0" Maximum="50" Value="30" ValueChanged="OnSliderValueChanged"
        MinimumTrackColor="DeepPink" MaximumTrackColor="LightPink" ThumbColor="DeepPink" />
</StackLayout>
```

И в файле связанного кода пропишем обработчик OnSliderValueChanged:

```Csharp
void OnSliderValueChanged(object sender, ValueChangedEventArgs e)
{
    header.Text = $"Выбрано: {e.NewValue:F1}";
}
```

# Переключатели Switch и CheckBox

Класс Switch представляет кнопку-переключатель, который может находиться в двух состояниях: включенном и выключенном.

Среди свойств класса Switch стоит выделить следующие:

IsToggled: указывает, находится ли Switch во включенном состоянии (значение true) или выключенном (значение false)

ThumbColor: цвет кнопки переключателя

OnColor: цвет переключателя во включенном состоянии

Для отслеживания изменения состояния элемента Switch класс определяет событие Toggled. Его параметр ToggledEventArgs с помощью свойства Value позволяет получить новое состояние - новое значения свойства IsToggled.

Создадим элемент Switch в коде C#:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    Label label;
    public StartPage()
    {
        Switch switcher = new Switch { IsToggled = true};
        switcher.Toggled += switcher_Toggled;
        label = new Label
        {
            FontSize = 16,
            Text = $"Значение {switcher.IsToggled}"
        };
        Content = new StackLayout { Children = { switcher, label }, Padding=8 };
    }
    void switcher_Toggled(object sender, ToggledEventArgs e)
    {
        label.Text = $"Значение {e.Value}";
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.29.png)

Аналог в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="8">
        <Switch x:Name="switcher" IsToggled="True" Toggled="switcher_Toggled" />
        <Label x:Name="label" FontSize="16" />
    </StackLayout>
</ContentPage>
```
и в файле связанного кода пропишем обработчик события Toggled:

```Csharp
namespace HelloApp;
 
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
    }
    void switcher_Toggled(object sender, ToggledEventArgs e)
    {
        label.Text = $"Значение {e.Value}";
    }
}
```

# Checkbox

Похожую функциональность предоставляет другой класс - CheckBox - он представляет флажок, который может находиться в двух состояниях: отмеченном и неотмеченном. Среди свойств данного класса следует выделить следующие:

- IsChecked: указывает, находится ли флажок в отмеченном состоянии (значение true) или неотмеченном (значение false)

- Color: цвет флажка

Для отслеживания изменения состояния флажка класс Checkbox определяет событие CheckedChanged. Его параметр CheckedChangedEventArgs с помощью свойства Value позволяет получить новое состояние - новое значения свойства IsChecked.

Пример CheckBox в коде C#:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    Label statusLabel;
    public StartPage()
    {
        CheckBox statusCheckBox = new CheckBox { IsChecked = false};
        statusCheckBox.CheckedChanged += CheckBox_CheckedChanged;
        Label statusHeaderLabel = new Label { FontSize = 16, Text = "женат/замужем", Margin=4 };
        StackLayout checkboxStack = new StackLayout 
        { 
            Orientation = StackOrientation.Horizontal,
            Children = { statusCheckBox, statusHeaderLabel }
        };
        statusLabel = new Label 
        { 
            FontSize = 18, 
            Text = "Статус: холост/не замужем"
        };
        Content = new StackLayout { Children = { statusLabel, checkboxStack}, Padding=8 };
    }
 
    private void CheckBox_CheckedChanged(object sender, CheckedChangedEventArgs e)
    {
        statusLabel.Text = $"Статус: {(e.Value ? "женат/замужем":"холост/не замужем")}";
    }
}
```
!(https://metanit.com/sharp/maui/pics/4.30.png)

Аналог в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="8">
        <Label x:Name="statusLabel" FontSize="18" Text="Статус: холост/не замужем" />
         
        <StackLayout Padding="8" Orientation="Horizontal">
            <CheckBox x:Name="statusCheckBox" CheckedChanged="CheckBox_CheckedChanged" />
            <Label FontSize="16"  Text="женат/замужем" />
        </StackLayout>
 
    </StackLayout>
</ContentPage>
```

и в файле связанного кода пропишем обработчик события CheckedChanged:

```Csharp
namespace HelloApp;
 
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
    }
    void CheckBox_CheckedChanged(object sender, CheckedChangedEventArgs e)
    {
        statusLabel.Text = $"Статус: {(e.Value ? "женат/замужем" : "холост/не замужем")}";
    }
}
```

# RadioButton

Класс RadioButton (радиокнопка) представляет кнопку-переключатель, которая позволяет пользователя выбрать один вариант из группы вариантов.

Среди свойств класса RadioButton стоит выделить следующие:

- Content: содержимое кнопки в виде текста или объекта View, отображается справа от круга кнопки.

- GroupName: определяет имя группы, к которой принадлежит данная радиокнопка

- Value: определяет некоторое значение (представляет тип object), связанное с данной радиокнопкой

- BorderColor: представляет тип Color и определяет цвет границы.

- BorderWidth: представляет тип double и определяет толщину границы.

- CharacterSpacing: представляет тип double и определяет расстояние между символами текста при кнопке.

- CornerRadius: представляет тип int и определяет радиус кнопки.

- FontAttributes: представляет тип FontAttributes и определяет стиль текста.

- FontAutoScalingEnabled: представляет тип bool и определяет, будет ли применяться системное масштабирование. По умолчанию равно true, то есть масщтабирование применяется.

- FontFamily: представляет тип string и определяет используемое семейство шрифтов.

- FontSize: представляет тип double и определяет размер шрифта.

- TextColor: представляет тип Color и определяет цвет текста.

- IsChecked: указывает, находится ли радиокнопка в отмеченном состоянии (значение true) или неотмеченном (значение false)

Обычно работа ведется не с одной радиокнопкой, а с группой радиокнопок, из которой пользователь выбирает одну. Для управления группой радиокнопок в .NET MAUI есть класс RadioButtonGroup, который имеет ряд свойств для управления группой радиокнопок:

- GroupName: название группы.

- SelectedValue: выбранный объект RadioButton

Создание радиокнопок в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout>
        <Label x:Name="header" Text="Выберите язык программирования" />
        <RadioButton GroupName="languages" Content="C#" IsChecked="True" />
        <RadioButton GroupName="languages" Content="Java" />
        <RadioButton GroupName="languages" Content="C++" />
    </StackLayout>
</ContentPage>
```

!(https://metanit.com/sharp/maui/pics/4.31.png)

В данном случае есть три радиокнопки, и все они принадлежат к группе languages. И в рамках этой группы мы можем выбрать только одну. По умолчанию здесь выбрана первая кнопка.

Чтобы упростить определение группы, можно у контейнера через атрибут RadioButtonGroup.GroupName определить имя группы для всех вложенных радиокнопок:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout RadioButtonGroup.GroupName="languages">
        <Label x:Name="header" Text="Выберите язык программирования" />
        <RadioButton Content="C#"  />
        <RadioButton Content="Java" />
        <RadioButton Content="C++" />
    </StackLayout>
</ContentPage>
```
С каждой радиокнопкой может быть связано некоторое значение, оно передается через свойство Value:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout RadioButtonGroup.GroupName="languages">
        <Label x:Name="header" Text="Выберите язык программирования" />
        <RadioButton Content="C#" Value="C#"  />
        <RadioButton Content="Java" Value="Java" />
        <RadioButton Content="C++" Value="C++" />
    </StackLayout>
</ContentPage>
```
# Обработка выбора радиокнопки

Для отслеживания изменения состояния радиокнопкт класс RadioButton определяет событие CheckedChanged. Его параметр CheckedChangedEventArgs с помощью свойства Value позволяет получить новое состояние - новое значения свойства IsChecked.

Гапример, мы могли бы определить для каждой кнопки обработчик данного события:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout RadioButtonGroup.GroupName="languages">
        <Label x:Name="header" Text="Выберите язык программирования" />
        <RadioButton Content="C#" Value="C#" CheckedChanged="OnLanguageCheckedChanged" />
        <RadioButton Content="Java" Value="Java"  CheckedChanged="OnLanguageCheckedChanged" />
        <RadioButton Content="C++" Value="C++"  CheckedChanged="OnLanguageCheckedChanged" />
    </StackLayout>
</ContentPage>
```
В данном случае при выборе каждой кнопки будет срабатывать обработчик OnLanguageCheckedChanged. Определим его в файле связанного кода:

```Csharp
namespace HelloApp;
 
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
    }
    void OnLanguageCheckedChanged(object sender, CheckedChangedEventArgs e)
    {
        RadioButton selectedRadioButton = ((RadioButton)sender);
        if(header!=null)
            header.Text = $"Выбранный язык: {selectedRadioButton.Value}";
    }
}
```

В данном случае в обработчике события получаем выбранный объект RadioButton и затем значение его свойства Value передаем в текст метки header.

!(https://metanit.com/sharp/maui/pics/4.32.png)

Хотя для решения конкретно данной задачи гораздо проще использовать механизм привязки, которая будет рассмотрена далее, тем не менее мы можем таким образом с обработчиках событий получать выбор определенной радиокнопки и соотвественно предпринимать некоторе действия.

Аналогичный пример в коде C#:

```Csharp
using static System.Net.Mime.MediaTypeNames;
 
namespace HelloApp;
 
class StartPage : ContentPage
{
    Label header = new Label { Text = "Выберите язык программирования" };
    public StartPage()
    {
        string[] langs = { "C#", "Java", "C++" };
        
        StackLayout stackLayout = new StackLayout();
        stackLayout.Add(header);  
 
        foreach(var lang in langs)
        {
            RadioButton langRadioButton= new RadioButton { GroupName = "languages", Content = lang, Value = lang };
            langRadioButton.CheckedChanged += OnLanguageCheckedChanged;
            stackLayout.Add(langRadioButton);
        }
        Content = stackLayout;
    }
 
    void OnLanguageCheckedChanged(object sender, CheckedChangedEventArgs e)
    {
        RadioButton selectedRadioButton = ((RadioButton)sender);
        if (header != null)
            header.Text = $"Выбранный язык: {selectedRadioButton.Value}";
    }
}
```

# Кастомное содержимое

Обычно в качестве содержимого радиокнопки применяется текста, как в примере выше. Но в принципе это может быть произвольный объект. Например, испольуем изображения. Пусть в проекте в папке Resourses/Images находятся используемые изображения. В моем случае это файлы изображений csharp.jpg, java.jpg и cpp.jpg. Тогда их использование в элементе RadioButton в XAML выглядело бы следующим образом:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout RadioButtonGroup.GroupName="languages">
        <Label x:Name="header" Text="Выберите язык программирования" />
        <RadioButton Value="C#">
            <RadioButton.Content>
                <Image Source="csharp.jpg" WidthRequest="25" HeightRequest="25" />
            </RadioButton.Content>
        </RadioButton>
        <RadioButton Value="Java">
            <RadioButton.Content>
                <Image Source="java.jpg" WidthRequest="25" HeightRequest="25"  />
            </RadioButton.Content>
        </RadioButton>
        <RadioButton Value="C++">
            <RadioButton.Content>
                <Image Source="cpp.jpg" WidthRequest="25" HeightRequest="25"  />
            </RadioButton.Content>
        </RadioButton>
    </StackLayout>
</ContentPage>
```

!(https://metanit.com/sharp/maui/pics/4.34.png)

# Выпадающий список Picker

Визуально элемент Picker представляет собой обычное текстовое поле, по нажатию на которое открывается список для выбора, что-то наподобие выпадающего списка. Для управления внешним видом и вложенными элементами класс Picker определяет следующие свойства:

- ItemsSource: представляет тип IList и определяет коллекцию отображаемых элементов. По умолчанию равно null.

- SelectedIndex: представляет тип int, хранит индекс выделенного элемента. По умолчанию равно -1.

- SelectedItem: представляет тип object, хранит выбранный элемент. По умолчанию равно null.

- CharacterSpacing: представляет тип double и определяет расстояние между символами в Picker.

- FontAttributes: представляет тип FontAttributes и определяет атрибуты шрифта.

- FontAutoScalingEnabled: представляет тип bool и определяет, будет ли применяться к элементу системное масштабирование.

- FontFamily: представляет тип string и определяет используемое семейство шрифтов.

- FontSize: представляет тип double и определяет высоту шрифта.

- TextColor: представляет тип Color и определяет цвет текста.

- TitleColor: представляет тип Color и определяет цвет заголовка.

Ключевое свойство - ItemsSource, которое представляет коллекцию вложенных элементов.

С помощью события SelectedIndexChanged можно обработать выбор элемента в Picker

Например, создадим Picker в коде C#:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    Label header = new Label { Text = "Выберите язык", FontSize = 18 };
    Picker languagePicker = new Picker { Title = "Язык программирования" };
    public StartPage()
    {
        // можно динамически доблять элементы
        languagePicker.Items.Add("C#");
        languagePicker.Items.Add("JavaScript");
        languagePicker.Items.Add("Java");
 
        // можно сразу установить список элементов
        // languagePicker.ItemsSource = new string[]{ "C#", "Java", "JavaScript"};
         
        // установка выделенного индекса 
        // languagePicker.SelectedIndex = 0;
 
        languagePicker.SelectedIndexChanged += PickerSelectedIndexChanged;
         
        Content = new StackLayout { Children = { header, languagePicker }, Padding=8 };
    }
 
    void PickerSelectedIndexChanged(object sender, EventArgs e)
    {
        header.Text = $"Вы выбрали: {languagePicker.SelectedItem}";
        // или так через индекс
        //header.Text = $"Вы выбрали: {languagePicker.Items[languagePicker.SelectedIndex]}";
    }
}
```

Здесь содержит список для выбора, а отследить выбранный элемент мы можем с помощью обработчик события SelectedIndexChanged. Стоит отметить, что длина элемента Picker по умолчанию устанавливается чуть меньше чем его заголовок. .

!(https://metanit.com/sharp/maui/pics/4.35.png)

Аналог в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="8">
        <Label x:Name="header" Text="Выберите язык" FontSize="18" />
        <Picker x:Name="languagePicker" Title = "Язык программирования"
                SelectedIndexChanged="PickerSelectedIndexChanged">
            <Picker.Items>
                <x:String>C#</x:String>
                <x:String>JavaScript</x:String>
                <x:String>Java</x:String>
            </Picker.Items>
        </Picker>
    </StackLayout>
</ContentPage>
```

И тогда в файл связанного кода надо добавить обработчик события:

```Csharp
namespace HelloApp;
 
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
    }
    void PickerSelectedIndexChanged(object sender, EventArgs e)
    {
        header.Text = $"Вы выбрали: {languagePicker.SelectedItem}";
    }
}
```

# TableView

Класс TableView позволяет создавать табличные представления с различным содержимым. TableView может быть полезен для отображения списка различных настроек, вывод данных в виде формы, для построчного отображения данных и т.д.

Среди свойств TableView следует выделить следующие:

- Intent: определяет назначение таблицы на iOS (применяется только к iOS). Представляет одну из констант перечисления TableIntent:

- Data: предназначен для простого отображения данных

- Form: представляет форму ввода данных, как в примере выше

- Menu: используется для вывода меню

- Settings: используется для отображения набора настроек

- HasUnevenRows: представляет тип bool и указывает, будут ли строки в таблицы иметь различную высоту. Значение по умолчаниюfalse.

- Root: определяет содерижимое таблицы в виде объекта TableRoot.

- RowHeight: определяет высоту строк в виде значения int, если свойство HasUnevenRows равно false.

Элементы в TableView организованы в секции (элементы TableSection). Корневым элементов в TableView является элемент TableRoot, который инкапсулирует в себе все секции. Так, определим простейший TableView в коде C#:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    public StartPage()
    {
        TableView tableView = new TableView
        {
            Intent = TableIntent.Data,
            Root = new TableRoot("Разработка ПО")
            {
                new TableSection ("Языки программирования")
                {
                    new TextCell{ Text = "Java", Detail = "Был создан в 1995 году в компании Sun Microsystems"},
                    new TextCell{ Text = "C#", Detail = "Был создан в 2000 году в компании Microsoft"}
                },
                new TableSection ("Базы данных")
                {
                    new TextCell{ Text = "MySQL", Detail = "Была создана в 1995 году в компании MySQL AB"},
                    new TextCell{ Text = "MS SQL Server", Detail = "Была создана в 1989 году в компании Microsoft"},
                }
            }
        };
        Content = new StackLayout { Children = { tableView }, Padding = 10 };
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.36.png)

Чтобы определить содержимое TableView, надо его свойству Root присвоить некоторый объект TableRoot. TableRoot хранит секции таблицы в виде объектов TableSection. Каждая же секция в свою очередь содержит набор отдельных ячеек или элементов Cell. В данном же случае есть две секции. Каждая секция содержит по два элемента TextCell, которые по сути просто выводят текст через свойство Text. А через свойство Detail можно определить некоторое описание к тексту.

Аналог в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="8">
        <TableView>
            <TableView.Root>
                <TableRoot Title="Разработка ПО">
                    <TableSection Title="Языки программирования">
                        <TextCell Text="Java" Detail="Был создан в 1995 году в компании Sun Microsystems" />
                        <TextCell Text="C#" Detail="Был создан в 2000 году в компании Microsoft" />
                    </TableSection>
                    <TableSection Title="Базы данных">
                        <TextCell Text="MySQL" Detail="Была создана в 1995 году в компании MySQL AB" />
                        <TextCell Text="MS SQL Server" Detail="Была создана в 1989 году в компании Microsoft" />
                    </TableSection>
                </TableRoot>
            </TableView.Root>
        </TableView>
    </StackLayout>
</ContentPage>
```

# Типы ячеек

При создании таблицы мы можем использовать разные виды ячеек:

- EntryCell: представляет метку с текстовым полем для ввода данных

- SwitchCell: представляет метку с переключателем

- TextCell: две метки для вывода текста

- ImageCell: аналогична TextCell со включением изображения

- ViewCell: содержимое и формат отображения данных ячейки определяется разработчиком

Наиболее часто используемыми из них являются SwitchCell и EntryCell.

Каждый тип ячеек имеет свой набор свойств. Например, для ячейки типа SwitchCell можно выделить два следующих свойства:

- Text: представляет текст ячейки

- On: указывает, находится в отмеченном или нет состоянии

А у EntryCell можно выделить следующие свойства:

- Keyboard: тип клавиатуры, которая отображается для ввода текста

- Label: текстовая метка, которая отображается слева от поля ввода

- LabelColor: цвет текста метки

- Placeholder: текст, отображаемый до ввода текста

- Text: сам введенный текст

- HorizontalTextAlignment: горизонтальное выравнивание текста

# Обработка событий

Элементы TableView поддерживают обработку событий. Для каждого типа ячеек тип поддерживаемых событий различается.

Так, EntryCell при завершении ввода (когда пользователь нажимает на кнопку "Готово" на клавиатуре) генерирует событие Completed.

Объект SwitchCell при переключении состояния генерирует событие OnChanged

Например обработаем события EntryCell и SwitchCell. Определим в XAML следующий код:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="8">
        <Label x:Name="loginLbl" FontSize="18" />
        <Label x:Name="saveLbl" FontSize="18" />
        <TableView>
            <TableView.Root>
                <TableRoot>
                    <TableSection Title="Персональные данные">
                        <EntryCell x:Name="loginEntry" Label="Логин" Keyboard="Default" Placeholder="Введите логин" Completed="OnTextCompleted" />
                        <SwitchCell x:Name="saveSwitch" Text="Сохранить" OnChanged="OnStatusChanged" />
                    </TableSection>
                </TableRoot>
            </TableView.Root>
        </TableView>
    </StackLayout>
</ContentPage>
```

В файле кода C# пропишем обработку событий:

```Csharp
namespace HelloApp;
 
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
    }
    void PickerSelectedIndexChanged(object sender, EventArgs e)
    {
        header.Text = $"Вы выбрали: {languagePicker.SelectedItem}";
    }
}
```

# TableView

Класс TableView позволяет создавать табличные представления с различным содержимым. TableView может быть полезен для отображения списка различных настроек, вывод данных в виде формы, для построчного отображения данных и т.д.

Среди свойств TableView следует выделить следующие:

- Intent: определяет назначение таблицы на iOS (применяется только к iOS). Представляет одну из констант перечисления TableIntent:

- Data: предназначен для простого отображения данных

- Form: представляет форму ввода данных, как в примере выше

- Menu: используется для вывода меню

- Settings: используется для отображения набора настроек

- HasUnevenRows: представляет тип bool и указывает, будут ли строки в таблицы иметь различную высоту. Значение по умолчаниюfalse.

- Root: определяет содерижимое таблицы в виде объекта TableRoot.

- RowHeight: определяет высоту строк в виде значения int, если свойство HasUnevenRows равно false.

Элементы в TableView организованы в секции (элементы TableSection). Корневым элементов в TableView является элемент TableRoot, который инкапсулирует в себе все секции. Так, определим простейший TableView в коде C#:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    public StartPage()
    {
        TableView tableView = new TableView
        {
            Intent = TableIntent.Data,
            Root = new TableRoot("Разработка ПО")
            {
                new TableSection ("Языки программирования")
                {
                    new TextCell{ Text = "Java", Detail = "Был создан в 1995 году в компании Sun Microsystems"},
                    new TextCell{ Text = "C#", Detail = "Был создан в 2000 году в компании Microsoft"}
                },
                new TableSection ("Базы данных")
                {
                    new TextCell{ Text = "MySQL", Detail = "Была создана в 1995 году в компании MySQL AB"},
                    new TextCell{ Text = "MS SQL Server", Detail = "Была создана в 1989 году в компании Microsoft"},
                }
            }
        };
        Content = new StackLayout { Children = { tableView }, Padding = 10 };
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.36.png)

Чтобы определить содержимое TableView, надо его свойству Root присвоить некоторый объект TableRoot. TableRoot хранит секции таблицы в виде объектов TableSection. Каждая же секция в свою очередь содержит набор отдельных ячеек или элементов Cell. В данном же случае есть две секции. Каждая секция содержит по два элемента TextCell, которые по сути просто выводят текст через свойство Text. А через свойство Detail можно определить некоторое описание к тексту.

Аналог в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="8">
        <TableView>
            <TableView.Root>
                <TableRoot Title="Разработка ПО">
                    <TableSection Title="Языки программирования">
                        <TextCell Text="Java" Detail="Был создан в 1995 году в компании Sun Microsystems" />
                        <TextCell Text="C#" Detail="Был создан в 2000 году в компании Microsoft" />
                    </TableSection>
                    <TableSection Title="Базы данных">
                        <TextCell Text="MySQL" Detail="Была создана в 1995 году в компании MySQL AB" />
                        <TextCell Text="MS SQL Server" Detail="Была создана в 1989 году в компании Microsoft" />
                    </TableSection>
                </TableRoot>
            </TableView.Root>
        </TableView>
    </StackLayout>
</ContentPage>
```

# Типы ячеек

При создании таблицы мы можем использовать разные виды ячеек:

- EntryCell: представляет метку с текстовым полем для ввода данных

- SwitchCell: представляет метку с переключателем

- TextCell: две метки для вывода текста

- ImageCell: аналогична TextCell со включением изображения

- ViewCell: содержимое и формат отображения данных ячейки определяется разработчиком

Наиболее часто используемыми из них являются SwitchCell и EntryCell.

Каждый тип ячеек имеет свой набор свойств. Например, для ячейки типа SwitchCell можно выделить два следующих свойства:

- Text: представляет текст ячейки

- On: указывает, находится в отмеченном или нет состоянии

А у EntryCell можно выделить следующие свойства:

- Keyboard: тип клавиатуры, которая отображается для ввода текста

- Label: текстовая метка, которая отображается слева от поля ввода

- LabelColor: цвет текста метки

- Placeholder: текст, отображаемый до ввода текста

- Text: сам введенный текст

- HorizontalTextAlignment: горизонтальное выравнивание текста

# Обработка событий

Элементы TableView поддерживают обработку событий. Для каждого типа ячеек тип поддерживаемых событий различается.

Так, EntryCell при завершении ввода (когда пользователь нажимает на кнопку "Готово" на клавиатуре) генерирует событие Completed.

Объект SwitchCell при переключении состояния генерирует событие OnChanged

Например обработаем события EntryCell и SwitchCell. Определим в XAML следующий код:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="8">
        <Label x:Name="loginLbl" FontSize="18" />
        <Label x:Name="saveLbl" FontSize="18" />
        <TableView>
            <TableView.Root>
                <TableRoot>
                    <TableSection Title="Персональные данные">
                        <EntryCell x:Name="loginEntry" Label="Логин" Keyboard="Default" Placeholder="Введите логин" Completed="OnTextCompleted" />
                        <SwitchCell x:Name="saveSwitch" Text="Сохранить" OnChanged="OnStatusChanged" />
                    </TableSection>
                </TableRoot>
            </TableView.Root>
        </TableView>
    </StackLayout>
</ContentPage>
```

В файле кода C# пропишем обработку событий:

```Csharp
namespace HelloApp;
 
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
    }
    void OnTextCompleted(object sender, EventArgs e)
    {
        loginLbl.Text = loginEntry.Text;
    }
 
    void OnStatusChanged(object sender, ToggledEventArgs e)
    {
        saveLbl.Text = saveSwitch.On ? "сохранено" : "не сохранено";
    }
}

```

!(https://metanit.com/sharp/maui/pics/4.37.png)

При запуске на Windows10/11 событие Completed у EntryCell срабатывает при нажатии клавиши Enter при вводе в текстовое поле.

# Использование изображений

Для вывода изображений применяется тип ImageCell. По сути это тот же TextCell, только с возможностью отображения картинки. Путь к изобрадению хранится в свойстве ImageSource. Простейший пример в XAML:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="8">
        <TableView>
            <TableView.Root>
                <TableRoot>
                    <TableSection Title="Языки программирования">
                        <ImageCell Text="C#" Detail="Создатель: Андерс Хейлсберг" ImageSource="csharp.jpg"  />
                        <ImageCell Text="C++" Detail="Создатель: Бьорн Страуструп" ImageSource="cpp.jpg" />
                        <ImageCell Text="Java" Detail="Создатель: Джеймс Гослинг" ImageSource="java.jpg" />
                    </TableSection>
                </TableRoot>
            </TableView.Root>
        </TableView>
    </StackLayout>
</ContentPage>
```

В данном случае предполагается, что в проекте в папке Resources/Images расположены файлы csharp.jpg, cpp.jpg и java.jpg.

!(https://metanit.com/sharp/maui/pics/4.38.png)

# WebView

Класс WebView представляет собой мини-веббраузер, позволяющий просматривать веб-контент в виде веб-страниц из интернета, локальных html-файлов и просто строк с кодом html. Некоторые из свойств WebView, которые позволяют управлять навигацией

Cookies: представляет тип CookieContainer и позволяет управлять куками.

CanGoBack: представляет тип bool и указывает, можно ли перейти к предыдущей странице. Данное свойство доступно только для чтения.

CanGoForward: представляет тип bool и указывает, можно ли перейти к следующей странице. Данное свойство доступно только для чтения.

Source: представляет тип WebViewSource - адрес текущей html-страницы, которая отображается в WebView. В реальности данное свойство будет представлять один из наследников класса WebViewSource: либо тип UrlWebViewSource (если html-страница загружена из интернета), либо тип HtmlWebViewSource (если загружен локальный html-файл)

Следует учитывать, что если объект WebView помещается в контейнеры HorizontalStackLayout, StackLayout или VerticalStackLayout, то для WebView необходимо установить свойства HeightRequest и WidthRequest. Иначе WebView не будет отображаться.

# Просмотр данных из интернета

Для загрузки данных нам надо передать свойству Source элемента WebView определенный интернет-адрес:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    public StartPage()
    {
        WebView webView = new WebView 
        { 
            Source = "https://metanit.com/"
        };
        Content = webView;
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.39.png)

Стоит отметить, что хотя свойство Source представляет тип WebViewSource, мы можем передать этому свойство обычную строку с адресом. И фреймворк сам преобразует ее в требуемый тип. То есть по сути в примере выше адрес устанавливается следующим образом:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    public StartPage()
    {
        WebView webView = new WebView 
        { 
            Source = new UrlWebViewSource { Url = "https://metanit.com/" },
        };
        Content = webView;
    }
}
```

Аналог в xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <WebView Source="https://metanit.com/" />
</ContentPage>
```

# Примечение для iOS

Начиная с версии iOS 9 система позволяет взаимодействовать только с теми серверами, которые применяют SSL. Для всех остальных серверов, которые не применяют SSL, надо вносить соответствующие значения в файл Info.plist.

```xml
<key>NSAppTransportSecurity</key>
    <dict>
        <key>NSExceptionDomains</key>
        <dict>
            <key>xamarin.com</key>
            <dict>
                <key>NSIncludesSubdomains</key>
                <true/>
                <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>
                <true/>
                <key>NSTemporaryExceptionMinimumTLSVersion</key>
                <string>TLSv1.1</string>
            </dict>
        </dict>
    </dict>
```

В данном случае дается разрешение для работы с сайтом xamarin.com. Но если нам вообще надо снять ограничение, то мы можем использовать более универсальную, но менее безопасную настройку:

```xml
<key>NSAppTransportSecurity</key>
    <dict>
        <key>NSAllowsArbitraryLoads </key>
        <true/>
    </dict>
```

Чтобы внести изменения в файл, надо его открыть как xml-файл в обычном текстовом редакторе.

# Загрузка HTML-строк

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    public StartPage()
    {
        WebView webView = new WebView();
        var htmlSource = new HtmlWebViewSource();
        htmlSource.Html = @"
                      <h1>Hello METANIT.COM</h1>
                      <p>Hello .NET MAUI!</p>
                      ";
        webView.Source = htmlSource;
        Content = webView;
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.40.png)

Аналог в XAML:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <WebView>
        <WebView.Source>
            <HtmlWebViewSource>
                <HtmlWebViewSource.Html>
                    <![CDATA[
                    <h1>Hello METANIT.COM</h1>
                    <p>Hello .NET MAUI!</p>
                    ]]>
                </HtmlWebViewSource.Html>
            </HtmlWebViewSource>
        </WebView.Source>
    </WebView>
</ContentPage>
```

Для большей читаемости кода HTML в XAML HTML-код помещается в секцию CDATA.

#   Загрузка локальных html-файлов

WebView может запускать файлы HTML, CSS и Javascript, которые встроены в приложение. Локальные файлы html, а также все сопутствующие ресурсы - файлы изображений, мультимедиа, скрипты javascript, стили css следует помещать в проекте в папку Resources\Raw. Кроме того, у всех этих файлов параметр Build Action должен быть установлен в MauiAsset.

Например, пусть у нас в папке Resources\Raw есть следующий html-файл index.html:

```xml
<!DOCTYPE html>
<html>
<head>
    <title>METANIT.COM</title>
    <meta charset="utf-8" />
    <link href="./styles.css" rel="stylesheet">
</head>
<body>
    <h1>Зимний лес</h1>
    <img src="forest.jpg" />
</body>
</html>
```

Этот файл использует таблицу стилей из файла styles.css и файл изображения forest.jpg. Также надо учесть, что данный файл имеет кодировку utf-8.

Убедимся, что у всех этих файлов параметр Build Action должен быть установлен в MauiAsset.

!(https://metanit.com/sharp/maui/pics/4.41.png)

Теперь загрузим файл index.html в коде C#:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    public StartPage()
    {
        WebView webView = new WebView();
        webView.Source = "index.html";
        Content = webView;
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.42.png)

Аналог в XAML

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <WebView Source="index.html" />
</ContentPage>
```

# Управление навигацией

Класс WebView поддерживает программный переход к страницам, сохраненным в истории переходов. Для этого класс определяет методы GoBack() (переход к предыдущей странице) и GoForward (переход к следующей странице).

```Csharp
WebView webView = new WebView();
// ...........
// если можно перейти назад, переходим назад
if (webView.CanGoBack)
{
    webView.GoBack();
}
 
// если можно перейти вперед, переходим вперед
if (webView.CanGoForward)
{
    webView.GoForward();
}
```

Для отслеживания навигации класс WebView определяет два события:

- Navigating: возникает, когда начинается переход на страницу. В качестве параметра принимает аргумент типа WebNavigatingEvent, который определяет свойство Cancel. Если это свойство равно true, то переход на страницу отменен.

- Navigated: возникает, когда переход на страницу завершен. В качестве параметра принимает объект класса WebNavigatedEventArgs. Этот класс определяет свойство Result, которое представляет тип WebNavigationResult и хранит результат перехода в виде одной из констант WebNavigationResult:

- Success: переход успешно завершился

- Cancel: переход отменен

- Timeout: таймаут в процессе перехода

- Failure: переход завершился неудачно

Пример обработки перехода:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    Label statusLabel = new Label() { Padding=8, FontSize=20};
    public StartPage()
    {
        Grid grid = new Grid();
        grid.RowDefinitions.Add(new RowDefinition { Height = 60 });
        grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Star });
 
        WebView webView = new WebView();
        webView.Source = "https://metanit.com";
        webView.Navigated += WebView_Navigated; // подключаем обработчик события
 
        grid.Add(statusLabel, 0, 0);
        grid.Add(webView, 0, 1);
        Content = grid;
    }
    // обрабатываем завершение перехода
    void WebView_Navigated(object sender, WebNavigatedEventArgs e)
    {
        if (e.Result == WebNavigationResult.Success)
            statusLabel.Text = "Запрос завершился успешно";
        else
            statusLabel.Text = "В процессе запроса возникли проблемы";
    }
}
```

# Всплывающие окна

Для создания всплывающих окон в .NET MAUI используются специальные методы, которые определены у объекта Page, а поэтому есть у любой страницы:

```Csharp
Task DisplayAlert (string title, string message, string cancel) 
Task<bool> DisplayAlert (string title, string message, string accept, string cancel) 
Task<bool> DisplayAlert (string title, string message, string accept, string cancel, FlowDirection flowDirection) 
Task<string> DisplayActionSheet (string title, string cancel, 
                            string destruction, params string[] buttons)
Task<string> DisplayPromptAsync(string title, string message, string accept = "OK", 
                            string cancel = "Cancel", string placeholder = null, int maxLength = -1, 
                            Keyboard keyboard = null, string initialValue = "");
```

## DisplayAlert

Вначале рассмотрим использование метода DisplayAlert. Используем его первую версию:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    public StartPage()
    {
        Button alertButton = new Button
        {
            Text = "Alert",
            VerticalOptions = LayoutOptions.Start,
            HorizontalOptions = LayoutOptions.Center
        };
        alertButton.Clicked += AlertButton_Clicked;
 
        Content = alertButton;
    }
 
    async void AlertButton_Clicked(object sender, EventArgs e)
    {
        await DisplayAlert("Уведомление", "Пришло новое сообщение", "ОK");
    }
}
```
Первый параметр передает заголовок окна, второй - текст окна, третий - надпись на кнопки отмены.

!(https://metanit.com/sharp/maui/pics/4.43.png)

Эта версия метода просто выводит некоторое диагностическое сообщение. Но если нам необходимо, чтобы всплывающее окно предоставляло пользователю некоторый выбор, который надо обработать, то можно использовать вторую версию. Для этого изменим обработчик кнопки:


```Csharp
async void AlertButton_Clicked(object sender, EventArgs e)
{
    bool result = await DisplayAlert("Подтвердить действие", "Вы хотите удалить элемент?", "Да", "Нет");
    await DisplayAlert("Уведомление", "Вы выбрали: "+ (result ? "Удалить" : "Отменить"), "OK");
}
```

!(https://metanit.com/sharp/maui/pics/4.44.png)

# DisplayActionSheet

Всплывающее окно, которое создается методом DisplayActionSheet(), предоставляет возможность выбора из ряда действий. Получив выбранное значение, затем мы можем произвести какие-то действия на основании этого значения.

Метод DisplayActionSheet() принимает следующие параметры:

```Csharp
Task<string> DisplayActionSheet (String title, String cancel, String destruction, params String[] buttons)
```

- title: заголовок окна

- cancel: текст для кнопки отмены. Может быть равен null, если мы хотим скрыть эту кнопку

- destruction: текст для кнопки удаления. Также для скрытия этой кнопки можно передать значение null

- buttons: текстовые метки для дополнительных кнопок

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    Label actionLabel;
    public StartPage()
    {
        Button alertButton = new Button { Text = "Alert", HorizontalOptions=LayoutOptions.Center };
        alertButton.Clicked += AlertButton_Clicked;
        actionLabel = new Label();
        Content = new StackLayout { Children = { alertButton, actionLabel } };
    }
 
    async void AlertButton_Clicked(object sender, EventArgs e)
    {
        var action = await DisplayActionSheet("Выбрать язык", "Отмена", "Удалить", "C#", "JavaScript", "Java");
        actionLabel.Text = action;
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.45.png)

Если нам не нужна какая-то кнопка, например, в примере выше если кнопку Отмены мы можем использовать просто для отмены выбора и закрытия всплывающего сообщения, то кнопка Удалить в данной ситуации не особенно нужна. Поэтому для ее сокрытия вместо ее текста можно использовать null:

```Csharp
var action = await DisplayActionSheet("Выбрать язык", "Отмена", null, "C#", "JavaScript", "Java");
```

## DisplayPromptAsync

Еще один метод - DisplayPromptAsync позволяет ввести данные во всплывающее окно, введенные данные возвращаются методом.

Метод DisplayActionSheet() принимает следующие параметры:

```Csharp
Task<string> DisplayPromptAsync(string title, string message, string accept = "OK", string cancel = "Cancel", string placeholder = null, int maxLength = -1, Keyboard keyboard = null, string initialValue = "");
```

- title: заголовок окна

- message: приглашение к вводу

- accept: текст для кнопки подтверждения ввода

- cancel: текст для кнопки отмены. Может быть равен null, если мы хотим скрыть эту кнопку

- placeholder: текст-заменитель в текстовом поле ввода

- maxLength: максимальная длина текстового поля ввода

- keyboard: объект KeyBoard, который устанавливает тип клавиатуры для ввода

- initialValue: начальное значение в поле ввода

Пример использования:

```Csharp
namespace HelloApp;
 
class StartPage : ContentPage
{
    Label nameLabel;
    public StartPage()
    {
        Button alertButton = new Button { Text = "Alert", HorizontalOptions=LayoutOptions.Center };
        alertButton.Clicked += AlertButton_Clicked;
        nameLabel = new Label();
        Content = new StackLayout { Children = { alertButton, nameLabel } };
    }
 
    async void AlertButton_Clicked(object sender, EventArgs e)
    {
        var name = await DisplayPromptAsync("Логин", "Введите имя:", "OK", "Отмена");
        nameLabel.Text = name;
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.46.png)

# Индикация прогресса. ProgressBar и ActivityIndicator

ProgressBar
Элемент ProgressBar представляет горизонтальную полосу, которая отображает прогресс некоторого действия.

Класс ProgressBar определяет два свойства:

- Progress представляет значение типа double, которое представляет значение прогресса. Данное число находится в диапазоне от 0 до 1. Значение по умолчанию - 0.

Стоит отметить, что значения меньше 0 будут округлены до 0, а значения больше 1 будут округлены до 1

- ProgressColor устанавливает цвет элемент

Например:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            StackLayout stackLayout = new StackLayout { Padding = 20 };
 
            Label label = new Label { Text = "ProgressBar" };
            ProgressBar progressBar = new ProgressBar{ Progress = 0.4, ProgressColor = Colors.SeaGreen };
 
            stackLayout.Children.Add(label);
            stackLayout.Children.Add(progressBar);
            Content = stackLayout;
        }
    }
}
```
В данном случае устанавливаем в качестве начального значения 0.4, а в качестве цвета - зеленый цвет

!(https://metanit.com/sharp/maui/pics/4.48.png)

Аналогичный пример в XAML:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
 
    <StackLayout Padding="20">
        <Label Text="Progressbar" />
        <ProgressBar Progress="0.4" ProgressColor="SeaGreen" />
    </StackLayout>
 
</ContentPage>
```

Манипулируя значением свойства Progress, мы можем динамически изменять индикацию процесса. Например, эмулируем некоторый процесс:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        ProgressBar progressBar = new ProgressBar { ProgressColor = Colors.SeaGreen };
        Label label = new Label();
        public StartPage()
        {
            StackLayout stackLayout = new StackLayout { Padding = 20 };

            stackLayout.Children.Add(label);
            stackLayout.Children.Add(progressBar);
            Content = stackLayout;
        }
        protected override async void OnAppearing()
        {
            while(progressBar.Progress < 0.9)
            {
                progressBar.Progress += 0.1;
                label.Text = $"Состояние процесса: {Math.Round(progressBar.Progress, 1) * 100} %";
                await Task.Delay(1000);
            }
            label.Text = "Процесс закончен";
            base.OnAppearing();
        }
    }
}
```

В методе OnAppearing(), который вызывается, когда страница начинаеть отображаться на экране, в цикле while увеличиваем текущее значение ProgressBar, пока оно меньше 0.9. И для имитации делаем задержку в секунду, отображая с помощью метки состояние прогресса.

!(https://metanit.com/sharp/maui/pics/4.49.png)

# ActivityIndicator

ActivityIndicator похож на ProgressBar, только отображает процесс с помощью кругового индикатора. Он определяет два свойства:

- IsRunning: при значении true индиктор активен.

- Color: цвет индикатора

Определение в коде C#:

```Csharp
ActivityIndicator activityIndicator = new ActivityIndicator { IsRunning = true, Color = Colors.SeaGreen };
```
Определение в коде XAML:

```xml
<ActivityIndicator IsRunning="true" Color="SeaGreen" />
```

Имитируем некоторый процесс, и пока процесс идет, отобразим индикатор:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        ActivityIndicator activityIndicator = new ActivityIndicator { IsRunning = true, Color = Colors.SeaGreen };
        Label label = new Label();
        public StartPage()
        {
            StackLayout stackLayout = new StackLayout { Padding = 20 };
 
            stackLayout.Children.Add(label);
            stackLayout.Children.Add(activityIndicator);
            Content = stackLayout;
        }
        protected override async void OnAppearing()
        {
            int count = 0;
            while (count != 100)
            {
                label.Text = $"Состояние процесса: {count} %";
                await Task.Delay(2000);
                count +=10;
            }
            label.Text = "Процесс закончен";
            activityIndicator.IsRunning = false;
            base.OnAppearing();
        }
    }
}
```

!(https://metanit.com/sharp/maui/pics/4.50.png)
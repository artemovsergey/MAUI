# ГЛАВА 10

# Удаленные данные

В этой главе вы будете изучать тему удаленных данных, изучая что это такое, виды, как с ним взаимодействовать и что учитывать при этом. Затем вы будете основываться на этом обучении, создавая новую widget: виджет погоды для отображения текущей погоды. Это будет можно сделать, взаимодействуя непосредственно с ```Open Weather API```. Ты получишь
знакомство с обработкой HTTP-запросов и ответов с помощью API, как
для обработки ответа в формате ```JSON``` и различных уровней
гибкость при сопоставлении с данными ```JSON```. Вы закончите, упростив
реализация с фантастическим пакетом NuGet, который генерирует исходный код
код для вас, просто из интерфейса, который вы определяете для представления сети
услуга.

# Что такое удаленные данные?

Удаленные данные — это любые данные, полученные извне устройства, на котором вы приложение запущено. Это может варьироваться от запроса веб-API для
для получения данных, используя поставщика облачных баз данных, изображения, размещенные онлайн, потоковое видео или аудио данные и многое другое.
Подавляющее большинство приложений будет взаимодействовать с той или иной формой удаленная конечная точка для извлечения данных. В этом постоянно меняющемся мире данных, это становится неотъемлемой частью практически любого приложения.

# Что следует учитывать при обработке удаленных данных

При взаимодействии с
удаленные данные. Вы будете явно обращаться к ним, когда будете создавать новый
виджет, но я хочу обратить ваше внимание на них, прежде чем вы начнете.

# Время загрузки

Один из худших опытов для пользователя — нажать на кнопку или открыть новый
страница/приложение и просто увидите, как приложение блокируется во время загрузки данных.
Пользователь будет думать, что приложение зависло и на самом деле платформы
как Android и Windows, скорее всего, укажет, что приложение
разбился / заблокировался, если загрузка занимает слишком много времени. К счастью, .NET предлагает вам
ключевые слова async и await. Они не являются необходимыми, но они действительно делают
ваша жизнь проще. На эту тему может быть целая глава или даже книга;
тем не менее, мой хороший друг Брэндон Минник уже осветил многое из этого.
в своем репозитории AsyncAwaitBestPractices на GitHub. Если вы не проверили
это раньше, я настоятельно рекомендую вам сделать это, если вы хотите копнуть глубже;
https://github.com/brminnick/AsyncAwaitBestPractices.
Обычный вариант использования — показать пользователю, что приложение занято.
загрузка. Это может быть с помощью простого ActivityIndicator, который загружает
Спиннер/значок загрузки для конкретной платформы, с которым пользователи должны быть знакомы, или вы
можно использовать функции анимации, которые я рассмотрел, чтобы показать что-то большее
вовлеченный. С помощью этого экрана загрузки вы затем инициируете вызов веб-службы. Если
вы получаете ответ, вы отображаете результат этого ответа в своем приложении
(например, элементы в списке покупок или, в вашем сценарии, текущая погода пользователя).

# Сбои

Во время создания недавнего приложения некоторые из наиболее ценных
тестирование, которое я провел, заключалось в том, чтобы установить приложение, а затем прокатиться по Лондону.
Под землей и посмотрите, насколько ненадежны данные мобильного телефона
связь действительно может быть.

Есть два ключевых вопроса, которые следует учитывать при работе с сетью.
проблемы с подключением:
1. Что нужно знать пользователю?
2. Как приложение должно восстанавливаться?

# Безопасность

Как разработчику приложений важно, чтобы вы поддерживали доверие
которые ваши пользователи вкладывают в вас в отношении обеспечения безопасности своих данных. С
Имея это в виду, вы всегда должны выбирать HTTPS вместо HTTP. На самом деле, большинство
платформы по умолчанию не разрешают HTTP-трафик, чтобы избежать его случайного
использовал. Есть способы отключить предотвращение HTTP-трафика; Однако я
настоятельно не советую этого делать, поэтому в этой книге я не буду описывать, как это сделать.
Я настоятельно рекомендую, чтобы при создании приложений вы учитывали
безопасность как главный приоритет. Открытый проект безопасности веб-приложений
(OWASP) — некоммерческий фонд, работающий над повышением безопасности
программного обеспечения, и оно предоставляет некоторые действительно отличные ресурсы и рекомендации
о том, что вы действительно должны учитывать при создании веб-сайтов и мобильных
Приложения. В качестве хорошей отправной точки посмотрите на их мобильное приложение.
Репозиторий руководства по тестированию безопасности на GitHub по адресу https://github.com/OWASP/owasp-mastg/.
Довольно часто API требуют уровней аутентификации, которые усложняют
поток для извлечения данных из них. Обычно это происходит, когда ваш
приложение должно потреблять данные, специфичные для пользователя, а не только API
сам. Я не буду рассматривать этот сценарий в этой книге, но я рекомендую
почитайте об OAuth2.0 с хорошим начальным ресурсом на www.oauth.com/
oauth2-серверы/мобильные и собственные приложения/. Кроме того, специальные API
такие как GitHub API, скорее всего, предоставят хорошую документацию о том, как
использовать свой особый механизм аутентификации. Итак, имея это в виду, я
рекомендуем обратиться к документации по API, который вы хотите
интегрироваться с.

# Веб-сервисы

Веб-сервисы действуют как механизм запроса или получения данных из удаленного
сервер. Как правило, они предлагают множество преимуществ разработчикам, которые их создают.
поскольку они обеспечивают возможность зарядки в зависимости от использования, защищают
интеллектуальная собственность разработчика и другие причины.

# Открытый API погоды

Вы будете вызывать Open Weather API и, в частности, версию 2.5
API OneCall. API можно использовать бесплатно с некоторыми ограничениями использования. Ты можешь
звоните на него до 60 раз в минуту и ​​1 000 000 звонков в месяц, что позволит
конечно, будет хорошо для этого сценария.
Для первоначальной работы вы будете использовать фиксированные широту и долготу
20,7984 и -156,3319 соответственно, что, если вы посмотрите, представляет собой
Мауи, Гавайи. Вы разрешите приложению использовать текущую
информацию о местоположении в следующей главе.

# Создание открытой учетной записи погоды

Вам будет необходимо создать учетную запись. Для этого перейдите на сайт
на https://home.openweathermap.org/users/sign_up и создайте
счет. Обратите внимание, что вам не нужно вводить никаких платежных данных. Ты можешь
используйте его совершенно бесплатно. Если вы нарушите ограничения вызовов, API просто выйдет из строя
вместо случайных зарядов.

# Создание ключа Open Weather API

Далее вам необходимо создать ключ API, что можно сделать на следующем
страницу по адресу https://home.openweathermap.org/api_keys. Сохраните копию этого
Ключ API готов, когда вы в конечном итоге будете использовать его позже в этой главе. Не
пока слишком беспокойтесь, так как вы можете вернуться на указанную выше веб-страницу и
получить доступ к ключу.

# Изучение данных

Прежде чем погрузиться в написание кода, вы должны взглянуть на API
и данные, которые он возвращает. На самом деле API предлагает гораздо больше деталей, чем
вам действительно нужно. Вы можете потреблять детали, если хотите их использовать
в будущем; однако это приводит к некоторым возможным недостаткам. Это
увеличивает сложность чтения данных, если вам нужно отладить
вещей, а также увеличивает объем данных, которые необходимо получить
по вашему приложению. В мобильном мире это может быть дорого!
Учитывая вышеизложенное, вы можете сделать следующий вызов веб-службы, который
включает следующие детали:
• Звонки версии 2.5 API OneCall.
• Обеспечивает широту 20,7984
• Поставляет долготу -156,3319
• Предоставляет метрические единицы, что означает, что вы получите
градусов Цельсия
• Поставки исключают поминутные, ежечасные, ежедневные, оповещения,
это означает, что вы будете получать только текущие данные о погоде
• Предоставляет ключ API, созданный в предыдущем разделе.
Полный URL-адрес, который вам нужно вызвать, выглядит следующим образом:
https://api.openweathermap.org/data/2.5/onecall?lat=20.7984&
lon=-156.3319&units=metric&exclude=minutely,hourly,daily,alerts
&appid=APIKEY

Вы можете открыть это в любом веб-браузере, чтобы просмотреть следующий ответ
назад. Вы можете увидеть ключевые детали, которые вам понадобятся для вашего приложения
выделены жирным шрифтом.

```json
{
 "lat": 20.7984,
 "lon": -156.3319,
"timezone": "Pacific/Honolulu",
 "timezone_offset": -36000,
 "current": {
 "dt": 1663101650,
 "sunrise": 1663085531,
 "sunset": 1663129825,
 "temp": 20.77,
 "feels_like": 21.15,
 "pressure": 1017,
 "humidity": 86,
 "dew_point": 18.34,
 "uvi": 7.89,
 "clouds": 75,
 "visibility": 10000,
 "wind_speed": 5.66,
 "wind_deg": 70,
 "weather": [
 {
 "id": 501,
 "main": "Rain",
 "description": "moderate rain",
 "icon": "10d"
 }
 ],
 "rain": {
 "1h": 1.78
 }
 }
}
```
# Использование System.Text.Json

Чтобы использовать и десериализовать содержимое ```JSON```, возвращенного в
вам, вам нужно использовать один из следующих двух вариантов:
• ```Newtonsoft.Json``` (требуется пакет NuGet)
• ```System.Text.Json```
Newtonsoft существует уже много лет и является отличным выбором для
много разработчиков. ```System.Text.Json``` стал его преемником и является моим
рекомендацию для этого сценария, тем более, что она поддерживается корпорацией Майкрософт
а Джеймс Ньютон-Кинг, автор Newtonsoft, работает в Microsoft.
Давайте продолжим и будем использовать ```System.Text.Json```, так как это рекомендуемый способ.
для продолжения и поставляется с .NET MAUI из коробки.
Теперь, когда вы увидели, как выглядят данные, вы можете начать строить
классы модели, которые позволят вам десериализовать ответ, приходящий
вернулся из API.

# Создание ваших моделей

Я подчеркнул, что вам действительно не нужна вся информация, которая
возвращается из API. К счастью, вам нужно только построить свою модель, чтобы
покрыть детали, которые вам нужны, и позволить игнорировать остальные во время
процесс десериализации.
Давайте создадим необходимые вам классы моделей. Вы делаете это в обратном порядке
порядок их появления в JSON из-за того, что внешние элементы
необходимо обратиться к внутренним элементам.
Сначала добавьте новую папку, чтобы все было организовано, и назовите ее
Коммуникации.
Теперь добавьте новый файл класса и назовите его ```Weather.cs```.
пространство имен ```WidgetBoard.Communications```;

```Csharp
namespace WidgetBoard.Communications;
public class Weather
{
 public string Main { get; set; }
 public string Icon { get; set; }
 public string IconUrl => $"https://openweathermap.org/img/wn/{Icon}@2x.png";
}
```
Ваш класс Weather сопоставляется с элементом погоды в возвращаемом JSON.
из API. Вы можете видеть, что вы сопоставляете с основным и значком
элементов, и вы добавили вычисляемое свойство, которое возвращает URL
указывая на значок, предоставленный Open Weather API. Последнее свойство
вы сопоставляете, IconUrl, является еще одним прекрасным примером удаленных данных.
API предоставляет вам значок, который может отображаться внутри вашего
приложение, представляющее текущую погоду местоположения. На основе
пример в исходном JSON вы видите значение значка 10d. Этот
представляет дождь.

---
Вы заметите, что регистр имен ваших свойств не
соответствуют именам элементов в JSON. Это фактически приведет к
процесс десериализации для отображения по мере необходимости. Когда вы доберетесь до
часть десериализации, вы увидите, как справиться с этим сценарием.
---

Ваш следующий класс модели, который нужно добавить, должен называться Current и, аналогично
к классу Weather он будет отображаться на элемент, который соответствует его имени:
текущий. Ваш текущий файл класса должен иметь следующее содержимое:

```Csharp
using System.Text.Json.Serialization;
namespace WidgetBoard.Communications;
public class Current
{
 [JsonPropertyName("temp")]
 public double Temperature { get; set; }
 public int Sunrise { get; set; }
 public int Sunset { get; set; }
 public Weather[] Weather { get; set; }
}
```
Этот класс будет содержать массив погоды, заката и восхода солнца.
раз и текущая температура. Со свойством Температура
сопоставление, вы можете увидеть, как можно сопоставить свойство в вашем
модели в элемент в JSON с другим именем. Эта функциональность
чрезвычайно ценно при построении собственных моделей, поскольку позволяет
вы должны назвать свойства, чтобы обеспечить лучший контекст. лично я предпочитаю
избегайте аббревиатур и придерживайтесь явных названий, чтобы сделать намерения
код четкий.
Последний добавляемый класс модели должен называться ```Forecast.cs``` и будет
иметь следующее содержание:

```Csharp
namespace WidgetBoard.Communications;
public class Forecast
{
 public string Timezone { get; set; }
 public Current Current { get; set; }
}
```

Этот класс сопоставляется с элементом верхнего уровня в возвращенном JSON. Ты
сопоставление с элементом Timezone, а также с Current, который будет содержать
ваши ранее сопоставленные значения.

Теперь, когда вы создали классы моделей, которые можно сопоставить с
JSON, возвращенный из Open Weather API, вы можете перейти к вызову
API, чтобы получить этот JSON.

# Подключение к Open Weather API

Прежде чем вы начнете создавать реализацию для доступа к API, вы
собираются создать интерфейс, чтобы определить, что он должен делать. Это имеет
дополнительное преимущество: когда вы хотите протестировать любой класс, который зависит от
IWeatherForecastService, вы можете предоставить фиктивную реализацию
вместо того, чтобы требовать, чтобы модульные тесты обращались к реальному API. я покрою
почему это плохая идея в главе 14, но здесь простой ответ заключается в том, что вы
иметь ограниченное количество звонков, которые вам разрешено делать бесплатно, и вы
не хочу, чтобы модульные тесты поглощали это пособие.

```Csharp
namespace WidgetBoard.Communications;
public interface IWeatherForecastService
{
 Task<Forecast> GetForecast(double latitude, double
longitude);
}

```

Общий подход к именованию классов, которые взаимодействуют с API, таков:
чтобы добавить суффикс Service, чтобы показать, что он предоставляет услугу пользователю.
Поэтому давайте создадим вашу службу, добавив новый файл класса и вызвав его
WeatherForecastService.cs. Добавьте следующее содержимое:

```Csharp
using System.Text.Json;
namespace WidgetBoard.Communications;
public class WeatherForecastService : IWeatherForecastService
{
 private readonly HttpClient httpClient;
 private const string ApiKey = "ENTER YOUR KEY";
 private const string ServerUrl = "https://api.open
weathermap.org/data/2.5/onecall?";
 public WeatherForecastService(HttpClient httpClient)
 {
 this.httpClient = httpClient;
 }
 public async Task<Forecast> GetForecast(double latitude,
double longitude)
 {
 var response = await httpClient
 .GetAsync($"{ServerUrl}lat={latitude}&lon={longitude}
&units=metric&exclude=minutely,hourly,daily,alerts&
appid={ApiKey}")
 .ConfigureAwait(false);
 response.EnsureSuccessStatusCode();
 var stringContent = await response.Content
 .ReadAsStringAsync()
 .ConfigureAwait(false);
 var options = new JsonSerializerOptions
 {
 PropertyNameCaseInsensitive = true
 };
 return JsonSerializer.Deserialize<Forecast>(string
Content, options);
 }
}
```
Вы добавили изрядную сумму в этот файл класса, поэтому давайте пройдемся по нему шаг за шагом.
шаг за шагом и охватывать то, что он делает.
Во-первых, это поле поддержки ```HttpClient```, которое устанавливается в
конструктор и предоставляется слоем внедрения зависимостей. У вас также есть
константы, представляющие URL-адрес API, а также ваш ключ API, который вы
созданные в предыдущих разделах.
Далее идет основная функциональность метода ```GetForecast```. 
первая строка в этом методе обрабатывает подключение к ```Open Weather API``` и
передавая значения широты, долготы и ключа API. Вы также убедитесь,
установить ```ConfigureAwait(false)```, потому что вам не нужно перезванивать
в начальном вызывающем потоке. Это помогает немного повысить производительность, так как
позволяет избежать ожидания освобождения вызывающего потока.

```Csharp
var response = await httpClient
 .GetAsync($"{ServerUrl}lat={latitude}&lon={longitude}
&units=metric&exclude=minutely,hourly,daily,alerts&appid=
{ApiKey}")
 .ConfigureAwait(false);
```
Затем вы убедитесь, что запрос был успешно обработан
позвонив

```Csharp
response.EnsureSuccessStatusCode();
```
---
Обратите внимание, что вышеприведенное вызовет исключение, если код состояния
получено не 200 (успех в порядке).
---

Затем вы извлекаете содержимое строки из ответа.

```Csharp
var stringContent = await response.Content
 .ReadAsStringAsync()
 .ConfigureAwait(false);
```
Наконец, вы используете NuGet-пакет System.Text.Json, который вы
установлен ранее, чтобы десериализовать содержимое строки в модель
классы, которые вы создали.

```Csharp
var options = new JsonSerializerOptions
{
 PropertyNameCaseInsensitive = true
};

return JsonSerializer.Deserialize<Forecast>(stringContent,
options);

```

Я упоминал ранее, что вы должны были явно согласиться на сопоставление
имена ваших свойств в элементы JSON без учета регистра.
Вы можете видеть из приведенного выше кода, что вы можете сделать это через
использование класса ```JsonSerializerOptions``` и, в частности,
Свойство ```PropertyNameCaseInsensitive```.
Теперь, когда вы создали сервис, вы должны добавить свою погоду
виджет и пользоваться услугой.

# Создание WeatherWidgetView

Чтобы создать виджет, вам нужно добавить новое представление. Добавить
новый .NET MAUI ContentView (XAML) в папку Views и
назовите его ```WeatherWidgetView```. В результате создаются два файла:
```WeatherWidgetView.xaml``` и ```WeatherWidgetView.xaml.cs```. Вам нужно
обновите оба файла.

**WeatherWidgetView.xaml**
```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentView
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.Views.WeatherWidgetView"
 x:DataType="viewmodels:WeatherWidgetViewModel">
 <VerticalStackLayout>
 <Label
 Text="Today"
 FontSize="20"
 VerticalOptions="Center"
 HorizontalOptions="Start"
 TextTransform="Uppercase" />
 <Label
 VerticalOptions="Center"
 HorizontalOptions="Center">
 <Label.FormattedText>
 <FormattedString>
 <Span
 Text="{Binding Temperature,
StringFormat='{0:F1}'}"
 FontSize="60"/>
 <Span
 Text="°C" />
 </FormattedString>
 </Label.FormattedText>
 </Label>
 <Label
 Text="{Binding Weather}"
 FontSize="20"
 VerticalOptions="Center"
 HorizontalOptions="Center" />
 <Image
 Source="{Binding IconUrl}"
 WidthRequest="100"
 HeightRequest="100"/>
 </VerticalStackLayout>
</ContentView>
```
Некоторые из приведенных выше XAML должны показаться знакомыми на основе предыдущего
код, который вы написали. Некоторые биты являются новыми, поэтому давайте рассмотрим их.
```Label.FormattedText``` позволяет вам определять текст различных форматов.
внутри одного элемента управления ```Label```. Это может быть полезно, особенно когда части
текст динамически изменяется по длине и, следовательно, приводит к содержанию
передвигаться. В вашем примере вы добавляете ```Span``` с текстовой привязкой
к вашему свойству ```Temperature``` в модели представления и второй ```Span``` с
символ градусов Цельсия.
Второй новой концепцией является использование элемента управления Image. Привязка
на свойстве Source выглядит относительно просто; однако это
стоит отметить, что .NET MAUI здесь творит чудеса. Ты
привязка строки к свойству. Под капотом .NET MAUI преобразует
строку во что-то, что может напоминать источник изображения. Фактически,
базовый тип называется ImageSource. Кроме того, он проверит ваш
строка, и если она содержит допустимый URL-адрес (например, начинается с https://), то она будет
стремитесь загрузить его как удаленное изображение, а не искать в наборе приложений
скомпилированных ресурсов. .NET MAUI также может обрабатывать кэширование
изображения для вас, чтобы помочь уменьшить количество запросов, отправляемых для загрузки
изображения из удаленного источника. Чтобы использовать эту функцию,
вам нужно предоставить свойство ```UriImageSource``` в вашей модели представления, а не
чем строковое свойство.
Процесс преобразования одного вида в другой называется
Преобразователи типов и могут быть довольно распространены в .NET MAUI. я не буду вдаваться
подробно о том, как они работают, поэтому перейдите на сайт документации Microsoft
по адресу https://learn.microsoft.com/dotnet/api/system.componentmodel.
конвертер типов.

**WeatherWidgetView.xaml.cs**

Также необходимо внести следующие коррективы в
Файл ```WeatherWidgetView.xaml.cs```. Эта часть необходима, потому что вы
не создали общий базовый класс для представлений виджетов. Иногда там
может быть веской причиной для их создания; однако, поскольку вы хотите сохранить
максимально простое визуальное дерево, нет общей визуальной базы
класс для использования.

```Csharp
using WidgetBoard.ViewModels;
namespace WidgetBoard.Views;
public partial class WeatherWidgetView : ContentView,
IWidgetView
{
 public WeatherWidgetView()
 {
 InitializeComponent();
 }
 public IWidgetViewModel WidgetViewModel
 {
 get => BindingContext as IWidgetViewModel;
 set => BindingContext = value;
 }
}
```

Теперь, когда вы создали виджет, вам нужно создать
просмотреть модель, которая будет с ним работать в паре.

# Создание модели WeatherWidgetViewModel

Модель представления, которую необходимо создать для представления связанных с погодой данных, которые могут быть привязаны к пользовательскому интерфейсу, требует некоторой работы, которую вы должны выполнить.
с которыми вы знакомы, и некоторые, с которыми вы не так знакомы. Давайте
переходите к добавлению знакомых элементов, а затем переходите к более новым
концепции. Сначала добавьте новый файл класса в папку ViewModels и назовите его
```WeatherWidgetViewModel.cs```. Исходное содержимое должно быть изменено на
выглядеть следующим образом:

```Csharp
using WidgetBoard.Communications;
namespace WidgetBoard.ViewModels;
public class WeatherWidgetViewModel : BaseViewModel,
IWidgetViewModel
{
 public const string DisplayName = "Weather";
 public int Position { get; set; }
 public string Type => DisplayName;
}
```
Вышеупомянутое должно выглядеть знакомым, так как оно очень похоже на
```ClockWidgetViewModel```, который вы создали ранее в этой книге. Теперь вам нужно
чтобы добавить информацию о погоде.
Сначала добавьте зависимость от созданного вами ```IWeatherForecastService```.
недавно.

```Csharp
private readonly IWeatherForecastService
weatherForecastService;
public WeatherWidgetViewModel(IWeatherForecastService
weatherForecastService)
{
 this.weatherForecastService = weatherForecastService;
 Task.Run(async () => await LoadWeatherForecast());
}
private async Task LoadWeatherForecast()
{
 var forecast = await weatherForecastService.
GetForecast(20.798363, -156.331924);
 Temperature = forecast.Current.Temperature;
 Weather = forecast.Current.Weather.First().Main;
 IconUrl = forecast.Current.Weather.First().IconUrl;
}
```
Внутри вашего конструктора вы храните копию службы, а также
запустить фоновую задачу для получения информации о прогнозе. Довольно часто вы
не стал бы запускать что-то подобное из конструктора; однако,
учитывая, что вы знаете, что ваша модель представления будет создана только тогда, когда она создается
добавленный в пользовательский интерфейс, это вполне приемлемо.
Наконец, вам нужно добавить свойства, к которым ваше представление хочет привязаться.

```Csharp
private string iconUrl;
private double temperature;
private string weather;
public string IconUrl
{
 get => iconUrl;
 set => SetProperty(ref iconUrl, value);
}
public double Temperature
{
 get => temperature;
 set => SetProperty(ref temperature, value);
}
public string Weather
{
 get => weather;
 set => SetProperty(ref weather, value);
}
```
Это все, что вам нужно в модели представления на данный момент. Теперь вы можете зарегистрировать
виджет и подготовьте его к первому тестовому запуску.

# Регистрация вашего виджета

Сначала вам нужно использовать пакет NuGet, чтобы следовать некоторым
рекомендуемые методы регистрации и использования ```HttpClient```
сорт. Идите вперед и добавьте пакет ```Microsoft.Extensions.Http NuGet``` и
затем посмотрите, как его использовать.

Щелкните правой кнопкой мыши решение ```WidgetBoard```.

• Выберите «Управление пакетами NuGet».

• Найдите ```Microsoft.Extensions.Http```.

• Выберите правильный пакет.

• Щелкните Добавить пакет.

Внутри вашего файла ```MauiProgram.cs``` вам нужно добавить следующие строки
в метод ```CreateMauiApp```:

```Csharp
builder.Services.AddHttpClient<WeatherForecastService>();
builder.Services.AddSingleton<IWeatherForecastService,
WeatherForecastService>();
WidgetFactory.RegisterWidget<WeatherWidgetView, WeatherWidgetVi
ewModel>(WeatherWidgetViewModel.DisplayName);
builder.Services.AddTransient<WeatherWidgetView>();
builder.Services.AddTransient<WeatherWidgetViewModel>();
```
Приведенный выше код регистрирует представление вашего виджета и модели представления с помощью
слой внедрения зависимостей, а также регистрирует его в вашей ```WidgetFactory```,
это означает, что его можно создать из вашего наложения виджета добавления.

# Проверка вашего виджета

Если вы запустите свое приложение и добавите виджет погоды, вы увидите
результат на рис. 10-1.

![изображение](https://user-images.githubusercontent.com/26972859/231479651-c8fff206-c623-4c9d-997e-374a20d832c9.png)

Рисунок 10-1. Приложение работает и показывает ваш виджет погоды
рендеринг правильно

Это прекрасно работает, если у вас хорошее сетевое соединение. 
момент, когда у вас медленное соединение или даже нет соединения, вы
обратите внимание, что вещи загружаются не совсем так, как ожидалось. На самом деле, вы, вероятно,
наблюдать аварию. Вы знали, что это может произойти, основываясь на ваших предыдущих
изучение вещей, которые необходимо учитывать при работе с удаленными
данные. Давайте теперь применим некоторые методы для обработки этих сценариев.

# Добавление некоторого состояния

Первое, что вы хотите сделать, это рассмотреть различные возможные состояния
в котором может находиться ваш процесс. Есть три ключевых сценария, которые вам необходимо
обрабатывать и обеспечивать визуальную обратную связь с вашими пользователями по следующим вопросам:

1. Виджет загружает данные.

2. Виджет имеет данные.

3. Виджет столкнулся с проблемой загрузки данных.

Давайте рассмотрим эти три сценария.
Сначала создайте перечисление, которое будет представлять приведенные выше сценарии.

```Csharp
public enum State
{
 None = 0,
 Loading = 1,
 Loaded = 2,
 Error = 3
}
```
Вы также хотите изменить код загрузки в модели представления, чтобы сделать
использование этого нового состояния.

```Csharp
private async Task LoadWeatherForecast()
{
    try
 {
 State = State.Loading;
 var forecast = await weatherForecastService.GetForecast
(20.798363, -156.331924);
 Temperature = forecast.Current.Temperature;
 Weather = forecast.Current.Weather.First().Main;
 IconUrl = forecast.Current.Weather.First().IconUrl;
 State = State.Loaded;
 }
 catch (Exception ex)
 {
 State = State.Error;
 }
}
```
И вам также нужно добавить свойство ```State``` и резервное поле.

```Csharp
private State state;
public State State
{
 get => state;
 set => SetProperty(ref state, value);
}
```
# Преобразование состояния в пользовательский интерфейс

Этот раздел вполне заслуживает более заметного оформления; однако, чтобы позволить
содержание этой книги, я решил показывать только те части, которые основаны на
в контексте тем, которые вы изучаете при создании своего приложения.
Довольно часто в .NET MAUI встречаются сценарии, в которых вы хотите привязать
часть данных в пользовательский интерфейс, но этот тип данных не соответствует желаемому типу в
пользовательский интерфейс. Чтобы не добавлять дополнительные свойства и потенциально добавлять
информацию, связанную с представлением, в свои модели представлений, вы можете использовать
понятие, называемое конвертерами. Преобразователь позволяет определить, как конкретный
тип данных может быть преобразован из своего типа в другой тип. я всегда нахожу
лучший способ рассказать о чем-то подобном — увидеть его в действии, поэтому давайте создадим
конвертер для преобразования из вашего нового перечисления состояний выше в логическое значение
готов к привязке к свойству ```IsVisible``` в вашем представлении.
Добавьте новую папку и назовите ее ```Converters```, а затем добавьте новый класс.
файл и назовите его ```IsEqualToStateConverter.cs```, а затем вы можете добавить
следующее содержание:

```Csharp
using System.Globalization;
using WidgetBoard.ViewModels;
namespace WidgetBoard.Converters;
public class IsEqualToStateConverter : IValueConverter
{
 public State State { get; set; }
 public object Convert(object value, Type targetType, object
parameter, CultureInfo culture)
 {
 if (value is State state)
 {
 return state == State;
 }
 return value;
 }
 public object ConvertBack(object value, Type targetType,
object parameter, CultureInfo culture)
{
 throw new NotImplementedException();
 }
}
```
Интерфейс ```IValueConverter``` позволяет определить, как значение
переданный может быть преобразован. Реализации этого интерфейса предназначены для использования
в привязке с использованием свойства ```Converter```.

# Отображение состояния загрузки

Стоит отметить, что временами данные могут загружаться очень быстро, и действие
показ спиннера может вызвать негативные эмоции, если он мигает слишком часто.
быстро. Конечно, невозможно знать, какие звонки будут длиться дольше.
чем другие, поскольку существует так много факторов, которые могут повлиять на сеть. В
В такие моменты мне нравится следить за тем, чтобы всегда была минимальная сумма
времени, когда вы показываете счетчик, чтобы не было этой странной вспышки
Пользователь.

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentView
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 xmlns:converters="clr-namespace:WidgetBoard.Converters"
 x:Class="WidgetBoard.Views.WeatherWidgetView"
 x:DataType="viewmodels:WeatherWidgetViewModel">
 <ContentView.Resources>
 <converters:IsEqualToStateConverter
 x:Key="IsLoadingConverter"
 State="Loading" />
 </ContentView.Resources>
<VerticalStackLayout>
 <Label
 Text="Today"
 FontSize="20"
 VerticalOptions="Center"
 HorizontalOptions="Start"
 TextTransform="Uppercase" />
 <!-- Loading -->
 <VerticalStackLayout
 IsVisible="{Binding State, Converter={StaticResource
IsLoadingConverter}}">
 <ActivityIndicator
 IsRunning="{Binding State, Converter={Static
Resource IsLoadingConverter}}" />
 <Label
 Text="Loading weather data" />
 </VerticalStackLayout>
 </VerticalStackLayout>
</ContentView>

```

# Отображение загруженного состояния

Чтобы обработать состояние ошибки, вам нужно добавить еще один экземпляр
ваш ```IsEqualToStateConverter```, на этот раз с установленным свойством ```State```
в ```Loaded```.

```xml
<converters:IsEqualToStateConverter
 x:Key="HasLoadedConverter"
 State="Loaded" />
```
Затем вы можете использовать этот конвертер в привязке, чтобы показать/скрыть
следующий пользовательский интерфейс:

```xml
<!-- Loaded -->
<VerticalStackLayout
 IsVisible="{Binding State, Converter={StaticResource
HasLoadedConverter}}">
 <Label
 VerticalOptions="Center"
 HorizontalOptions="Center">
 <Label.FormattedText>
 <FormattedString>
 <Span
 Text="{Binding Temperature, String
Format='{0:F1}'}"
 FontSize="60"/>
 <Span
 Text="°C" />
 </FormattedString>
 </Label.FormattedText>
 </Label>
 <Label
 Text="{Binding Weather}"
 FontSize="20"
 VerticalOptions="Center"
 HorizontalOptions="Center" />
 <Image
 Source="{Binding IconUrl}"
 WidthRequest="100"
 HeightRequest="100"/>
</VerticalStackLayout>
```

# Отображение состояния ошибки

Чтобы обработать состояние ошибки, вам нужно добавить еще один экземпляр вашего
```IsEqualToStateConverter```, на этот раз со свойством ```State```, установленным на ```Error```.

```xml
<converters:IsEqualToStateConverter
 x:Key="HasErrorConverter"
 State="Error" />
```
Затем вы можете использовать этот конвертер в привязке, чтобы показать/скрыть
следующий пользовательский интерфейс:

```xml
<!-- Error -->
<VerticalStackLayout
 IsVisible="{Binding State, Converter={StaticResource HasErrorConverter}}">
 <Label
 Text="Unable to load weather data" />
 <Button
 Text="Retry"
 Command="{Binding LoadWeatherCommand}" />
</VerticalStackLayout>
```
Возможно, вы заметили, что добавили кнопку и привязали ее
команда для модели представления. Вам нужно добавить это в свою модель представления, если
вы хотите скомпилировать и запустить приложение. Цель кнопки состоит в том, чтобы
разрешить пользователю запросить повторную попытку загрузки информации о погоде, если
Отображается состояние ошибки.
Внутри вашего файла ```WeatherWidgetViewModel.cs``` вам нужно сделать
следующее изменение:

```Csharp
public ICommand LoadWeatherCommand { get; }
```
Затем вам нужно обновить конструктор с изменениями, выделенными жирным шрифтом:

```Csharp
public WeatherWidgetViewModel(WeatherForecastService
weatherForecastService)
{
 this.weatherForecastService = weatherForecastService;
 LoadWeatherCommand = new Command(async () => await LoadWeatherForecast());
 Task.Run(async () => await LoadWeatherForecast());
}
```
Это означает, что в случае сбоя загрузки по какой-либо причине пользователь
есть возможность нажать кнопку повтора, и виджет попытается
снова загрузите информацию о погоде. Он будет проходить через добавленные вами состояния, поэтому
пользовательский интерфейс покажет пользователю различные параметры пользовательского интерфейса, когда это произойдет.
Этот тип обработки сбоев считается ручным. Есть способы
автоматически обрабатывать повторные попытки через пакет ```Polly```.

# Упрощение доступа к веб-сервису

В предыдущих разделах было описано, как вы можете напрямую взаимодействовать с веб-сайтом.
обслуживание на самом базовом уровне. Это требует небольшой настройки, но, к счастью, в
ваш сценарий это не было слишком сложно. Некоторые веб-сервисы могут потребовать
гораздо больше настроек или даже вернуть гораздо больше данных.
При создании приложений цель состоит в том, чтобы написать как можно меньше кода.
насколько это возможно, так как это уменьшает объем кода, который вам нужно поддерживать. Этот
заявление не выступает за написание сокращенного кода, который может быть трудным
чтобы человек понял, но вместо этого заявив, что вы хотите сосредоточиться на
детали, которые являются ключевыми для приложения, которое вы создаете, а не
такие вещи, как использование веб-сервиса. Конечно, вы хотите знать, что вы
но необходимость записи базовых битов с помощью ```HttpClient``` может
стать громоздким. К счастью, есть пакеты, которые могут
помочь тебе!

# Готовые библиотеки

Сначала я рекомендую вам выяснить, не является ли поставщик веб-услуг
также предоставляет клиентскую библиотеку, облегчающую использование. Довольно
часто поставщики предоставляют библиотеку, особенно когда есть слой
необходима аутентификация. Официальных клиентских библиотек для Open нет.
API погоды; однако существует ряд пакетов NuGet, которые предоставляют
некоторая поддержка использования API.

# Библиотеки генерации кода

Если клиентская библиотека недоступна, вы можете использовать автоматическое создание
package, чтобы уменьшить количество кода, который вам нужно написать. ремонт это фантастика
пакет для этой цели. Он позволяет определить интерфейс, представляющий
вызов веб-службы, а затем ```Refit``` сделает все остальное.
Так почему я просто не начал здесь? В новом проекте вы, вероятно,
сделать это, но я всегда твердо чувствую, что вам нужно получить понимание
что делают такие пакеты, как ```Refit```, до того, как вы действительно начнете их использовать. Этот
может быть бесценным, когда что-то идет не так, и вам нужно точно отладить
что и почему идет не так!

# Добавление пакета Refit NuGet

Давайте добавим NuGet-пакет ```Refit.HttpClientFactory``` и
затем посмотрите, как его использовать.

• Щелкните правой кнопкой мыши решение ```WidgetBoard```.

• Выберите «Управление пакетами NuGet».

• Найдите ```Refit.HttpClientFactory```.

• Выберите правильный пакет.

• Щелкните Добавить пакет.

Теперь, когда у вас установлен пакет NuGet, вы можете его использовать.
Откройте файл ```IWeatherForecastService.cs``` и сделайте следующее:
модификации выделены жирным шрифтом:

```Csharp
using Refit;
namespace WidgetBoard.Communications;
public interface IWeatherForecastService
{
 [Get("/onecall?lat={latitude}&lon={longitude}&units=metric&
exclude=minutely,hourly,daily,alerts&appid=APIKEY")]
 Task<Forecast> GetForecast(double latitude, double
longitude);
}
}
```
Фантастическая часть приведенного выше кода заключается в том, что вам не нужно писать
реализация. ```Refit``` использует генераторы исходного кода, чтобы сделать это за вас! В
на самом деле это означает, что вы можете удалить свой класс ```WeatherForecastService```, поскольку он не
требуется дольше.
Последнее изменение, которое вам необходимо сделать, это изменить то, как вы
зарегистрируйте ```IWeatherForecastService``` с вашим ```MauiAppBuilder``` в
Файл ```MauiProgram.cs```. Откройте его и внесите следующие изменения.
Сначала добавьте оператор ```using```.

```Csharp
using Refit;
```
Затем замените

```Csharp
builder.Services.AddSingleton<IWeatherForecastService,
WeatherForecastService>();
```
с

```Csharp
builder.Services
 .AddRefitClient<IWeatherForecastService>()
 .ConfigureHttpClient(c => c.BaseAddress = new Uri("https://
api.openweathermap.org/data/2.5"));

```
Эта новая строка кода использует методы расширения ```Refit```, которые
позволяют использовать реализацию ```IWeatherForecastService```
всякий раз, когда вы регистрируете зависимость от этого интерфейса. Это стоит
повторяя, что реализация ```IWeatherForecastService```
автоматически генерируется для вас через пакет ```Refit```. Для дальнейшего
читая об этом пакете, я полностью рекомендую их веб-сайт по адресу
https://reactiveui.github.io/refit/.

# Дальнейшее чтение

Вы добавили некоторые сложности в ваше приложение, чтобы
обрабатывать сценарий, когда доступ к веб-сервису не загружается должным образом.
Есть две действительно замечательные библиотеки, которые действительно могут помочь уменьшить
количество кода, которое вам нужно написать вокруг этих частей.

# Polly

Чтобы процитировать раздел about в репозитории ```GitHub```,
```Polly``` — это библиотека устойчивости .NET и обработки временных сбоев.
что позволяет разработчикам выражать политики, такие как повторная попытка, схема
```Breaker```, ```Timeout```, ```Bulkhead Isolation``` и ```Fallback``` плавно и потокобезопасно.
Polly действительно может помочь сократить объем написания сложного кода, связанного с ошибкой.
сценарии доступа к веб-сервису. Я настоятельно рекомендую ознакомиться с
Репозиторий GitHub по адресу https://github.com/App-vNext/Polly.

# StateContainer из CommunityToolkit.Maui

Вам пришлось встроить преобразователи и применить привязки ```IsVisible``` для управления
какое представление отображается, когда ваш виджет находится в определенном состоянии. 
```StateContainer``` уменьшает эти накладные расходы, поэтому вам «просто» нужно определить
состояния и представления для этих состояний.
Если вы любите писать меньше кода, я рекомендую ознакомиться с
Документация Microsoft на https://learn.microsoft.com/dotnet/
набор инструментов сообщества/maui/layouts/statecontainer.

# Краткое содержание

В этой главе вы

• Узнал об удаленных данных

• Узнал, как вы можете взаимодействовать с ним

• Рассмотрены общие соображения

• Посмотрел конкретный пример с ```Open Weather API```

• Создал собственную реализацию для использования Open
API погоды

• Рассмотрено, как использовать возвращенные данные

• Обсудили сценарии, в которых что-то может пойти не так

• Предоставленные реализации для обработки этих сценариев

• Посмотрели, как можно упростить
реализация с переоснащением

• Добавлено в ваш виджет погоды

В следующей главе вы будете

• Узнайте о разрешениях на различных платформах и
как их запросить.

• Узнайте, как использовать API геолокации.

• Узнайте, как написать свой собственный
взаимодействие при необходимости.

• Узнайте, как настроить пользовательский интерфейс в зависимости от платформы на
котором запущено ваше приложение.

• Научитесь настраивать пользовательский интерфейс с помощью обработчика.
архитектура.

# Исходный код

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introducing-MAUI/tree/
main/ch10.

# Дополнительное задание

Есть так много возможностей для доступа к удаленным данным в вашем
приложение! Вот несколько дополнительных виджетов, которые я хотел бы, чтобы вы рассмотрели
создание

# Виджет TODO

Пример приложения для создания руководств — это приложение TODO.
Я хотел бы, чтобы вы расширили эту идею и добавили ```TodoWidget``` в свой
приложение. Для этого можно использовать несколько API TODO.
У вас есть любимый сервис TODO, которым вы пользуетесь? лично мне нравится
Вариант Microsoft TODO. Есть неплохая документация по
Страницы Microsoft, которые помогут вам начать работу: https://learn.microsoft.com/graph/todo-concept-overview

# Виджет Цитата дня

Я знаю, что мне определенно нравится вдохновляться цитатой, которая приносит хорошее самочувствие. Почему бы и нет
вы планируете создать виджет, который будет обновляться ежедневно и показывать цитату из
день?
API They Said So Quotes предлагает хороший API для выполнения именно этой задачи.
с документацией, размещенной по адресу https://quotes.rest/.
Другая концепция, которую вам нужно будет рассмотреть, — это то, как вызвать
Класс планировщика для запуска обновления в полночь.

# NASA Space Image of the Day Widget

Мне нравятся некоторые изображения, полученные от НАСА. Это так здорово иметь возможность
заглянуть в просторы космоса! Довольно удобно, у них есть приличный набор
API, которые позволяют создавать виджеты и демонстрировать эти изображения! 
документация на веб-сайте НАСА действительно великолепна и должна быть в состоянии
проведет вас через процесс доступа к нужным вам данным. НАСА
Документацию по API можно найти по адресу https://api.nasa.gov/.
Мне действительно не терпится увидеть эти виджеты в действии!


































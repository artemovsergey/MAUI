# ГЛАВА 11

# Получение конкретики

В этой главе вы узнаете о ```.NET MAUI Essentials``` и о том, как
он позволяет вам получать доступ к API-интерфейсам для конкретных платформ, не беспокоясь
о любых сложностях, связанных с платформой. Два конкретных примера
запрашивают разрешения на каждой платформе и получают доступ к
информация о геолокации устройства. Вы узнаете, что требуется, если вы
действительно нужно взаимодействовать с API для конкретных платформ, которые не были
абстрагировано для вас. Наконец, вы познакомитесь с несколькими методами, концепциями,
и архитектуры, которые позволяют вам настроить пользовательский интерфейс и поведение вашего
приложений в зависимости от платформ, на которых они работают.

# Основы .NET MAUI

В предыдущей главе вы создали виджет погоды. ты не закончил
работа, тем не менее, поскольку в настоящее время она загружает только погоду для Мауи, Гавайи.
Не знаю, как вам, а мне не посчастливилось там жить! В этом
раздел, вы узнаете, каково текущее местоположение устройства с точки зрения
долготу и широту, и вы затем отправите эту информацию на
Open Weather API для гораздо более точной сводки погоды
текущее местоположение пользователя.
Для этого необходимо понимание двух ключевых
понятия: система разрешений каждой операционной системы и как
получить доступ к API, специфичным для GPS-координат. К счастью, в .NET MAUI есть
вы рассмотрели оба сценария, но вам нужно знать, как они
работа и любые различия, зависящие от платформы. Давайте посмотрим на каждый, чтобы получить
лучшее понимание.

# Разрешения

Общая тема, которую я обсуждаю в этой книге, — это то, как .NET MAUI
делает много тяжелой работы, когда дело доходит до работы с каждым поддерживаемым
Платформа. Это продолжается с разрешениями, потому что .NET MAUI абстрагирует
большое количество разрешений.

**Замечание:**
Стоит отметить, что каждая операционная система отличается. Не все
требуют разрешений для определенных функций. Обратитесь в Microsoft
документация о том, что поддерживает .NET MAUI и что требуется
для каждой платформы на  https://learn.microsoft.com/dotnet/
maui/platform-integration/appmodel/permissionsavailable-permissions.

Существует два ключевых метода, позволяющих взаимодействовать с
система разрешений в .NET MAUI.

# Проверка статуса разрешения

Чтобы проверить, дал ли пользователь уже разрешение на
вашего приложения, вы можете использовать метод ```CheckStatusAsync``` в классе.
Для виджета «Погода» вам необходим доступ к геолокации устройства.
информация. У вас есть два варианта разрешения на использование:

• ```LocationWhenInUse```: позволяет приложению
для доступа к информации о геолокации, когда приложение
открытые на переднем плане.

• ```LocationAlways```: Это позволяет приложению также
получить доступ к информации о геолокации, даже если приложение
является фоновым. Это может быть особенно полезно для
приложения для отслеживания упражнений, которые должны отслеживать
движение пользователя.
Вам нужна только опция ```LocationWhenInUse``` для вашего приложения.

```Csharp
PermissionStatus status = await Permissions.
CheckStatusAsync<Permissions.LocationWhenInUse>();
```

Рекомендуется проверить статус разрешения
прежде чем запрашивать его, чтобы получить представление о том, имеет ли пользователь
спрашивали раньше. В iOS вам разрешено спрашивать только один раз, а затем
вам необходимо предложить пользователю перейти в приложение «Настройки» и включить
разрешения, если они захотят изменить свое мнение. К сожалению, ```Android``` предоставляет
другой подход и вернет статус ```Denied```, даже если пользователь
не было предложено ранее. В этом случае вам рекомендуется
вызвать ```ShouldShowRationale```, чтобы проверить, действительно ли пользователь
подсказал.
Возможные значения для ```PermissionStatus``` следующие:
• Неизвестно: разрешение находится в неизвестном состоянии или включено.
iOS пользователю ни разу не было предложено.
• Отклонено: пользователь отклонил запрос на разрешение.
• Отключено: функция отключена на устройстве.
• Предоставлено: Пользователь предоставил разрешение или
автоматически предоставляется.
• Ограничено: в состоянии с ограничениями.

# Запрос разрешения

Как только вы подтвердите, что пользователю не было предложено
запрос разрешения, вы можете перейти к их запросу с помощью
Метод ```Permissions.RequestAsync``` вместе с конкретным разрешением на
запрос. В вашем примере это будет разрешение ```LocationWhenInUse```.
Статус PermissionStatus = ожидание разрешений.
```RequestAsync<Permissions.LocationWhenInUse>()```;
Стоит отметить, что метод RequestAsync нужно запускать на
основной поток или поток пользовательского интерфейса. Это необходимо, потому что это может привести к представлению
встроенный системный пользовательский интерфейс, чтобы спросить пользователя, хотят ли они дать
разрешение. Поэтому всякий раз, когда вы вызываете ```Permissions.RequestAsync```, вы
должен убедиться, что ваш код уже запущен в основном потоке с
```MainThread.IsMainThread```, или вы можете отправить в основной
поток с помощью метода ```MainThread.InvokeOnMainThreadAsync```.

**Замечание:**
Лучшей практикой считается только запрашивать разрешение у пользователя.
использовать определенную функцию при первой попытке использовать эту функцию. Этот
помогает предоставить пользователю контекст относительно того, почему разрешение
запрашивается. Вы также можете обнаружить, что другая платформа
провайдеры (например, Apple, Google и Microsoft) имеют разные правила, которые они
применять при рассмотрении и утверждении заявок, которые вы отправляете
их магазины. Для этого я рекомендую работать с самыми строгими
правила, чтобы избавить себя от боли и усилий.

# Обработка разрешений в вашем приложении

Следующий раздел кода рекомендован Microsoft
сайт документации по адресу https://learn.microsoft.com/dotnet/maui/
platform-integration/appmodel/permissions?#example. Это было
включено и оставлено без изменений, так как это помогает действительно подчеркнуть различия
между платформами.
Сначала создайте новую папку и класс для этого нового фрагмента.
функциональность. Вызовите папку Службы. Добавьте новый файл интерфейса и назовите его
```ILocationService.cs``` в папке ```Services```. Содержание этого нового
интерфейс должен быть обновлен до следующего

```Csharp
namespace WidgetBoard.Services;
public interface ILocationService
{
 Task<Location> GetLocationAsync();
}
```
Это дает определение того, что такое реализация службы определения местоположения.
предоставит: асинхронный метод, который в конечном итоге вернет
Объект местоположения.
Далее создайте реализацию. Добавьте новый файл класса под
Папка ```Services``` и назовите ее ```LocationService.cs```. Изменить начальный
содержание к следующему:

```Csharp
namespace WidgetBoard.Services;
public interface ILocationService
{
 Task<Location> GetLocationAsync();
}
```
Теперь, когда у вас есть пустой класс, вы можете добавить метод для обработки
запросы разрешений готовы к использованию.

```Csharp
private async Task<PermissionStatus>
CheckAndRequestLocationPermission()
{
 PermissionStatus status = await Permissions.
CheckStatusAsync<Permissions.LocationWhenInUse>();
 if (status == PermissionStatus.Granted)
 {
 return status;
 }
 if (status == PermissionStatus.Denied && DeviceInfo.
Platform == DevicePlatform.iOS)
 {
 // Prompt the user to turn on in settings
 // On iOS once a permission has been denied it may not
be requested again from the application
 return status;
 }
 if (Permissions.ShouldShowRationale<Permissions.
LocationWhenInUse>())
 {
 // Prompt the user with additional information as to
why the permission is needed
 }
 status = await Permissions.RequestAsync<Permissions.
LocationWhenInUse>();
 return status;
}
```
Теперь, когда вы добавили возможность запрашивать разрешение пользователя на
использовать API геолокации на устройстве, вы можете приступить к его использованию.

# Использование API геолокации

.NET MAUI предоставляет возможность доступа к API геолокации каждой платформы.
чтобы получить долготу и широту, представляющие, где в
мире, где в данный момент находится устройство, на котором запущено приложение. Полная информация
о том, что предоставляет API, можно узнать по адресу https://learn.microsoft.com/
dotnet/maui/platform-integration/device/geolocation.

# Регистрация службы геолокации

Откройте файл ```MauiProgram.cs``` и пропишите геолокацию
реализацию, чтобы вы могли использовать ее через уровень внедрения зависимостей.
Вам нужно добавить следующую строку в метод ```CreateMauiApp```:

```Csharp
builder.Services.AddSingleton(Geolocation.Default);
```

# Использование службы геолокации

Теперь это означает, что вы можете добавить зависимость от ```IGeolocation```.
интерфейс и везде, где .NET MAUI предоставляет вам экземпляр. Давайте
используйте реализацию ```IGeolocation``` в файле ```LocationService.cs```.
Есть несколько модификаций, которые вам нужно сделать, поэтому я пройдусь по ним.
каждый.
Добавьте поле для реализации ```IGeolocation``` в корень
класс.

```Csharp
private readonly IGeolocation geolocation;
```
Assign the IGeolocation implementation in the constructor.

```Csharp
public LocationService(IGeolocation geolocation)
{
  this.geolocation = geolocation;
}
```
Provide the method to return a Location object.

```Csharp
public async Task<Location> GetLocationAsync()
{
 return await MainThread.InvokeOnMainThreadAsync(async () =>
 {
 var status = await CheckAndRequestLocationPermission();
 if (status != PermissionStatus.Granted)
 {
 return null;
 }
 return await this.geolocation.GetLocationAsync();
 });
}
```

Эта реализация сначала гарантирует, что вы работаете на основном
поток, необходимый для доступа на основе местоположения. Затем он вызывает ваш
метод обработки разрешений и, если у приложения есть разрешение, оно вызывает метод
```IGeolocation``` и возвращает результирующий объект ```Location```.
Теперь вы готовы использовать ```LocationService```.

# Регистрация службы определения местоположения

Откройте файл ```MauiProgram.cs``` и зарегистрируйте ```LocationService```.
реализацию, чтобы вы могли использовать ее через уровень внедрения зависимостей.
Вам нужно добавить следующую строку в метод ```CreateMauiApp```:

```Csharp
builder.Services.AddSingleton<ILocationService,
LocationService>();
```

# Использование ILocationService

Давайте воспользуемся реализацией ILocationService в вашем
Файл WeatherWidgetViewModel.cs. Есть несколько модификаций, которые вам нужны
сделать, поэтому я пройдусь по каждому
Добавьте поле для реализации ILocationService в корень
класс.

```Csharp
private readonly ILocationService locationService;

```
Назначьте реализацию ```ILocationService``` в конструкторе;
изменения выделены жирным шрифтом.

```Csharp
public WeatherWidgetViewModel(
 IWeatherForecastService weatherForecastService,
 ILocationService locationService)
{
 this.weatherForecastService = weatherForecastService;
 this.locationService = locationService;
 LoadWeatherCommand = new Command(async () => await
LoadWeatherForecast());
}
```
Измените перечисление ```State```, включив в него новое значение, чтобы вы могли
справиться, когда что-то пойдет не так с доступом к разрешению. Добавить
Значение ```PermissionError```, как показано ниже жирным шрифтом.

```Csharp
public enum State
{
 None = 0,
 Loading = 1,
 Loaded = 2,
 Error = 3,
 PermissionError = 4
}
```
Измените метод ```LoadWeatherForecast```, чтобы он вызывал новый
Реализация ```ILocationService``` для определения местоположения устройства.
местоположение, а затем использовать его для вызова ```Open Weather API```, чтобы узнать
погода в месте нахождения устройства.

```Csharp
private async Task LoadWeatherForecast()
{
 State = State.Loading;
 try
 {
 var location = await this.locationService.
GetLocationAsync();
 if (location is null)
 {
 State = State.PermissionError;
 return;
 }
 var forecast = await weatherForecastService.
GetForecast(location.Latitude, location.Longitude);
 Temperature = forecast.Current.Temperature;
 Weather = forecast.Current.Weather.First().Main;
 IconUrl = forecast.Current.Weather.First().IconUrl;
 State = State.Loaded;
 }
 catch (Exception ex)
 {
 State = State.Error;
 }
}
```
Вы внесли здесь несколько изменений, так что давайте разберем их.
Во-первых, вы вызываете ```locationService```, чтобы получить местоположение устройства.
Если он возвращает null, это означает, что приложение не имеет разрешения и
вы устанавливаете состояние в ```PermissionError```.
Если у вас есть разрешение, вы передаете текущее местоположение устройства в
Метод ```WeatherForecastService.GetForecast```.

# Отображение ошибок прав доступа для вашего пользователя

Вы добавили новое значение состояния, а также присвоили его в своем представлении.
модель, когда вы либо не можете получить параметр разрешения, либо пользователь
запретил доступ к функции ```LocationWhenInUse```. Теперь вы можете
добавьте поддержку в свой пользовательский интерфейс, чтобы ответить на это значение и показать что-то
соответствующий пользователю. Откройте файл ```WeatherWidgetView.xaml``` и сделайте
следующие модификации.
Добавьте экземпляр конвертера в тег ```<ContentView.Resources>```

```xml
<converters:IsEqualToStateConverter
 x:Key="HasPermissionErrorConverter"
 State="PermissionError" />
```
Затем вы можете добавить раздел, который будет отображаться, когда состояние
свойство равно ```PermissionError```. Вы должны добавить это в
Файл ```WeatherWidgetView.xaml``` после следующего раздела:

```xml
<!-- Error -->
<VerticalStackLayout
 IsVisible="{Binding State,
Converter={StaticResource HasErrorConverter}}">
 ...
</VerticalStackLayout>
```
Раздел, который вы хотите добавить, выглядит следующим образом:

```xml
<!-- PermissionError -->
<VerticalStackLayout
 IsVisible="{Binding State, Converter={StaticResource
HasPermissionErrorConverter}}">
 <Label
 Text="Unable to retrieve location data" />
 <Button
 Text="Retry"
 Command="{Binding LoadWeatherCommand}" />
</VerticalStackLayout>
```
Теперь, когда вы добавили все необходимые фрагменты кода для вызова
API разрешений и геолокации вам необходимо настроить каждый из ваших
поддерживаемые платформы, чтобы включить разрешение местоположения.

# Настройка компонентов для конкретной платформы

Именно здесь .NET MAUI перестает держать вас за руку и требует от вас
выполнить некоторую работу в папках для конкретной платформы. Многие API, которые
предоставляется .NET MAUI, как подробно описано в этом разделе документации
сайте https://learn.microsoft.com/dotnet/maui/platformintegration/, может потребоваться определенный уровень настройки для конкретной платформы. Это зависит от платформы. Например, для тактильной поддержки,
только Android требует некоторой настройки, тогда как для ```Geolocation API``` все
платформы требуют некоторой настройки.
К счастью, .NET MAUI предоставляет полезные исключения и сообщения об ошибках.
если вы пропустите какие-либо настройки для конкретной платформы, и они обычно указывают
действие, необходимое для устранения проблемы. Такие темы делают обязательным
что вы действительно тестируете свое приложение на каждой из платформ, которые вы хотите
поддержки, чтобы убедиться, что он ведет себя так, как ожидалось. Давайте настроим каждую платформу, чтобы ваше приложение могло полностью поддерживать доступ
текущее местоположение устройств.

# Андроид

Android требует настройки нескольких разрешений и функций в
чтобы ваше приложение использовало разрешение ```LocationWhenInUse```. Ты
можно настроить их внутри ```Platforms/Android/MainApplication.cs```
файл, поэтому откройте его и сделайте следующие добавления жирным шрифтом:

```Csharp
using Android.App;
using Android.Runtime;
[assembly: UsesPermission(Android.Manifest.Permission.
AccessCoarseLocation)]
[assembly: UsesPermission(Android.Manifest.Permission.
AccessFineLocation)]
[assembly: UsesFeature("android.hardware.location",
Required = false)]
[assembly: UsesFeature("android.hardware.location.gps",
Required = false)]
[assembly: UsesFeature("android.hardware.location.network",
Required = false)]
namespace WidgetBoard;

```
Обратите внимание, что использование ключевого слова сборки требует, чтобы атрибуты
применяются на уровне сборки, а не на уровне класса, как текущий
Использование атрибута [Application]. Для получения дополнительной информации о том, как начать работу
с геолокацией см. документацию Microsoft по адресу t https://
learn.microsoft.com/dotnet/maui/platform-integration/device/
geolocation?tabs=android-get-started.

Если вы сейчас запустите приложение на Android, то увидите, что первое
когда вы добавляете виджет погоды на доску, система представит
следующее всплывающее окно для пользователя с просьбой разрешить разрешение для вашего
приложение для использования функции определения местоположения. На рис. 11-1 показан результат
запуск вашего приложения на Android.

![изображение](https://user-images.githubusercontent.com/26972859/231486435-b082c9f9-79af-4c58-bc42-eb815a1cb535.png)

Рисунок 11-1. Приложение, работающее на Android, показывает
запрос разрешения при первом добавлении виджета погоды на доску

# iOS/Мак

Apple требует, чтобы вы указали причину, по которой ваше приложение хочет использовать
функцию геолокации в процессе определения того, что ваше приложение
использует функцию. Вы можете настроить это, изменив ```Platforms/iOS/```
Файлы ```Info.plist``` и ```Platforms/MacCatalyst/Info.plist``` для iOS и
Mac Catalyst соответственно. Оба файла требуют одинаковых изменений, так что давайте откроем
их и добавьте следующие строки. Обратите внимание, что я предпочитаю редактировать файлы
внутри кода Visual Studio, поскольку я считаю, что это обеспечивает лучший опыт редактирования.
В Visual Studio есть встроенный редактор, но лично я предпочитаю редактировать
XML напрямую. Добавьте следующие строки внутрь элемента ```<dict>```:

```xml
<key>NSLocationWhenInUseUsageDescription</key>
<string>In order to provide accurate weather information.</string> 
```
Для получения дополнительной информации о том, как начать работу с геолокацией, см.
в документации Microsoft по адресу https://learn.microsoft.com/
dotnet/maui/platform-integration/device/geolocation?tabs=ios -
get-started
Если вы сейчас запустите приложение на iOS и macOS, то увидите, что
при первом добавлении виджета погоды на доску система представит
следующее всплывающее окно для пользователя с просьбой предоставить разрешение для вашего
приложение для использования функции определения местоположения. На рис. 11-2 показан результат
запуск приложения на iOS.

![изображение](https://user-images.githubusercontent.com/26972859/231486775-9169a4ff-9726-4bd8-bd2b-0a3065aff5c9.png)

Рисунок 11-2. Приложение, работающее на iOS (слева) и macOS (справа)
отображение запроса на разрешение при первом добавлении виджета погоды
к доске

# Windows

Приложения ```Windows``` имеют концепцию возможностей, и
разработчики объявляют, какие возможности требуются в их приложениях.
Чтобы сделать это для вашего приложения, вам необходимо изменить файл ```Platforms/Windows/Package.appxmanifest```. Обратите внимание, что я выбираю
редактировать файлы внутри кода Visual Studio, так как я считаю, что это обеспечивает лучшее редактирование
опыт. Добавьте следующую строку внутрь элемента ```<Capabilities>```:

```xml
<DeviceCapability Name="location"/>
```
Для получения дополнительной информации о том, как начать работу с геолокацией, см.
документацию Microsoft по адресу https://learn.microsoft.com/dotnet/
maui/platform-integration/device/geolocation?tabs=windowsget-started.
Если вы сейчас запустите приложение в Windows, вы не увидите разрешение
всплывающее окно запроса. На рис. 11-3 показан результат запуска приложения на
Окна.

![изображение](https://user-images.githubusercontent.com/26972859/231487071-a404f50a-2c09-45be-bfce-7e71c026bfd8.png)

Рисунок 11-3. Приложение, работающее в ```Windows```, показывает
запрос разрешения при первом добавлении виджета погоды на доску
  
# Доступ к API для конкретной платформы  
  
Несмотря на то, что .NET MAUI предоставляет вам множество функциональных возможностей,
box, могут быть случаи, когда вам нужно написать собственное взаимодействие с
уровень, специфичный для платформы, для достижения ваших целей. Любая функциональность
может быть достигнуто на конкретной платформе также может быть достигнуто в рамках .NET
App MAUI. Вам просто, возможно, придется сделать тяжелую работу самостоятельно. Если
ваша реализация считается достаточно полезной для других разработчиков, вы
следует предложить изменения команде .NET MAUI.
Есть две основные концепции, которые вы можете использовать при создании кода для конкретной платформы в .NET MAUI. Давайте рассмотрим каждый из них через
простой пример создания ```LocationService```, который возвращает долготу
и широта штаб-квартиры для каждого поставщика платформы (например, Google,
Apple и Microsoft).  
  
# Платформо-зависимый код с директивами компилятора
  
Скорее всего, вы столкнетесь с использованием директивы компилятора ```#if```.
при работе с приложением .NET MAUI. Я не большой их поклонник, но я
признайте, что в некоторых сценариях они действительно приносят пользу.  
  
```Csharp
namespace WidgetBoard.Services;
public class PlatformLocationService : ILocationService
{
 public Task<Location> GetLocationAsync()
 {
 Location location;
#if ANDROID
 location = new Location(37.419857, -122.078827);
#elif WINDOWS
 location = new Location(47.639722, -122.128333);
#else
 location = new Location(37.334722, -122.008889);
#endif
 return Task.FromResult(location);
 }
}
```
Приведенный выше код будет скомпилирован различными способами в зависимости от цели.
Платформа. Полученный скомпилированный код для платформы Android выглядит так:
следует:
  
```Csharp
namespace WidgetBoard.Services;
public class PlatformLocationService : ILocationService
{
 public Task<Location> GetLocationAsync()
 {
 Location location;
 location = new Location(37.419857, -122.078827);
 return Task.FromResult(location);
 }
}
```

Это означает, что будет скомпилирован только код, специфичный для платформы.
и отправлены на эту платформу.
Этот подход может хорошо работать в этом сценарии, но как только вам понадобится
использовать несколько классов или других платформо-зависимых библиотек, код будет
очень быстро становятся сложными. В более сложных случаях можно использовать
папки для конкретной платформы, созданные в вашем проекте для вас.  
  
# Платформо-зависимый код в папках платформы  
  
Я кратко рассмотрел эти папки в главе 2. На каждой платформе есть папка и
файлы внутри каждой папки (например, ```/Platforms/Android/```) будут скомпилированы только
для этой платформы, когда вы ориентируетесь на нее. Для создания такого же
```PlatformLocationService``` из предыдущего раздела, вам сначала нужно
создайте разделяемый класс в папке ```Services``` со следующим содержимым:  
  
```Csharp
namespace WidgetBoard.Services;
public partial class MultiPlatformLocationService :
ILocationService
{
} 
```

Приведенный выше код не будет компилироваться, потому что вы не реализовали
```ILocationService```. Это ожидается до тех пор, пока вы не добавите свой специфичный для платформы
реализации, так что не волнуйтесь. Вы добавляете частичное ключевое слово, потому что
это только частичная реализация. Файлы и классы для конкретных платформ
вы добавите в ближайшее время, завершит эту частичную реализацию.
Затем вам нужно создать свою платформу Android
выполнение. Для этого вы добавляете новый файл класса в
```/Platforms/Android/``` и назовите ее ```PlatformLocationService.cs```,
так же, как тот, что выше. Вы хотите изменить его содержимое на следующее:  
  
```Csharp
namespace WidgetBoard.Services;
public partial class MultiPlatformLocationService
{
 public Task<Location> GetLocationAsync()
 {
 return Task.FromResult(new Location(37.419857,
-122.078827));
 }
}
```
Этот класс будет скомпилирован только тогда, когда платформа Android
target, и поэтому вы получаете скомпилированный вывод, очень похожий на тот,
в разделе «Код для конкретной платформы с директивами компилятора». 
ключевое отличие в том, что вам не нужно добавлять какие-либо из этих неприятных #if
директивы.  
  
**Замечание:**
При построении специфичных для платформы реализаций таким образом
пространство имен ваших разделяемых классов должно совпадать! В противном случае
компилятор не сможет построить один класс.  

  
# Переопределение пользовательского интерфейса для конкретной платформы
 
Одна фундаментальная часть .NET MAUI заключается в том, что он использует
базовые элементы управления платформой для обработки рендеринга наших приложений.
Это приведет к тому, что наши приложения будут выглядеть по-разному на каждом из
платформы. В большинстве сценариев это считается хорошей вещью
потому что приложение соответствует внешнему виду платформы.
Однако иногда вам потребуется переопределить некоторые специфичные для платформы
рендеринга или даже просто для настройки рендеринга элементов управления в вашем приложении на
конкретная платформа.  
  
# На платформе  
  
Типичным примером необходимости изменения свойств элемента управления является
размер текста или расстояние вокруг элементов управления (поля или отступы). я всегда
обнаружите, что последние штрихи делают приложение действительно гладким
и полировка может привести к необходимости настройки таких деталей для каждой платформы.
Есть два основных способа добиться этого, и они зависят от того,
вы являетесь разработчиком пользовательского интерфейса, ориентированным на XAML или C#. Давайте рассмотрим оба с
пример.  
  
# Расширение разметки OnPlatform  
  
XAML, как уже упоминалось, не так многофункционален с точки зрения того, что можно написать.
и достигнуто. Поэтому дополнительный функционал предоставляется .NET
MAUI для преодоления этих ограничений. Одним из таких примеров является ```OnPlatform```.
расширение разметки. Расширения разметки XAML помогают повысить мощность и
гибкость XAML, позволяя устанавливать атрибуты элементов из множества
источников.
Вы можете решить, что в вашем файле ```ClockWidgetView.xaml``` ```FontSize```
свойство слишком велико для iOS и Android и решили изменить его только для
эти платформы. Давайте посмотрим на код и посмотрим, как вы можете изменить
свойство, основанное на платформе, на которой работает приложение.
  
```xml
<?xml version="1.0" encoding="utf-8" ?>
<Label
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.Views.ClockWidgetView"
 FontSize="60"
 VerticalOptions="Center"
 HorizontalOptions="Center"
 x:DataType="viewmodels:ClockWidgetViewModel"
 Text="{Binding Time}">
 <Label.BindingContext>
 <viewmodels:ClockWidgetViewModel />
 </Label.BindingContext>
</Label>
```
Приведенный выше код показывает, что для свойства ```FontSize``` в настоящее время установлено значение
значение 60. С помощью расширения разметки OnPlatform вы можете изменить это
значение в зависимости от платформы, на которой работает приложение. Следующее
пример кода показывает, как вы можете сохранить значение по умолчанию 60, а затем
переопределить для платформ, которые вы хотите:  

```xml
FontSize="{OnPlatform Default=60, Android=25, iOS=30} 
```
В приведенном выше примере кода указано, что все платформы по умолчанию будут использовать
```FontSize``` 60, если приложение не работает на Android, и значение
будет использоваться 25 или если приложение работает на iOS и значение 30 будет
использоваться.
  
# Условные операторы  
  
Если вы создали свой пользовательский интерфейс на C# или хотели хотя бы изменить ```FontSize```
свойства элемента управления ```Label``` аналогичным образом вы можете написать следующее
условный оператор С#:  
  
```Csharp
public ClockWidgetView()
{
 if (DeviceInfo.Platform == DevicePlatform.Android)
 {
 FontSize = 25;
 }
 else if (DeviceInfo.Platform == DevicePlatform.iOS)
 {
 FontSize = 30;
 }
 else
 {
 FontSize = 60;
 }
}
```
Для получения дополнительной информации об использовании расширения разметки ```OnPlatform```
и другие возможные расширения разметки, которые позволяют настраивать
вашего приложения, обратитесь к документации Microsoft по адресу
https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/
consume#onplatform-markup-extension.
Будут времена, когда просто переопределить значения, подобные этому, недостаточно.
Для более сложных сценариев необходимо рассмотреть архитектуру, которая
совершенно новый для .NET MAUI, и это архитектура обработчика.  
  
# Обработчики

Обработчики — это область, в которой .NET MAUI действительно сияет! Если у вас есть
исходить из фона ```Xamarin.Forms```, вы оцените боль
которые принесли пользовательские рендереры. Если у вас нет ```Xamarin.Forms```
опыт, вам очень повезло! Я не буду слишком углубляться в детали
старого подхода, так как это книга о .NET MAUI, а не о прошлом;
однако я чувствую, что стоит поговорить о старых проблемах и о том, как они
были преодолены новой архитектурой обработчика.
Как в ```Xamarin.Forms```, так и в .NET MAUI мы преимущественно создаем
пользовательские интерфейсы с абстрактными элементами управления: элементы управления, определенные в Microsoft
пространство имен, а не конкретно какие-либо элементы управления платформой. Эти элементы управления
в конечном итоге должны быть сопоставлены с уровнем, специфичным для платформы. в
В дни ```Xamarin.Forms``` у вас будет собственный модуль визуализации. Рендерер
будет нести ответственность за знание абстрактного управления, а также
специфичные для платформы элементы управления и сопоставления значений свойств и обработчиков событий
и такое между ними двумя. Это считается сильно связанной конструкцией,
это означает, что становится действительно довольно сложно улучшить элементы управления и
их рендеринг. Если вы хотите переопределить небольшое количество поведения,
вам придется реализовать полный рендерер, отвечающий за сопоставление всех
свойства/события. Это было очень больно!  
В .NET MAUI эта концепция рендереров полностью заменена.
с обработчиками. Эта новая архитектура обеспечивает несколько дополнительных уровней между
абстрактные элементы управления в пространстве имен .NET MAUI и базовые
специфические для платформы элементы управления, отображаемые в наших приложениях. Это
считается гораздо более слабо связанным, в основном из-за того, что каждый
будет реализовывать ряд интерфейсов, и это функция обработчика.
ответственность за взаимодействие с интерфейсом, а не за конкретный элемент управления.
Это имеет много преимуществ, в том числе тот факт, что несколько элементов управления могут
реализовать один и тот же интерфейс и в конечном итоге полагаться на один и тот же единый
обработчик. Он также предоставляет возможность определять меньшие фрагменты общих
функциональность и, как вы все знаете, меньшие классы и файлы намного
легче читать, следовать и, в конечном счете, поддерживать. Рисунок 11-4 показывает, как
абстрактный класс ```Button``` в .NET MAUI сопоставляется с конкретными элементами управления на
каждой платформы.  
  
![изображение](https://user-images.githubusercontent.com/26972859/231488966-8cfc6c41-57cb-4671-96cd-82085ebe13d1.png)

Рисунок 11-4. Архитектура обработчика в .NET MAUI  
  
Если вы хотите создать новый элемент управления, который должен сопоставляться с реализациями для конкретных платформ, вам следует следовать шаблону, показанному на рис.
Рисунок 11-4. Например, если вы сделали свой ```FixedWidgetBoard``` элементом управления
таким образом вы также создадите интерфейс ```IFixedWidgetBoard```.
а затем ```FixedWidgetBoardHandler```, а затем карту из виртуального представления
через вид на платформу. Вы не использовали этот подход в своем сценарии
потому что пользы не было. На самом деле, это привело бы к большему количеству кода, потому что  
вам нужно будет сопоставить каждую платформу по отдельности. Эта концепция может
звучит так, как будто это всегда будет вызывать больше усилий; однако в ситуации
Кнопка, это имеет смысл, потому что каждая платформа уже имеет определение
что такое кнопка и как она себя ведет.
Довольно часто как разработчики приложений вы будете использовать существующие
элементы управления, а не создавать свои собственные элементы управления, поэтому вместо необходимости
чтобы построить все, что вы видите на рис. 11-4, вы можете настроить элементы управления
с помощью обработчиков.
  
# Настройка элементов управления с помощью картографов  
  
Картографы являются ключом к архитектуре обработчика. Они определяют действия, которые
будет выполняться при изменении свойства или при отправке команды
между кросс-платформенными элементами управления и специфичными для платформы представлениями. Этот кусок
информации сама по себе может быть не очень полезной, но как только вы получите
понимание того, как изменить эти действия или предоставить новые, вы
может начать понимать, насколько мощным это может быть. Большинство
Обработчики .NET MAUI находятся в пространстве имен ```Microsoft.Maui.Handlers```,
что делает их относительно легкими для обнаружения. Есть несколько исключений
к этому правилу, которое определено в их документации по адресу https://learn.
microsoft.com/dotnet/maui/user-interface/handlers/#handlerbased-views.

---
Важно отметить, что, изменяя преобразователи для обработчиков,
вы будете переопределять поведение для всех реализаций
управлять им можно. Вы можете преодолеть это, создав класс (например,
MyButton), который наследуется от элемента управления, который вы хотите улучшить.
(например, Button), а затем ваш обработчик нацелен на новый класс
(Моя кнопка).
---
  
# Область настройки картографа
  
Все элементы управления в .NET MAUI, использующие архитектуру обработчика, также предоставляют
События ```HandlerChanging``` и ```HandlerChanged``` или ```OnHandlerChanging```
и ```OnHandlerChanged```, что означает, что вы можете подписаться на них и
настроить внешний вид конкретного экземпляра элемента управления.
  
# Дальнейшее чтение

Одним из замечательных примеров переопределения элементов управления таким образом является выступление Питера
Марчев, разработчик ```Telerik```, показывает, как можно настроить отдельные
компоненты в своих диаграммах контролируются очень ограниченным количеством кода.
Выступление можно посмотреть на www.youtube.com/watch?v=s7WfTT-MVSg.
  
# Краткое содержание  
  
В этой главе вы

  • Узнал о разрешениях на различных платформах
и как их запросить

  • Узнали, как использовать API геолокации.

  • Написал собственное взаимодействие для конкретной платформы, когда
необходимый

  • Обнаружено, как настроить пользовательский интерфейс в зависимости от платформы.
на котором работает ваше приложение

  • Дальнейшая настройка пользовательского интерфейса с помощью обработчика
архитектура

  В следующей главе вы будете

  • Узнайте, что такое тестирование и почему оно важно.
  
Расскажите, что такое модульное тестирование и как вы можете применить его к
Приложение .NET MAUI.
  
• Узнайте, что такое тестирование моментальных снимков и как вы можете
реализовать это.

  • Получите представление о тестировании устройств и о том, как вы можете
применить их к своим приложениям.

  • Загляните в будущее, чтобы еще раз испытать добро.  
  
# Исходный код  

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://learn.
microsoft.com/dotnet/maui/user-interface/handlers/#handlerbased-views.  
  
# Дополнительное задание  
  
Вы только поверхностно коснулись API-интерфейсов интеграции с платформой, которые
.NET MAUI предлагает вам. Я хотел бы, чтобы вы просмотрели другие возможные
API и создавать свои собственные виджеты, которые выиграют от них. 
документацию по API интеграции платформы можно найти по адресу https://
Learn.microsoft.com/dotnet/maui/platform-integration/.  
  
# Виджет барометра
  
Вы можете использовать API барометра, чтобы сообщать об окружающей среде.
давление воздуха возвращается к пользователю. На самом деле, это может быть хорошим дополнением к
Виджет погоды, а не совершенно новый виджет. Документация для
этот API можно найти по адресу https://learn.microsoft.com/dotnet/maui/
platform-integration/device/sensors?#barometer.
  
# Поиск геокодирования
  
Я не хочу включать разрешения, такие как доступ к местоположению, для приложений, которые мне не нужны.
поверьте, они действительно нужны. Возможно, вы можете улучшить свой виджет погоды
чтобы пользователь мог указать свой ближайший город, поселок или почтовый индекс и
затем используйте API геокодирования для обратного поиска долготы и широты
информация, необходимая для Open Weather API. Документация
API геокодирования можно найти по адресу https://learn.microsoft.com/
dotnet/maui/platform-integration/device/geocoding. 
  
  

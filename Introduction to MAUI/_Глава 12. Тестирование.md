# ГЛАВА 12

# Тестирование

Тестирование — очень важная часть процесса разработки программного обеспечения;
это позволяет вам убедиться, что вы доставили именно то, что требовалось
а также проверить правильность работы программного обеспечения. Он также обеспечивает
подстраховка от обнаружения регрессий в продуктах, которые вы создаете.
Существует множество различных подходов к разработке и написанию тестов.
и где они вписываются в процесс разработки программного обеспечения. Эта глава
не предназначено для полного понимания этих подходов, но
познакомить вас с различными методами тестирования приложения .NET MAUI, почему
они могут быть полезными и пробудить в вас интерес к обучению их использованию в
больше глубины

# Модульное тестирование

Юнит-тестирование — это процесс проверки того, что небольшие модули, обычно метод
или класса приложения соответствуют их дизайну и ведут себя так, как предполагалось. Один
Большим преимуществом тестирования такой небольшой единицы кода является то, что это упрощает
для вас, чтобы определить, где проблемы могут лежать или закрадываться как часть регрессии.
За свою карьеру я работал со многими устаревшими системами, где
команды пренебрегали применением модульного тестирования и опыта при попытке
выявить причину ошибки в большой системе действительно может быть дорого с точки зрения
время и деньги.
Несмотря на то, что юнит-тестирование рассматривается ближе к концу этой книги, это концепция.
которые должны быть приняты на ранней стадии процесса разработки. Модульное тестирование может
помощь в разработке и создании кода, который легче читать и поддерживать
потому что это заставляет вас раскрывать эти маленькие единицы функциональности и
в конечном итоге следовать принципам SOLID.
Модульное тестирование само по себе не выявит всех ошибок в системе и не должно
можно полагаться как на единственное средство тестирования ваших приложений. При использовании в
в сочетании с другими формами тестирования, такими как интеграционное, функциональное или
сквозное тестирование, вы можете быть уверены, что ваше приложение
стабилен и дает то, что требуется.
Давайте посмотрим, как реализовать модульное тестирование с помощью .NET MAUI.

# Модульное тестирование в .NET MAUI

Приложения .NET MAUI — это, как следует из названия, проекты на основе .NET,
это означает, что любая из существующих платформ модульного тестирования на основе .NET может
использоваться.

**Замечание:**
В настоящее время проект .NET MAUI по умолчанию несовместим.
с проектом модульного тестирования. Я расскажу, как решить эту проблему, в разделе «Добавление
Проект модульного тестирования для вашего решения».

Есть три известных фреймворка, которые поставляются с шаблоном.
поддержки в Visual Studio, что означает, что вы можете создавать их с помощью «Файл» ➤ «Добавить».
Новый вариант проекта. Три фреймворка перечислены ниже.

# xUnit

xUnit, по-видимому, является выбором команды .NET MAUI. Одна основная причина
поскольку это, вероятно, поддержка возможности запуска модульных тестов на основе xUnit.
на реальных устройствах, что означает, что вы можете тестировать реализации для конкретных устройств.
https://xunit.net

# НУнит

NUnit — мой старый фаворит. Я использовал его во многих проектах в
прошлое! У него есть несколько замечательных функций, таких как возможность запускать один и тот же тестовый пример.
с несколькими наборами данных, чтобы уменьшить объем тестового кода, необходимого для
писать и в конечном итоге поддерживать.
https://nunit.org

# МСТест

MSTest — это среда тестирования, созданная и поставляемая корпорацией Майкрософт. Это
не выглядит таким многофункциональным, как NUnit или xUnit, но все же отлично справляется со своей задачей.
https://learn.microsoft.com/dotnet/core/testing/unittesting-with-mstest

# Выбранная вами среда тестирования

В этой книге мы будем использовать xUnit главным образом из-за преимуществ, которые он дает.
с возможностью также запускать модульные тесты на устройствах.
Тесты в xUnit украшаются атрибутом [Факт] со значением
ожидание, что как автор тестовых методов вы назовете их в
способ, который определяет факт, который тест подтвердит.
Большинство тестовых фреймворков очень похожи и, как правило, различаются по срокам.
ключевых слов при идентификации тестов. Используйте любую среду тестирования
вам наиболее комфортно. Если у вас нет большого опыта
с любым, возможно, поэкспериментируйте с каждым, чтобы увидеть, что дает вам лучшее
опыт. В конце концов, вы будете строить и поддерживать
эти тесты, поэтому они должны приносить пользу вам и вашей команде.

# Добавление собственных модульных тестов

Есть несколько шагов, которые вам нужно выполнить, чтобы убедиться, что вы
может выполнить модульное тестирование вашего приложения .NET MAUI. Добавим тестовый проект в
решение, а затем внесите необходимые изменения.

# Добавление проекта модульного тестирования в ваше решение

1. Щелкните меню «Файл».
2. Нажмите Добавить.
3. Щелкните Новый проект.
4. Введите Тест в поле Поиск шаблонов.
На рис. 12-1 показано диалоговое окно «Добавить новый проект».
Визуальная студия.

![изображение](https://user-images.githubusercontent.com/26972859/231493948-80015487-83e8-4bea-bbd9-735952115fd2.png)

Рисунок 12-1. Добавить диалоговое окно нового проекта в Visual Studio

5. Выберите тестовый проект xUnit.
6. Щелкните Далее.
7. Введите имя проекта. я выбрал
```WidgetBoard.Tests``` и найдите добавление ```.Tests``` или
```.UnitTests``` предоставляет общий способ отличить
между приложением и тестовыми проектами. Это тоже
общее соглашение об именах, которое упрощает
поиск всех проектов модульных тестов при запуске
в конвейере CI. Я расскажу об этом более подробно в
Глава 14.
8. Щелкните Далее.
9. Выберите фреймворк. Значение по умолчанию должно подойти;
просто убедитесь, что он соответствует целевой версии
Проект приложения .NET MAUI.
10. Щелкните Создать.

# Измените проект вашего приложения на целевой net7.0

К сожалению, текущий шаблон проекта .NET MAUI не включает
целевая платформа net7.0, что означает, что она изначально несовместима с
стандартный модульный тестовый проект. Чтобы исправить это, вы можете вручную
добавьте целевую структуру net7.0. Откройте ```WidgetBoard/WidgetBoard```.
csproj в Visual Studio Code или вашем любимом текстовом редакторе и сделайте
следующие изменения.
Измените первый элемент ```TargetFrameworks```, включив в него net7.0; изменения
выделены жирным шрифтом:

```xml
<TargetFrameworks>net7.0;net7.0-android;net7.0-ios;net7.0-maccatalyst</TargetFrameworks>
```
Добавьте атрибут ```Condition``` к элементу ```OutputType```; изменения
жирным шрифтом:

```xml
<OutputType Condition="'$(TargetFramework)' != 'net7.0'">Exe
</OutputType>
```
Без этого второго изменения вы увидите сообщение об ошибке компиляции
эта ошибка CS5001: программа не содержит статического основного метода
подходит для точки входа. Это связано с тем, что вы строите
приложение и приложения .NET ожидают наличия статического метода Main
в качестве точки входа в приложение. ```OutputType``` для .NET MAUI
приложения должны быть в формате Exe, что может показаться немного запутанным, поскольку вы редко в итоге получите исполняемый файл, который будет доставлен.

---
Если вы используете более новую версию .NET MAUI, вы можете
замените net7.0 версией, которую вы используете, например, net8.0.
---

# Добавление ссылки на проект для тестирования

Теперь вам нужно добавить ссылку из вашего тестового проекта на основной
прикладной проект.
1. Щелкните правой кнопкой мыши ```WidgetBoard.Tests```.
2. Нажмите Добавить.
3. Щелкните Справочник по проекту.
4. Выберите ```WidgetBoard``` из списка. Рисунок 12-2 показывает
диалоговое окно «Диспетчер ссылок» в Visual Studio.

![изображение](https://user-images.githubusercontent.com/26972859/231494592-12c69608-6b15-4e68-a8f0-3c484d8b5179.png)

Рисунок 12-2. Диспетчер ссылок в Visual Studio

5. Нажмите ОК.

# Измените свой тестовый проект, чтобы использовать зависимости MAUI

Последний шаг — заставить ваш тестовый проект использовать .NET MAUI.
зависимости так же, как основной проект приложения. Откройте
Файл ```WidgetBoard.Tests/WidgetBoard.Tests.csproj``` в Visual Studio
Код или ваш любимый текстовый редактор и внесите следующие изменения
Добавьте ```<UseMaui>true</UseMaui>``` в группу свойств верхнего уровня.
элемент, который теперь должен выглядеть так; изменения выделены жирным шрифтом:

```xml
<PropertyGroup>
 <TargetFramework>net7.0</TargetFramework>
 <ImplicitUsings>enable</ImplicitUsings>
 <Nullable>enable</Nullable>
 <UseMaui>true</UseMaui>
 <IsPackable>false</IsPackable>
</PropertyGroup>
```
Теперь вы настроили все, чтобы приступить к написанию и запуску.
ваши модульные тесты.

# Тестирование ваших моделей представления

Архитектура MVVM очень хорошо подходит для модульного тестирования каждого
индивидуальный компонент.
Во-первых, вам нужно создать папку ```ViewModels``` в вашем
Проект ```WidgetBoard.Tests```, а затем добавьте новый файл класса с именем
```BoardDetailsPageViewModelTests.cs```. Хорошей практикой является хранение папок
и тесты, названные аналогично коду, который они тестируют, чтобы упростить его
организовать и разместить.
Теперь вы можете добавить свой первый набор тестов.

# Тестирование BoardDetailsPageViewModel

Внутри только что созданного файла класса добавьте следующее:

```Csharp
[Fact]
public void SaveCommandCannotExecuteWithoutBoardName()
{
 var viewModel = new BoardDetailsPageViewModel(null, null);
 Assert.Null(viewModel.BoardName);
 Assert.False(viewModel.SaveCommand.CanExecute(null));
}
[Fact]
public void SaveCommandCanExecuteWithBoardName()
{
 var viewModel = new BoardDetailsPageViewModel(null, null);
 viewModel.BoardName = "Work";
 Assert.True(viewModel.SaveCommand.CanExecute(null));
}
```

# Тестирование INotifyPropertyChanged

В главе 4 я рассказал, что ```INotifyPropertyChanged``` служит
механизм для синхронизации ваших представлений и моделей представлений; следовательно, он может
быть действительно полезным, чтобы убедиться, что ваши модели представления правильно реализуются
```INotifyPropertyChanged```, гарантируя, что он вызывает свойство ```PropertyChanged```.
событие, когда оно должно.
Следующий тест показывает, как создать экземпляр
```BoardDetailsPageViewModel```, подпишитесь на событие ```PropertyChanged```,
изменить свойство, которое, как вы ожидаете, вызовет событие ```PropertyChanged```, и
затем подтвердите, что событие было вызвано:

```Csharp
[Fact]
public void SettingBoardNameShouldRaisePropertyChanged()
{
 var invoked = false;
 var viewModel = new BoardDetailsPageViewModel(null, null);
 viewModel.PropertyChanged += (sender, e) =>
 {
 if (e.PropertyName.Equals(nameof(BoardDetailsPageView
Model.BoardName)))
 {
 invoked = true;
 }
 };
 viewModel.BoardName = "Work";
 Assert.True(invoked);
}
```
Это дает вам уверенность в том, что если ```BoardName```
не отображается в вашем пользовательском интерфейсе, это, вероятно, не будет проблемой внутри
модель представления.

# Тестирование асинхронных операций

Многие современные приложения включают определенный уровень асинхронной работы.
и прекрасным примером является использование вами ```Open Weather API``` для загрузки
погода в текущем местоположении. ```WeatherWidgetViewModel``` опирается на
реализация созданного вами интерфейса ```IWeatherForecastService```
в главе 10. Модульные тесты для конкретных реализаций, подобных этой, могут
считать шелушащимся. Ненадежный тест — это тест, дающий противоречивые результаты.
Доступ к веб-службе может демонстрировать такое поведение при модульном тестировании.
учитывая ограничения доступа к API или другие потенциальные проблемы, которые могут повлиять на
надежный тестовый запуск.
Для того, чтобы убрать хлипкость теста, можно создать mock
реализация, которая обеспечит набор согласованного поведения

# Создание макета ILocationService

Создайте новую папку в своем проекте ```WidgetBoard.Tests``` и назовите ее ```Mocks```. я
рассматривал это раньше, но организация кода таким образом действительно может сделать
его гораздо легче поддерживать. С этой новой папкой вы можете создать новый класс
файл внутри и назовите его ```MockLocationService.cs```. Измените содержимое на
следующий:

```Csharp
using WidgetBoard.Services;
namespace WidgetBoard.Tests.Mocks;
internal class MockLocationService : ILocationService
{
 private readonly Location? location;
 private readonly TimeSpan delay;
 private MockLocationService(Location? mockLocation,
TimeSpan delay)
 {
 location = mockLocation;
 this.delay = delay;
 }
 internal static ILocationService ThatReturns(Location?
location, TimeSpan after) =>
 new MockLocationService(location, after);
 internal static ILocationService
ThatReturnsNoLocation(TimeSpan after) =>
 new MockLocationService(null, after);
 public async Task<Location?> GetLocationAsync()
 {
 await Task.Delay(this.delay);
 return this.location;
 }
}
```
Реализация, которую вы предоставили для ```GetLocationAsync```
метод вызывает задержку на основе предоставленного параметра ```TimeSpan``` в
конструктор для имитации сетевой задержки, а затем возвращает местоположение
предоставляется в конструкторе.

Одна ключевая деталь, которую мне очень нравится использовать при создании макетов, — это
их использование в моих тестах настолько легко читается, насколько это возможно. Вы можете видеть, что
```MockLocationService``` не может быть создан, поскольку он имеет частный
конструктор. Это означает, что для его использования вы должны использовать ```ThatReturns``` или
Методы ```ThatReturnsNoLocation```. Посмотри на это и увидишь, сколько еще
читаемо это:

```Csharp
MockLocationService.ThatReturns(new Location(0.0, 0.0), after:
TimeSpan.FromSeconds(2));
```
Приведенное выше гораздо читабельнее, чем следующее, потому что оно
включает намерение:

```Csharp
new MockLocationService(new Location(0.0, 0.0), TimeSpan.
FromSeconds(2));

```

# Создание макета WeatherForecastService

Вы можете добавить второй файл в папку ```Mocks``` и вызвать этот файл класса
```MockWeatherForecastService.cs```. Измените содержимое на следующее:

```Csharp
using WidgetBoard.Communications;
namespace WidgetBoard.Tests.Mocks;
internal class MockWeatherForecastService :
IWeatherForecastService
{
 private readonly Forecast? forecast;
 private readonly TimeSpan delay;
 private MockWeatherForecastService(Forecast? forecast,
TimeSpan delay)
 {
 this.forecast = forecast;
 this.delay = delay;
 }
 internal static IWeatherForecastService
ThatReturns(Forecast? forecast, TimeSpan after) =>
 new MockWeatherForecastService(forecast, after);
 internal static IWeatherForecastService
ThatReturnsNoForecast(TimeSpan after) =>
 new MockWeatherForecastService(null, after);
 public async Task<Forecast?> GetForecast(double latitude,
double longitude)
 {
 await Task.Delay(this.delay);
 return forecast;
 }
}
```
Реализация, предоставленная вами для метода ```GetForecast```, заставляет
задержка на основе предоставленного параметра ```TimeSpan``` в конструкторе
чтобы имитировать задержку в сети, а затем вернуть прогноз, предоставленный в
конструктор.

# Создание асинхронных тестов

Имея макеты на месте, вы можете написать тесты, которые будут проверять
поведение вашего приложения при вызове асинхронного и потенциально
длительные операции. Вам нужно добавить новый файл класса в ваш
Папка ```ViewModels``` в проекте ```WidgetBoard.Tests``` и вызов
```WeatherWidgetViewModelTests.cs```, а затем измените содержимое на
следующий:

```Csharp
using WidgetBoard.Tests.Mocks;
using WidgetBoard.ViewModels;
namespace WidgetBoard.Tests.ViewModels;
public class WeatherWidgetViewModelTests
{
}
```

Теперь вы можете приступить к добавлению трех тестов, чтобы охватить различные
разные сценарии.

```Csharp
[Fact]
public async Task NullLocationResultsInPermissionErrorState()
{
 var viewModel = new WeatherWidgetViewModel(
 MockWeatherForecastService.ThatReturnsNoForecast(after:
TimeSpan.FromSeconds(5)),
 MockLocationService.ThatReturnsNoLocation(after:
TimeSpan.FromSeconds(2)));
 await viewModel.InitializeAsync();
 Assert.Equal(State.PermissionError, viewModel.State);
 Assert.Null(viewModel.Weather);
}
```
Этот первый тест, как следует из названия, проверяет, что если нулевое местоположение
возвращаемая из реализации ```ILocationService```, модель представления
Состояние будет установлено на ```PermissionError```, и погода не будет установлена.

```Csharp
[Fact]
public async Task NullForecastResultsInErrorState()
{
 var viewModel = new WeatherWidgetViewModel(
 MockWeatherForecastService.ThatReturnsNoForecast(after:
TimeSpan.FromSeconds(5)),
MockLocationService.ThatReturns(new Location(0.0, 0.0),
after: TimeSpan.FromSeconds(2)));
 await viewModel.InitializeAsync();
 Assert.Equal(State.Error, viewModel.State);
 Assert.Null(viewModel.Weather);
}
```
Этот второй тест, как следует из названия, проверяет, что если нулевой прогноз
возвращаемый из реализации ```IWeatherForecastService```, представление
State модели будет установлено на Error, и погода не будет установлена.

```Csharp
[Fact]
public async Task ValidForecastResultsInSuccessfulLoad()
{
 var weatherForecastService =
 MockWeatherForecastService.ThatReturns(
 new Communications.Forecast
 {
 Current = new Communications.Current
 {
 Temperature = 18.0,
 Weather = new Communications.Weather[]
 {
 new Communications.Weather
 {
 Icon = "abc.png",
Main = "Sunshine"
 }
 }
 }
 },
 after: TimeSpan.FromSeconds(5));
 var locationService = MockLocationService.ThatReturns(
 new Location(0.0, 0.0),
 after: TimeSpan.FromSeconds(2));
 var viewModel = new WeatherWidgetViewModel(
 weatherForecastService,
 locationService);
 await viewModel.InitializeAsync();
 Assert.Equal(State.Loaded, viewModel.State);
 Assert.Equal("Sunshine", viewModel.Weather);
}
```
Этот последний тест, как следует из названия, проверяет,
возвращаемый из реализации ```IWeatherForecastService```, представление
Состояние модели будет установлено на «Загружено», а погода будет установлена ​​правильно.

# Проверка ваших представлений

Можно написать модульные тесты, которые будут проверять поведение ваших представлений.

# Создание макета ClockWidgetViewModel

Чтобы проверить ваш ```ClockWidgetView```, вам нужно предоставить ему представление
модель. Ваша ```ClockWidgetViewModel``` в настоящее время имеет некоторые сложности.
это затруднит его использование в тесте. Он отображает текущую дату/время.
Давайте создадим макет, чтобы устранить эту потенциальную трудность. Внутри ваших моков
папку, добавьте новый файл класса с именем ```MockClockWidgetViewModel.cs``` и
изменить содержимое, чтобы оно соответствовало следующему:

```Csharp
using WidgetBoard.ViewModels;
namespace WidgetBoard.Tests.Mocks;
public class MockClockWidgetViewModel : IWidgetViewModel
{
 public int Position { get; set; }
 public string Type => "Mock";
 public MockClockWidgetViewModel(DateTime time)
 {
 Time = time;
 }
 public DateTime Time { get; }
 public Task InitializeAsync() => Task.CompletedTask;
}
```
Теперь вы можете использовать это в своих модульных тестах, чтобы убедиться, что ваш
```ClockWidgetView``` правильно привязывается к своей модели представления.

# Создание тестов представления

Сначала создайте папку ```Views``` в своем проекте ```WidgetBoard.Tests```, а затем добавьте
новый файл класса с именем ```ClockWidgetView.cs```.

```Csharp
using WidgetBoard.Tests.Mocks;
using WidgetBoard.Views;
namespace WidgetBoard.Tests.Views;
public class ClockWidgetViewTests
{
 [Fact]
 public void TextIsUpdatedByTimeProperty()
 {
  var time = new DateTime(2022, 01, 01);
 var clockWidget = new ClockWidgetView();
 Assert.Null(clockWidget.Text);
 clockWidget.WidgetViewModel = new MockClockWidgetView
Model(time);
 Assert.Equal(time.ToString(), clockWidget.Text);
 }
}
```
Тест ```TextIsUpdatedByTimeProperty``` создает новый
ClockWidgetView назначает новую модель ```MockClockWidgetViewModel``` и
затем проверяет правильность обновления свойства ```Text``` виджета
чтобы отразить значение свойства ```Time``` в вашей модели представления через его
привязка.

# Тестирование устройств

Тестирование устройств на самом деле является формой модульного тестирования; тем не менее, он обеспечивает некоторые
уникальные способности, поэтому он заслуживает отдельного раздела верхнего уровня. Это по существу
позволяет вам писать модульные тесты, которые можно запускать на устройстве и, следовательно,
по-настоящему тестировать любые функциональные возможности платформы. Прекрасный пример
из этого, чтобы протестировать ```PlatformLocationService```, который вы реализовали в
предыдущую главу, чтобы вернуть координаты долготы и широты каждого
штаб-квартира поставщика платформы.

# Создание проекта тестирования устройства

Вам нужно создать другой проект, чтобы справиться с запуском
тесты устройства. Документация в репозитории GitHub охватывает все это.
необходим, поэтому перейдите на https://github.com/shinyorg/xunit-maui. Регистрироваться
репозиторий кода под названием ```WidgetBoard.DeviceTests```, если вы застряли; там
это уже созданный проект для использования в качестве шаблона.

# Добавление теста для конкретного устройства

```Csharp
using WidgetBoard.Services;
using Xunit;
namespace WidgetBoard.DeviceTests.Services;
public class PlatformLocationServiceTests
{
 [Fact]
 public async Task GetLocationAsyncWillReturnPlatform
SpecificLocation()
 {
 var locationService = new PlatformLocationService();
 var location = await locationService.
GetLocationAsync();
#if ANDROID
 Assert.Equal(37.419857, location.Latitude);
 Assert.Equal(-122.078827, location.Longitude);
#elif WINDOWS
 Assert.Equal(47.639722, location.Latitude);
 Assert.Equal(-122.128333, location.Longitude);
#else
 Assert.Equal(37.334722, location.Latitude);
 Assert.Equal(-122.008889, location.Longitude);
#endif
 }
}
```
Теперь, когда вы написали свои тесты, вы можете запустить их на своем
устройства.

# Запуск тестов для конкретных устройств

Чтобы запустить тесты на устройстве, вам сначала нужно установить
Проект ```WidgetBoard.DeviceTests``` в качестве запускаемого проекта. Вы можете сделать это как
следует:
• Щелкните правой кнопкой мыши проект ```WidgetBoard.DeviceTests``` в
Обозреватель решений.
• Выберите Установить в качестве запускаемого проекта.
Теперь запустите приложение из Visual Studio. Рисунок 12-3 показывает
экран запуска теста устройства, работающий в Windows.

![изображение](https://user-images.githubusercontent.com/26972859/231498799-d25896cb-cb5c-4b3e-8022-059e0a5ef0fd.png)

Рисунок 12-3. Средство запуска тестов устройств на платформе Windows

Вы можете щелкнуть конкретный тест и выбрать его запуск, или вы можете просто
Выполнить все тесты. Эта часть полностью выполняется вручную, поэтому потребуется, чтобы человек
выполнять эти задачи, но его можно оставить работать столько времени, сколько потребуется тестам.
Наконец, вы увидите результаты тестовых прогонов, и вы можете нажать на них.
чтобы увидеть больше информации. На рис. 12-4 показаны средство запуска тестов устройства и
набор результатов испытаний.

![изображение](https://user-images.githubusercontent.com/26972859/231498917-7edeb287-4761-4f24-a496-808f885be965.png)

Рисунок 12-4. Результат тестового запуска для ```GetLocationAsyncWillReturn```
Тест устройства ```PlatformSpecificLocation```

Вы можете запустить эти тесты на всех платформах, которые вы поддерживаете, чтобы сделать
уверен, что код делает то, что ожидается.

# Тестирование снимков

Тестирование моментальных снимков похоже на модульное тестирование, но позволяет избежать необходимости писать
Операторы ```Assert``` для ручного определения каждого ожидания в тесте. Вместо
результат теста сравнивается с золотым мастером. Золотой мастер – это
моментальный снимок предыдущего запуска теста, который вы, как автор теста, принимаете в качестве
ожидаемый результат для последующих тестовых прогонов. Снимок может быть любым
от снимка экрана приложения до сериализации объекта
в памяти. Если вы посмотрите на ```WeatherWidgetViewModel```, вы
проверено в предыдущем разделе, вы можете видеть, что сериализация состояния
теста ```ValidForecastResultsInSuccessfulLoad``` приведет к
создается следующий золотой мастер:

```Csharp
{
 LoadWeatherCommand: {},
 IconUrl: https://openweathermap.org/img/wn/abc.png@2x.png,
 State: Loaded,
 Temperature: 18.0,
 Weather: Sunshine,
 Type: Weather
}
```
Когда этот тест запускается, каждый раз, когда сериализованный вывод
```WeatherWidgetViewModel``` будет сравниваться с указанным выше золотым мастером.
Если какие-либо значения отличаются от значений в золотом мастере, тест
не удастся.

# Моментальный снимок тестирования вашего приложения

Для моментального тестирования вашего приложения вы будете использовать
отличная библиотека под названием ```VerifyTests```. В ```VerifyTests``` есть действительно отличные
документацию и примеры, которые помогут вам начать все сначала, на https://github.
com/VerifyTests/Verify.
Вам также потребуется использовать пакет ```Verify.Xunit NuGet```. Я решил создать отдельный проект, чтобы сохранить вещи
четко разделены для целей этого примера. Вы можете повторить шаги
в разделах «Добавление проекта модульного тестирования в ваше решение» и «Добавление
Ссылка на проект для тестирования», за исключением того, что вы назовете проект
```WidgetBoard.SnapshotTests```.
Используя ```VerifyTests```, вы можете сделать копию своего
Класс ```WeatherWidgetViewModelTests``` в проекте ```WidgetBoard.Tests```
и измените его на следующее. Ограниченные изменения выделены жирным шрифтом.
выделить отличия от оригинала.

```Csharp
[UsesVerify]
public class WeatherWidgetViewModelTests
{
 [Fact]
 public async Task
NullLocationResultsInPermissionErrorState()
 {
 var viewModel = new WeatherWidgetViewModel(
 new MockWeatherForecastService(null),
 new MockLocationService(null));
 await viewModel.InitializeAsync();
 await Verify(viewModel);
 }
 [Fact]
 public async Task NullForecastResultsInErrorState()
 {
 var viewModel = new WeatherWidgetViewModel(
 new MockWeatherForecastService(null),
 new MockLocationService(new Location(0.0, 0.0)));
 await viewModel.InitializeAsync();
 await Verify(viewModel);
 }
 [Fact]
 public async Task ValidForecastResultsInSuccessfulLoad()
 {
 var viewModel = new WeatherWidgetViewModel(
 new MockWeatherForecastService(new Communications.
Forecast
{
 Current = new Communications.Current
 {
 Temperature = 18.0,
 Weather = new Communications.Weather[]
 {
 new Communications.Weather
 {
 Icon = "abc.png",
Main = "Sunshine"
 }
 }
 }
 }),
 new MockLocationService(new Location(0.0, 0.0)));
 await viewModel.InitializeAsync();
 await Verify(viewModel);
 }
}
```
Вы удаляете операторы ```Assert``` и заменяете их вызовом
Метод проверки. В вашем исходном сценарии вы только утверждали небольшую
количество вещей, но вы можете себе представить, что если количество ```Assert```
операторы должны были расти, то этот единственный вызов метода ```Verify``` действительно
уменьшить сложность ваших тестов.
Совершенно новые испытания всегда будут провалены, пока вы не примете золотого мастера.
Существует инструмент, который может упростить эту задачу, который снова предоставляется
разработчики ```VerifyTests```.

# Проходящие мысли

Я заканчиваю этот раздел тестирования моментальных снимков заявлением, что он не предназначен для
каждый. Некоторым людям действительно нравится уменьшение размера тестового примера, в то время как
он проверяет больше, чем большинство типичных модульных тестов, просто потому, что он
проверяет весь тестируемый объект. В качестве контраргумента некоторые люди
не нравится, что ожидаемое состояние или золотой мастер находятся в файле, отдельном от
тесты. Я лично считаю, что они представляют большую ценность, и я надеюсь, что это
введение в тестирование моментальных снимков даст вам достаточно контекста, чтобы решить
подойдет ли он вам и вашей команде или, по крайней мере, даст
вы желание поэкспериментировать с концепцией.

# Взгляд в будущее

Мне очень хотелось, чтобы в этой главе было рассказано, как писать и создавать тесты, которые
может протестировать ваш пользовательский интерфейс с помощью тестов автоматизации. К сожалению, это еще не совсем готово. Это
конечно то что просматривается, но ничего конкретного нет
или готовы.
Если у вас есть опыт работы с ```Xamarin.Forms```, вы можете
хорошо знать о ```Xamarin.UITesting```. Это оказалось немного сложно
работать, и это было непоследовательно время от времени, но это действительно обеспечило
основы для написания тестов автоматизации для приложения ```Xamarin.Forms```.
В настоящее время команда .NET MAUI оценивает несколько вариантов включения
вам протестировать ваши приложения.
В настоящее время есть возможность тестирования с помощью Appium
(https://appium.io); однако иногда он может быть неуклюжим и ненадежным.
Меня больше всего вдохновляет работа, которую Джонатан Дик (разработчик .NET MAUI
лид) занимается с ```Maui.UITesting```. Это очень в зачаточном состоянии в
время написания, но я ожидаю, что из этого выйдет что-то хорошее. Вам следует
ознакомьтесь с подробностями в репозитории GitHub по адресу https://github.
com/Redth/Maui.UITesting.

# Краткое содержание

Теперь у вас есть обзор различных методов тестирования и их преимуществ.
они приносят. Вы можете предпочесть моментальный снимок написанию собственных утверждений. Я не
в любом случае, пока вы тестируете свой код.

В этой главе вы

• Узнали, что такое тестирование и почему оно важно

• Изучили модульное тестирование и то, как его можно применить к
Приложение .NET MAUI

• Узнали о тестировании моментальных снимков и о том, как вы можете
реализовать это

• Изучили, что такое тесты устройств и как их можно применять.
их в ваши приложения

• Заглядывали в будущее, чтобы еще больше испытать доброту
В следующей главе вы будете

• Узнайте, что такое .NET MAUI Graphics.

• Получите представление о некоторых возможностях, предоставляемых
.NET MAUI Graphics

• Создайте свой собственный виджет эскиза с помощью .NET MAUI.
Элемент управления ```GraphicsView```

# Исходный код

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introducing-MAUI/tree/
main/ch12.


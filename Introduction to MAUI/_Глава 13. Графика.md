# ГЛАВА 13

# Позволяет получить графику

В этой главе вы узнаете, что такое ```.NET MAUI Graphics```, как его можно
использовать, а также несколько практических примеров того, почему вы хотели бы его использовать.
Вы также получите представление о некоторых возможностях, предоставляемых ```.NET MAUI Graphics``` и то, как вы можете использовать ее для создания собственного эскизного виджета с помощью
Элемент управления ```GraphicsView``` .NET MAUI.

# .NET MAUI Graphics

```.NET MAUI Graphics``` — еще одна из моих любимых тем! я в настоящее время
исследуя идею создания игрового движка поверх него, учитывая количество
мощности он уже предлагает.

У него есть потенциал, чтобы предложить возможность так многого достичь,
такие вещи, как рендеринг элементов управления диаграммами или других причудливых концепций через кросс-платформенный API, что означает, что вам действительно нужно сосредоточиться только на проблемах вы пытаетесь решить и не беспокоиться о каждой отдельной платформе.
По сути, ```.NET MAUI Graphics``` предлагает поверхность, которая может отображать пиксельную графику на любой платформе, поддерживаемой .NET MAUI. Рассмотрим ```.NET MAUI Graphics``` как слой абстракции, как и сам .NET MAUI, поверх
библиотеки чертежей для конкретной платформы. Так мы получаем всю силу каждого
платформу, но с помощью простого унифицированного API .NET, который мы, как разработчики, можем
работать с.

# Рисование на экране

.NET MAUI предоставляет ```GraphicsView```, который можно использовать для рисования фигур на
экран. Вам нужно назначить свойство ```Drawable``` на ```GraphicsView```
с реализацией, которая умеет рисовать. Эта реализация
должен реализовать интерфейс ```IDrawable```, определяющий метод ```Draw```.

# Обновление поверхности

Чтобы запустить приложение или ```GraphicsView``` для обновления того, что
отображается на экране, вы должны вызвать метод ```Invalidate``` на
Графический вид. Это приведет к тому, что метод ```IDrawable.Draw``` будет
вызывается, и вашему коду будет предоставлена ​​возможность обновить холст.
Способ взаимодействия с реализацией ```ICanvas``` заключается в том, чтобы сначала
установите нужные вам значения, такие как цвет заливки (```FillColor```) или цвет обводки
(```StrokeColor```), а затем вызовите интересующий вас метод рисования.
(```FillSquare```() или ```DrawSquare()``` соответственно).
Давайте рассмотрим несколько основных примеров, чтобы лучше понять, как
использовать графический слой.

# Рисование линии

Внутри метода Draw вы можете взаимодействовать с ```ICanvas```, чтобы нарисовать линию.
с помощью метода ```DrawLine```. Следующий код показывает, как это может быть
достигнуто:

```Csharp
public void Draw(ICanvas canvas, RectF dirtyRect)
{
 canvas.StrokeColor = Colors.Red;
 canvas.StrokeSize = 6;
 canvas.DrawLine(0, 20, 100, 50);
}
```
Вы устанавливаете StrokeColor и StrokeSize перед вызовом DrawLine.
метод. Порядок важен, и вы должны установить эти свойства, прежде чем
рисовать. На рис. 13.1 показан результат метода Draw сверху.

![изображение](https://user-images.githubusercontent.com/26972859/231508864-5ace6d9a-dd35-4fe4-b873-de20e28904ad.png)

Рисунок 13-1. Рисование линии в .NET MAUI Graphics

Помимо рисования линий, вы можете рисовать множество различных фигур, таких как
как эллипс, прямоугольник, прямоугольник со скругленными углами и дуга. можно еще больше нарисовать
сложные формы через пути.

# Рисование пути

Пути не следует путать с API фигур, предоставляемым с .NET.
МАУИ. Пути в .NET MAUI Graphics позволяют создать набор
координаты, чтобы нарисовать более сложную форму.

```Csharp
public void Draw(ICanvas canvas, RectF dirtyRect)
{
 PathF path = new PathF();
 path.MoveTo(40, 10);
 path.LineTo(70, 80);
 path.LineTo(10, 50);
 path.Close();
 canvas.StrokeColor = Colors.Red;
 canvas.StrokeSize = 6;
 canvas.DrawPath(path);
}
```
Сначала вы создаете ```PathF``` с помощью функций ```MoveTo```, ```LineTo``` и ```Close```.
методы. Метод ```MoveTo``` перемещает текущее местоположение пути в
указанным координатам, а затем метод ```LineTo``` рисует линию из
текущее местоположение, которое вы только что установили в ```MoveTo```, на координаты, указанные в
вызов метода ```LineTo```. Наконец, метод ```Close``` позволяет закрыть
путь. Это означает, что к конечному местоположению будет добавлена ​​линия обратно в
исходное местоположение. Обратите внимание, что вы явно не добавили ```LineTo(40, 10)```
вызов метода; ```Close``` делает это за вас. Затем вы устанавливаете ```StrokeColor``` и
StrokeSize перед вызовом метода ```DrawPath```. Рисунок 13-2 показывает
результат метода ```Draw``` сверху.

![изображение](https://user-images.githubusercontent.com/26972859/231509191-7a64d37f-a9e7-401e-b8c0-a0a8cf07a14a.png)

Рисунок 13-2. Рисование пути в .NET MAUI Graphics

Именно этот метод ```DrawPath``` вы будете использовать в новом виджете.
вы будете строить как часть этой главы.

# Сохранение состояния холста

Бывают случаи, когда вы хотите сохранить некоторые настройки.
которые вы применяете к холсту, например такие свойства, как ```StrokeColor``` и
Цвет заливки. Все свойства, связанные с обводкой и заливкой, а также другие, такие как
свойства преобразования, могут быть сохранены. Это можно сделать через
метод ```SaveState```, который сохранит текущее состояние. Это сохраненное состояние
затем можно восстановить с помощью метода ```RestoreState```. Это также возможно
чтобы сбросить текущее состояние графики обратно к значениям по умолчанию с помощью
Метод ```ResetState```. Эти три метода могут обеспечить большое количество
функциональности в конкретных сценариях. Скажем, вы внедрили диаграмму
управление рендерингом, где отображается диаграмма, а затем каждый отдельный
серия дается отдельно. Вы хотите сохранить состояние диаграмм
настройки графики, но хотите сбрасывать каждый раз, когда вы рендерите серию (например, каждый
столбец гистограммы).

# Дальнейшее чтение

Вы только коснулись того, что возможно с .NET.
Графический слой MAUI. Я настоятельно рекомендую вам обратиться к Microsoft
документации на https://learn.microsoft.com/dotnet/maui/userinterface/graphics/, где показаны гораздо более сложные сценарии, такие как
такие как рисование узоров, градиенты, изображения, рендеринг текста и многое другое.

# Создание виджета Sketch

Мои дочери любят рисовать и оставляют мне записки, когда меня нет дома.
со своего стола, поэтому я подумал, почему бы не дать им возможность рисовать в цифровом виде.
наброски и помочь спасти несколько деревьев. Давайте создадим новый виджет, а затем
собрать воедино эту новую механику рисования

# Создание модели SketchWidgetViewModel

Как и для всех виджетов, вы хотите создать модель представления, которая будет сопровождать
вид. Давайте добавим новый файл класса в папку ```ViewModels``` и назовем его
```SketchWidgetViewModel.cs```. Измените его со следующим содержимым:

```Csharp
namespace WidgetBoard.ViewModels;
public class SketchWidgetViewModel : IWidgetViewModel
{
 public const string DisplayName = "Sketch";
 public int Position { get; set; }
 public string Type => DisplayName;
 public Task InitializeAsync() => Task.CompletedTask;
}
```
Модель представления относительно проста, так как ей нужно только реализовать
основы интерфейса ```IWidgetViewModel```. Если вы решили добавить больше
функциональность в ваш виджет, у вас есть для этого инфраструктура.
Давайте теперь займемся представлением и взаимодействием с пользователем.


# Представление взаимодействия с пользователем

Когда пользователь взаимодействует с новым виджетом, он будет рисовать на
экран. Вам нужно будет записать это взаимодействие, чтобы его можно было отобразить.
внутри метода ```Draw```, который ```SketchWidgetView``` реализует через
интерфейс ```IDrawable```. Добавьте новый новый файл класса, назовите его ```DrawingPath.cs```
в корне проекта и измените его, чтобы он имел следующее содержимое:

```Csharp
public class DrawingPath
{
 public DrawingPath(Color color, float thickness)
 {
 Color = color;
 Thickness = thickness;
 Path = new PathF();
 }
 public Color Color { get; }
 public PathF Path { get; }
 public float Thickness { get; }
 public void Add(PointF point) => Path.LineTo(point);
}
```

Класс имеет три основных свойства:

• Color представляет собой цвет рисуемой линии.

• Thickness показывает толщину линии.

• Path содержит точки, составляющие линию.

У вас также есть единственный метод, который добавляет новую точку в путь.
свойство. Это хорошо согласуется с графическим слоем .NET MAUI.
получить точку, когда пользователь взаимодействует с поверхностью, и тогда вы можете
также используйте тот же тип для отображения линии на экране.
Давайте создадим виджет, который будет использовать этот класс.

# Создание SketchWidgetView

Как и в случае с каждым из представлений виджетов, вы будете создавать представление на основе XAML.
Это будет внутри представления, где находится большая часть логики, потому что это
виджет в значительной степени связан с просмотром.
Добавьте новый ```.NET MAUI ContentView (XAML)``` в папку ```Views``` и
назовите его ```SketchWidgetView```.

# Изменение SketchWidgetView.xaml

Содержимое файла ```SketchWidgetView.xaml``` должно быть изменено на
следующее. Помните, что вы хотите, чтобы ваше визуальное дерево было максимально простым.
насколько это возможно. Вам нужно только объявить сам ```GraphicsView``` и никакие другие
управление контейнером.

```xml
<?xml version="1.0" encoding="utf-8" ?>
<GraphicsView
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 x:Class="WidgetBoard.Views.SketchWidgetView"
 StartInteraction="GraphicsView_StartInteraction"
 DragInteraction="GraphicsView_DragInteraction"
 EndInteraction="GraphicsView_EndInteraction" />
```
•```GraphicsView``` предоставляет несколько событий, на которые вы можете подписаться.
для обработки взаимодействия пользователя с поверхностью. Только ты
интересует следующее:

• ```StartInteraction```: это когда пользователь впервые взаимодействует,
так что в основном, когда происходит первое касание/щелчок мыши.

• ```DragInteraction```: следует с самого начала и
включает в себя прикосновение/перемещение мыши по
поверхность.

• ```EndInteraction```: когда пользователь поднимает палец.
с экрана или кнопки мыши.

Когда вы добавляете эти события в файл XAML, он автоматически
создайте некоторый код C# в файле ```SketchWidgetView.xaml.cs```, который вы
расширить в ближайшее время.

# Изменение SketchWidgetView.xaml.cs

Visual Studio уже создала этот файл для вас, поэтому вам нужно открыть
его и измените его на следующее:

**Замечание:**
Обратите внимание, что типы в обработчиках событий были сокращены (например,
из ```System.Object``` в объект). В основном это делается для того, чтобы читать было понятнее.

```Csharp
Using Microsoft.Maui.Controls;
using WidgetBoard.ViewModels;
namespace WidgetBoard.Views;
public partial class SketchWidgetView : GraphicsView,
IWidgetView, IDrawable
{
 public SketchWidgetView()
 {
 InitializeComponent();
this.Drawable = this;
 }
 public IWidgetViewModel WidgetViewModel
 {
 get => BindingContext as IWidgetViewModel;
 set => BindingContext = value;
 }
 private void GraphicsView_StartInteraction(object sender,
TouchEventArgs e)
 {
 }
 private void GraphicsView_DragInteraction(object sender,
TouchEventArgs e)
 {
 }
 private void GraphicsView_EndInteraction(Object sender,
TouchEventArgs e)
 {
 }
 public void Draw(Icanvas canvas, RectF dirtyRect)
 {
 throw new NotImplementedException();
 }
}
```

**Замечание**
Каждый из дескрипторов событий и метод ```Draw``` имеют пустой или
реализация по умолчанию. Давайте медленно создадим этот файл и обсудим
ключевые части, как вы это делаете.

Во-первых, вам нужно добавить вспомогательные поля для хранения взаимодействий с
Пользователь.

```Csharp
private DrawingPath currentPath;
private readonly IList<DrawingPath> paths = new
List<DrawingPath>();
```
Первый обработчик событий, который необходимо изменить, относится к событию ```StartInteraction```.

```Csharp
private void GraphicsView_StartInteraction(object sender,
TouchEventArgs e)
{
 currentPath = new DrawingPath(Colors.Black, 2);
 currentPath.Add(e.Touches.First());
 paths.Add(currentPath);
 Invalidate();
}
```
В этом методе вы сначала создаете новый экземпляр класса ```DrawingPath```,
назначение цвета и толщины. Их, конечно, можно расширить, чтобы
выбор пользователя, чтобы они могли иметь собственные цвета. Далее вы добавляете
сначала коснитесь текущего пути, чтобы у вас была первая точка взаимодействия.
Затем вы добавляете текущий путь в список всех путей, чтобы они могли
в конечном итоге будет отображаться на экране. Наконец, вы вызываете ```Invalidate```, который
вызовите метод ```Draw```, чтобы можно было рисовать пути.
Следующий обработчик событий, который необходимо изменить, относится к событию ```DragInteraction```.

```Csharp
private void GraphicsView_DragInteraction(object sender,
TouchEventArgs e)
{
 currentPath.Add(e.Touches.First());
 Invalidate();
}
```
В этом методе вы добавляете текущее касание к текущему пути и
снова вызовите Invalidate, чтобы вызвать метод Draw.
Последний обработчик событий, который необходимо изменить, относится к событию EndInteraction.

```Csharp
private void GraphicsView_EndInteraction(object sender,
TouchEventArgs e)
{
 currentPath.Add(e.Touches.First());
 Invalidate();
}
```

Это имеет ту же реализацию, что и событие ```DragInteraction```.
обработчик. Последний набор изменений, которые необходимо внести, находится внутри метода ```Draw```, поэтому вы можете на самом деле увидеть что-то на экране.

```Csharp
public void Draw(ICanvas canvas, RectF dirtyRect)
{
 foreach (var path in paths)
 {
 canvas.StrokeColor = path.Color;
 canvas.StrokeSize = path.Thickness;
 canvas.StrokeLineCap = LineCap.Round;
 canvas.DrawPath(path.Path);
 }
}
```
Этот метод перебирает все пути, которые вы создали
от взаимодействия с пользователем, установки цвета обводки, размера, а затем рисования
путь, созданный тремя обработчиками событий, которые вы только что
реализовано.

# Регистрация вашего виджета

Последней частью реализации виджета эскиза является
зарегистрируйте свое представление и модель представления в ```MauiAppBuilder```. Давайте
откройте файл ```MauiProgram.cs``` и добавьте следующие строки в
Метод ```CreateMauiApp```:

```Csharp
WidgetFactory.RegisterWidget<SketchWidgetView, SketchWidgetView
Model>(SketchWidgetViewModel.DisplayName);
builder.Services.AddTransient<SketchWidgetView>();
builder.Services.AddTransient<SketchWidgetViewModel>();

```
# Проведение тестового розыгрыша вашего виджета

Вы должны иметь возможность запускать свое приложение на всех платформах, добавлять виджет
типа Sketch на доску, а затем взаимодействуйте с виджетом, чтобы оставить причудливый
каракули. На рис. 13-3 показан новый виджет эскиза, визуализированный на доске.

![изображение](https://user-images.githubusercontent.com/26972859/231511276-f60bea00-acb1-4c59-8953-b50a0c66f080.png)

Рисунок 13-3. Виджет эскиза, показывающий мои ужасные навыки рисования
работает на macOS

# Краткое содержание

В этой главе у вас есть

• Узнали, что такое ```.NET MAUI Graphics```.

• Получил представление о некоторых возможностях, предоставляемых
```.NET MAUI Graphics```

• Создайте свой собственный виджет эскиза с помощью .NET MAUI.
Элемент управления ```GraphicsView```

В следующей главе вы будете

• Изучите концепции распространения вашего приложения.

• Узнайте о таких концепциях, как непрерывная интеграция и
непрерывная доставка для улучшения вашего развития
процессы

• Узнайте о связывании, что это такое и чем оно может быть полезно/
мешать тебе

• Узнайте, почему важно собирать аналитические и аварийные
информация

• Узнайте, почему вы можете захотеть рассмотреть возможность запутывания
ваш код

# Исходный код

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introducing-MAUI/tree/
main/ch13..

# Дополнительное задание

Подумайте о другой концепции, в которой вы можете использовать графику .NET MAUI. Может быть
идея управления графиком, которую я обсуждал, или даже просто отображение уровня заряда батареи в виджет или другую информацию об устройстве.





































































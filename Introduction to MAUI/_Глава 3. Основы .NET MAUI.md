# ГЛАВА 3

# Основы .NET MAUI

В этой главе вы проанализируете проект, созданный в главе 2  и углубитесь в детали каждой ключевой области. Основное внимание уделяется обеспечению хорошего обзора того, как выглядит отдельный проект .NET MAUI, где
расположены ключевые компоненты и некоторые распространенные способы их улучшения.

## Структура проекта

.NET MAUI обеспечивает поддержку нескольких платформ из одного
проекта. Цель состоит в том, чтобы позволить нам, как разработчикам, совместно использовать как можно больше кода и как можно больше ресурсов.
Вы, вероятно, много раз слышали термин «один проект» в свое время.
работа с .NET MAUI. Эта концепция является новой для мира .NET, поскольку
часть .NET MAUI. Его ключевая особенность заключается в том, что вы можете создавать приложения для несколько разных целей из, как вы уже догадались, одного проекта. Если вы когда-либо создавали приложения .NET, предназначенные для совместного использования кода, вы наверняка заметили
что каждое приложение, которое вы хотите создать и развернуть, требует собственного проекта. То же самое было и с ```Xamarin.Forms``` в том смысле, что у вас было бы по крайней мере один проект с вашим общим кодом, а затем один проект на определенной платформе. Теперь единый проект содержит как общий код, так и биты кода, зависящие от платформы.
Рисунок 3-1 показывает сравнение между старым отдельным проектом
подход в ```Xamarin.Forms``` и новый формат проекта ```.NET MAUI```.

![изображение](https://user-images.githubusercontent.com/26972859/231077346-7c1360b9-d65c-4993-9e7e-b4761b1069a2.png)

Рисунок 3-1. Сравнение проектов Xamarin.Forms с .NET MAUI
проект 

Давайте проверим проект, который вы создали в главе 2, чтобы вы могли
начать понимать, как .NET MAUI поддерживает несколько
платформы и как они связаны с общим кодом.

Новый проект имеет следующую структуру:

- ```Platforms/```: эта папка содержит весь код для конкретной платформы. Внутри этой папки находится набор папок, каждая с именем, которое относится к платформе, которую он поддерживает.
Таким образом, платформы ```/Android``` поддерживают Android платформа.

- ```Ресурсы/```: в этой папке хранятся все ваши ресурсы для приложения. Ресурс, как правило, все, что вы хотите встроить в приложение, которое
не является строго кодом, таким как изображение, файл шрифта или даже
аудио или видео файл.

В прошлом управление ресурсами всегда было проблемой, когда создание кроссплатформенных приложений. Например, при создании приложения для Android и iOS с помощью ```Xamarin.Forms``` может потребоваться четыре
или пять разных размеров каждого изображения, отображаемого в приложении.
```MauiProgram.cs```: в этом классе вы инициализируете приложение .NET MAUI. Он использует универсальный ```Host Builder```, который является подходом Microsoft к инкапсуляция требований приложения. Эти требования включают, но не ограничиваются внедрение зависимостей, ведение журнала и настройка.

- ```App.xaml.cs```: это основная точка входа в кроссплатформенное приложение.  Обратите внимание на эту строку кода из ```MauiProgram.cs``` включает наш класс App:

```Csharp
builder.UseMauiApp<App>();
```

- App.xaml: этот файл включает общие ресурсы пользовательского интерфейса.
которые можно использовать во всем приложении. Я буду описывать эти типы ресурсов более подробно в Главы 5 и 8.

- ```MainPage.xaml``` и ```MainPage.xaml.cs```: эти два файла объединить, чтобы составить первую страницу вашего приложения.

- ```AppShell.xaml``` и ```AppShell.xaml.cs```: эти два файла позволит вам определить, как ваше приложение будет уложено за счет использования концепции ```.NET MAUI```, называемой ```Shell```. Я подробно расскажу о ```Shell``` в главе 5. Обратите внимание, что везде, где вы видите файл ```.xaml```, обычно
связанный файл ```.xaml.cs```. Это связано с ограничениями того, что XAML может предоставлять; для этого требуется связанный файл C#, чтобы покрыть части, которые делает XAML не поддерживает. Я расскажу о XAML более подробно в главе 5.

Также стоит отметить, что вам не нужно писать XAML. Конечно, .NET MAUI и его предшественник ```Xamarin.Forms``` тесно связаны в XAML, но поскольку XAML в конечном итоге компилируется в C#, все, что можно создать в XAML, возможно и в C#. Вы будете просмотрите различные возможности для разработки ваших приложений в следующую главу (глава 4).

## /Platforms/Folder

Я упомянул, что код для конкретной платформы находится в папке ```Platforms```.
В то время как кросс-платформенные приложения обеспечивают хорошую абстракцию от платформы, которые мы хотим поддерживать, я по-прежнему считаю, что очень важно знать как ведут себя эти платформы. Давайте погрузимся и посмотрим на каждую папкy c платформой, чтобы понять, что происходит.

### Android

Внутри папки платформы ```Android``` вы увидите следующие файлы:
  
• ```MainApplication.cs```: это основная точка входа для
платформа Android. Изначально следует отметить, что это очень мало. То, что он делает, довольно важно, хотя; он отвечает за создание ```MauiApp``` с использованием класса ```MauiProgram```. Это мост между ```Android-приложение``` и вашим кроссплатформенным .NET MAUI кодом.
  
• ```MainActivity.cs```: активность в Android-разработке
тип компонента приложения, который предоставляет пользователю
интерфейс. ```MainActivity``` запускается, когда ваше приложение
загружено. Обычно это делается нажатием на значок приложения;
однако это также может быть вызвано уведомлением или другой источник.
  
• ```AndroidManifest.xml```: этот файл чрезвычайно важен.
Это то, как вы определяете компоненты, из которых состоит ваша
приложение, любые необходимые ему разрешения, информацию о версии приложения, минимальный и целевой SDK версии, а также любые аппаратные или программные функции, которые он требует.

### iOS

Внутри папки платформы iOS вы увидите следующие файлы:
• ```AppDelegate.cs```: этот класс позволяет вам отвечать на все
специфические для платформы части жизненного цикла приложения.
• ```Info.plist```: этот файл содержит конфигурацию приложение. Это похоже на файл ```AndroidManifest.xml```. Вы можете изменить версию приложения и указать причины, по которым ваш приложению требуется разрешение на использование определенных функций.
• ```Program.cs```: это основная точка входа.

### MacCatalyst

Внутри папки платформы ```MacCatalyst``` вы увидите следующие файлы.
Стоит отметить, что этот раздел практически идентичен предыдущему iOS.
раздел. Он был сохранен отдельно, чтобы обеспечить простую ссылку на то, что
папка платформы состоит из ```MacCatalyst```.
• ```AppDelegate.cs```: этот класс позволяет вам отвечать на все
специфические для платформы части жизненного цикла приложения.
• ```Info.plist```: этот файл содержит конфигурацию
приложение. Вы можете изменить версию приложения и указать причины, по которым вашему приложению требуется разрешение на использование определенных функций.
• ```Program.cs```: это основная точка входа.

### Tizen

Внутри папки платформы ```Tizen``` вы увидите следующие файлы:
• ```Main.cs```: это основная точка входа для вашего ```Tizen```.
приложение.
• ```tizen-manifest.xml```: этот файл очень похож на
Файл AndroidManifest.xml. Это то, как вы определяете
компоненты, из которых состоит ваше приложение, любые
необходимые разрешения, версия приложения
информацию, версию API Tizen и любое аппаратное обеспечение.
или функции программного обеспечения, которые он требует.

### Windows

Внутри папки платформы ```Windows``` вы увидите следующие файлы:
• ```app.manifest```: манифест пакета представляет собой XML.
документ, содержащий информацию, необходимую системе
для развертывания, отображения или обновления приложения Windows. Эта информация включает идентификатор пакета, зависимости пакета,
необходимые возможности, визуальные элементы и расширяемость
точки. Каждый пакет приложения должен включать один пакет
манифест.
• ```App.xaml``` и ```App.xaml.cs```: основные точки входа для
ваше приложение Windows
• ```Package.appxmanifest```: манифест приложения — это
XML-файл, который описывает и идентифицирует общие и
частные параллельные сборки, которые приложение
должен привязываться во время выполнения. Они должны быть
те же версии сборки, которые использовались для тестирования
приложение. Манифесты приложений также могут описывать
метаданные для файлов, которые являются частными для приложения.

# Краткое содержание

Фу! Это было похоже на многое! Я думаю, мне нужно сделать перерыв на чай! Не
беспокойтесь, однако; в то время как это дает обзор того, что представляет собой каждый из файлов за которые вы отвечаете, вы будете изменять большинство из них на протяжении всей книги c некоторыми практическими примерами, поэтому, если есть какие-либо моменты, которые не ясны, или
вы чувствуете, что вам нужно будет вернуться к ним, вы, безусловно, будете.

## /Resources/Folder
  
В папке «Ресурсы» вы храните все, что хотите включить в
ваше приложение, которое не является строго кодом. Пройдемся по каждому из
подпапки и ключевые типы ресурсов.
  
## Fonts
  
.NET MAUI позволяет встраивать собственные шрифты. Это особенно
удобно, если вы создаете приложение для определенного бренда. Убедитесь, что вы отображаете один и тот же шрифт на каждой платформе. Вы можете встроить либо ```Fonts True Type``` (файлы .ttf) или ```Fonts Open Type``` (файлы .otf).
  

**Примечание:** Слово предупреждения о шрифтах. Я настоятельно рекомендую вам
проверьте правила лицензирования шрифтов, прежде чем включать их в свой
приложение. Хотя есть сайты, которые дают возможность скачать
шрифты свободно, очень большой процент этих шрифтов обычно требует
платить за их использование.

Есть две части внедрения шрифта, чтобы его можно было использовать в
ваше приложение.
  
1. Файл шрифта должен находиться в этой папке (Ресурсы/Шрифты).  
По умолчанию шрифт будет автоматически включен как файл шрифта на основе следующей строки, которую можно находится внутри файла проекта (WidgetBoard.csproj):

<MauiFont Include="Ресурсы\Шрифты\*" />

Что делает строка выше, так это устанавливает ```Build Action```
файл, который вы только что включили, должен иметь тип ```MauiFont```.
Если вы хотите выполнить это вручную, вы можете щелкнуть правой кнопкой мыши файл в Visual Studio, нажать **Свойства**,
и внутри панели свойств установите **Build Action**
в ```MauiFont```.
  
2. Настройте шрифт.
При начальной загрузке приложения вам необходимо чтобы указать, какие шрифты вы хотите загрузить. 

Файл ```MauiProgram.cs```:
  
```Csharp
.ConfigureFonts (шрифты =>
{
  fonts.AddFont("Lobster-Regular.ttf", "Lobster");
});
```
В приведенном выше примере вы добавляете файл шрифта ```LobsterRegular.ttf``` в коллекцию шрифтов и назначаете ему псевдоним ```Лобстер```. Это означает, что вы можете просто использовать имя лобстера при обращении к файлу в вашем
приложение.
  
### Images
  
Практически каждое создаваемое вами приложение будет включать в себя несколько изображений. Каждая платформа, которую вы хотите поддерживать, имеет свои собственные правила относительно размеров изображений,
вам необходимо предоставить, чтобы изображение отображалось как четкое и четкое на многих устройствах, на которых они работают. Возьмем, к примеру, iOS. Для обеспечения круглосуточного
пикселей в вашем приложении, вы должны указать три разных размера изображения:
24х24, 48х48 и 72х72. Это связано с разным DPI для устройств.
Apple строит. Устройства Android следуют аналогичному шаблону, но значения DPI различаются.
одинаковый. Это аналогично для Windows.
На рис. 3-2 показан пример изображения, которое будет отображаться в режиме 24x24 пикселей. Обратите внимание, что хотя Windows показывает три размера, это основано только на
рекомендации по попытке охватить наиболее распространенные настройки. Действительно, устройства Windows могут иметь свои DPI намного больше. 

Рисунок 3-2 показывает требуемые размеры изображений, необходимые для всех поддерживаемых платформ, чтобы визуализировать изображение размером 24x24 пикселя.
  
  ![изображение](https://user-images.githubusercontent.com/26972859/231078950-26519e2f-b6b6-4c12-90cb-73bc51252bc8.png)

Рисунок 3-2. Требуемые размеры изображений на разных платформах
 
Вы можете видеть из рисунка выше, что это может стать очень болезненным.
быстро, если в вашем приложении много изображений, каждое из которых требует как минимум
пять различных размеров должны быть сохранены. К счастью, .NET MAUI дает нам
возможность предоставить одно масштабируемое векторное изображение (SVG), и оно будет генерировать необходимые образы для всех платформ, когда приложение
скомпилировано. Я не могу передать вам, как счастливы все мы, старожилы ```Xamarin.Forms```, этой новой части функциональности!
  
В настоящее время, если изображение SVG имеет правильный исходный размер,
вы можете просто поместить изображение в папку ```/Resources/Images/``` и оно
просто начнет работать в вашем приложении. Аналогично тому, как шрифты
автоматически подхватываются, вы также можете увидеть, как обрабатываются изображения заглянув внутрь файла проекта и наблюдая за строкой
 
 <MauiImage Include="Resources\Images\*" />
  
**Замечание:** .NET MAUI не отображает SVG напрямую, а создает изображения PNG. из SVG во время компиляции. Это означает, что когда вы
ссылаясь на желаемое изображение, оно должно иметь расширение ```.png```.
Например, при встраивании изображения с именем ```image.svg``` в код
вы называете его ```image.png```.
  
Если содержимое SVG не нужного размера, то можно добавить некоторую конфигурацию, чтобы сообщить инструментам, какого размера должно быть изображение. Для это изображение не должно быть добавлено в папку ```/Resources/Images/``` как инструменты в конечном итоге будут генерировать дубликаты, и невозможно сказать, какие один победит. Вместо этого вы можете просто добавить изображение в /Resources/
папку, а затем добавьте следующую строку в файл проекта:
  
```xml
<MauiImage Include="Resources\image.svg" BaseSize="24,24" />
```
  Приведенный выше код будет обрабатывать содержимое файла ```image.svg``` как
24x24 пикселя, а затем масштабироваться для каждой платформы в зависимости от этого размера.
  
### Raw
  
Ваш последний тип ресурсов для встраивания — необработанные файлы. Это по существу означает то, что встроено, может быть загружено во время выполнения. Типичный пример этого заключается в предоставлении некоторых данных для предварительной загрузки в приложение при первом запуске
  
## С чего начать?
  
Приложения .NET MAUI имеют единую общую точку входа.
на всех платформах. Это дает нам возможность централизовать большую часть
процесс инициализации для наших приложений, поэтому запишите его только один раз. Вы заметили, что в каждой из основных точки входа, описанные в предыдущем разделе, все они называются ```MauiProgram.CreateMauiApp();```. Это основная точка входа в ваш .NET MAUI и общее приложение. Метод ```CreateMauiApp``` позволяет загрузить ваше приложение.
Начальная загрузка относится к самозапускающемуся процессу, который должен продолжаться или расти без внешнего участия (цитата из Википедии). Это значит, что ваша реализация в этом методе отвечает за настройку
приложение от настройки ведения журнала, общей конфигурации приложения и
регистрация реализаций, которые будут обрабатываться с внедрением зависимостей. Это одно из больших улучшений .NET MAUI по сравнению с ```Xamarin.Forms```. Это делается через ```Generic Host Builder```.
  
## Generic Host Builder
  
Я упоминал еще в главе 1, что одно из преимуществ, которое дает переход к .NET MAUI — мощное внедрение зависимостей. Общий ```Host Builder``` опробован и протестирован с помощью других платформ .NET, таких как
```ASP .NET Core```, и, к счастью, он стал доступен для всех приложений типов сейчас. Прежде чем мы перейдем к тому, как работает ```Generic Host Builder```. Давайте посмотрим на что такое внедрение зависимостей и почему вы должны его использовать.

# Что такое внедрение зависимостей?
 
**Внедрение зависимостей** (DI) — это шаблон проектирования программного обеспечения, направленный на снижение жестко закодированные зависимости в программном приложении. Зависимость объект, от которого зависит другой объект. Эта жестко запрограммированная зависимость подход называется тесно связанным. Давайте работать через пример, чтобы показать, как и почему он называется так, и как вы можете удалить потребность в жестко закодированных зависимостях, что делает ваш дизайн свободным в паре.
Итак, моя жена — фантастический пекарь. Она печет эти красивые, вкусные
торты, и это главная причина, по которой я так сильно набрала вес в последнее время. Я собираюсь использовать процесс выпечки торта, чтобы показать эту концепцию зависимости.
  
```Csharp
public class Baker
{
 public Cake Bake()
 {

 }
}
```
  
Приведенный выше код выглядит относительно просто, не так ли? Она печет
торт. Теперь давайте подумаем, как она могла бы приготовить торт. Она
нужен способ поиска ингредиентов, их взвешивания, смешивания и
наконец, испечь их. Мы заканчиваем что-то вроде
  
```Csharp
public class Baker
{
 private readonly WeighingScale weighingScale = new WeighingScale();
 private readonly Oven oven = new Oven();
 private readonly MixingMachine mixingMachine = new MixingMachine();
 private readonly IngredientsProvider ingredientsProvider = new 
 IngredientsProvider();
 
 public Cake Bake()
 {
  Ingredient ingredient = ingredientsProvider.Provide();
  weighingScale.Weigh(ingredient);
 }

}
```
  Мы видим, что для того, чтобы пекари выполняли свою работу, им нужно знать
обо всех этих различных единицах оборудования. А теперь представьте, что
Весы ломаются, и предоставляется замена. Бейкеру еще понадобится
для взвешивания ингредиентов, но не заботится о том, как это взвешивание выполняется. Представьте, что новые весы ```WeighingScale``` являются цифровыми и теперь требуют батареек. Есть несколько причин, по которым мы хотим отказаться от жестко закодированных зависимостей, как в нашем примере с Бейкером. Если бы мы заменили весы ```WeighingScale``` на другой реализации, нам пришлось бы изменить Класс пекаря.

• Если у весов есть зависимости (например, батареи в наших новых цифровых весах) их также необходимо настроить в классе Бейкера.
• Это становится более трудным для модульного тестирования, потому что
Baker создает зависимости и, следовательно, модульный тест
приведет к необходимости тестировать гораздо больше.

Внедрение зависимостей может помочь нам решить вышеуказанные проблемы путем
что позволяет нам достичь инверсии управления  (IoC - Inversion of Control). Инверсия контроля
по существу означает, что мы инвертируем знание зависимости от пекаря, знающего о весах, до них, знающих о что-то, что может взвешивать ингредиенты, но не реальную реализацию.

Это делается с помощью введения интерфейса, который мы будем называть
```IWeighingScale```.
  
```Csharp
public class Baker
{
 private readonly IWeighingScale weighingScale;
 private readonly Oven oven = new Oven();
 private readonly MixingMachine mixingMachine = new MixingMachine();
 private readonly IngredientsProvider ingredientsProvider = new IngredientsProvider();
 
 public Baker(IWeighingScale weighingScale)
 {
  this.weighingScale = weighingScale;
 }

 public Cake Bake()
 {
  Ingredient ingredient = ingredientsProvider.Provide();
  this.weighingScale.Weigh(ingredient);
 }
}
```
Теперь наш ```Backer``` знает об интерфейсе для чего-то, что может весить
их ингредиенты, но не фактическая вещь, которая делает взвешивание. Этот
означает, что в сценарии, когда весы ломаются и новый
один поставляется, в классе ```Baker``` нет никаких изменений для обработки
этот новый масштаб. Вместо этого он регистрируется как часть запуска приложения или процесс начальной загрузки. Конечно, мы могли бы и должны следовать тому же подход для других наших зависимостей. Еще одна концепция, которую я представил здесь, — это использование конструктора инъекция. ```Внедрение конструктора``` — это процесс предоставления зарегистрированного
зависимости при создании экземпляра нашего ```Baker```. Итак, когда наш ```Backer```
создается, ему передается экземпляр ```WeighingScale```.
Если у вас есть опыт работы с ```Xamarin.Forms```, вы пришли
через ```DependencyService```. Это обеспечило механизм управления
внедрение зависимостей внутри приложения; однако он подвергся критике
в прошлом из-за отсутствия поддержки внедрения конструктора. Это не значит
не удалось добиться внедрения конструктора в ```Xamarin.Forms```
приложений, но для этого требовалось использование стороннего пакета, и есть
много отличных пакетов там! Теперь все это встроено в .NET MAUI.
  
## Регистрация зависимостей
  
В предыдущем разделе я обсуждал, как свести к минимуму зависимости в вашей кодовой базе. Теперь разберемся, как настроить эти зависимости, чтобы наследникам были даны правильные реализации.
Реализации, которые вы регистрируете в универсальном компоновщике хостов,
называемые услугами и работой по предоставлению тон реализует
для наследников называется ```ServiceProvider```. Вы можете зарегистрировать свои сервисы с использованием подписки.
  
## AddSingleton

Одноэлементная регистрация означает, что всегда будет только **один экземпляр** объекта. Итак, на примере нашего пекаря, которому нужно использовать ```IWeighingScale```, мы регистрируем его следующим образом:
  
```Csharp
builder.Services.AddSingleton<IWeighingScale, WeighingScale>();
```
Затем каждый раз, когда разрешается ```IWeighingScale```, мы будем
снабжены одним и тем же экземпляром. Это подходит для примера с весами
потому что мы используем один и тот же на протяжении всего процесса выпечки.
  
**Замечание**: Крайне маловероятно, что вам когда-либо понадобится регистрировать модель представления как синглтон. Это может ввести элементы поведения, которые вы
скорее всего, не ожидают, кроме того, что вы можете запустить
риск утечки памяти.
  
## AddTransient
  
Временная регистрация противоположна синглтону. Каждый раз, когда
реализация разрешается, создается и предоставляется **новый экземпляр**. Так
на примере нашего пекаря, которому нужно использовать ```IWeighingScale```, мы
зарегистрировать его следующим образом:
  
```Csharp
builder.Services.AddTransient<IWeighingScale, WeighingScale>();
```
Как уже упоминалось, каждый раз, когда ```IWeighingScale``` разрешается, мы
будем снабжены новым экземпляром. Лучшим примером здесь может быть жиронепроницаемая бумага, которой застелены формы для кексов. Они используются один раз и выбрасываются.
  
## AddScoped
  
Ограниченная регистрация находится где-то посередине ```AddTransient``` и
```AddTransient```. Для «области действия» будет предоставлен один экземпляр, а затем, когда создается новая область, новый экземпляр будет предоставлен на весь срок службы тот объем.
  
```Csharp
builder.Services.AddScoped<IWeighingScale, WeighingScale>();
```
Этот тип регистрации гораздо лучше подходит для веб-приложения.
куда приходят запросы, а область действия будет представлять один запрос.

В мире мобильных и настольных компьютеров ваше приложение обычно имеет одно состояние и поэтому менее вероятно, что потребуется регистрация с ограниченной областью действия. В настоящее время ```.NET MAUI``` не обеспечивает автоматического создания областей, но у вас есть
возможность создавать свои собственные с помощью интерфейса ```IServiceScopeFactory``` и в конечном счете его реализация.
  
# Жизненный цикл приложения
  
К сожалению, нет двух платформ с одинаковым набором действий или жизненным циклом события, такие как запуск приложения, работа в фоновом режиме или закрытие.

Именно здесь кроссплатформенные фреймворки дают нам солидный набор инкапсулированных событий для покрытия большинства сценариев. Есть четыре основных состояния приложения в приложении .NET MAUI.
  
## Состояния приложения
  
Это состояния приложения:

• ````Не запущено````: это означает, что приложение
не запускался и не загружался в память. Этот
как правило, когда приложение было установлено, устройство включено, приложение был закрыт пользователем, или операционная система
закрыл приложение, чтобы освободить некоторые ресурсы.
• ```Работает```: это означает, что приложение видимо и
в фокусу.
• ```Деактивировано```: это означает, что приложение не больше сфокусированы, но все еще могут быть видны. На мобильном это может означать, что операционная система показывает предупреждение о запросе разрешения (например, приложение запрашивает разрешение на использование камеры) или подобное.
• ```Остановлено```: это означает, что приложение больше не
видимый.
  
Теперь вы можете видеть, как приложение .NET MAUI перемещается между
выше четырех состояний и событий, которые инициируются приложением.
На рис. 3-3 показаны возможные состояния, которые может принимать приложение
```.NET MAUI``` в течение своей жизни и как она переходит между этими состояниями.
  
![изображение](https://user-images.githubusercontent.com/26972859/231094374-72c17a79-ea47-424c-b2c3-5ddfd20471e9.png)

Рисунок 3-3. Диаграмма жизненного цикла состояния приложения
  
Прежде чем мы углубимся в детали каждого из запускаемых событий,
между переходами состояний, я должен дать вам некоторые сведения о
как к ним можно получить доступ и почему. Чтобы получить доступ к этим событиям, вы должны получить доступ к классу ```Window```. Конечно, это не общепринятая концепция Window в мобильном приложении, но вы должны понимать, что вы работаете с кросс-платформенной структурой и, следовательно, подход, который подходит как для настольных компьютеров, так и для мобильных устройств. Я вижу это так: мобильное приложение — это
однооконное приложение, а ```Desktop```, скорее всего, будет многооконным.
  
# События жизненного цикла
  
Теперь перейдем к событиям, которые перемещают приложение между состояниями.

• ```Created```: это событие вызывается после окна платформы был создан. Обратите внимание, что окно может быть не видно еще.
• ```Активировано```: это событие возникает, когда окно
сфокусированное окно.
• ```Деактивировано```: это событие возникает, когда окно
больше не сфокусированное окно. Обратите внимание, что окно
еще может быть видно.
• ```Stopped```: это событие возникает, когда окно закрыто.
дольше виден. Приложение может возобновить работу с этого
состоянии, но это не гарантируется, поэтому рекомендуется
вы отменяете любые длительные процессы или что-то еще
что мпотребляют ресурсы на устройстве. Мобильный
операционные системы гораздо строже в отношении того, что может
происходить в фоновом режиме.
• ```Возобновлено```: это событие возникает, когда приложение
возобновляется из состояния ```Stopped```. Рекомендуется
для повторной подготовки вашего приложения к полному использованию (например,
подписывайтесь на события или сообщения, обновляйте все видимые содержание).
• ```Уничтожение```: это событие возникает, когда платформа
окно уничтожается и удаляется из памяти.
Рекомендуется отписаться от событий или cообщений.
  
# Обработка событий жизненного цикла
  
По умолчанию приложение .NET MAUI не дает вам доступа к жизненному циклу.
события; это то, на что вы должны согласиться. Чтобы зарегистрироваться, вы должны измените свой класс приложения.

Откройте Visual Studio. Вам нужно добавить новый класс в свой проект и
назовите его ```StateAwareWindow```. Ваш новый класс нужно будет изменить, чтобы он выглядит следующим образом:
  
```Csharp
public class StateAwareWindow: Window
{
 public StateAwareWindow() : base()
 {
 }

 public StateAwareWindow(Page page) : base(page)
 {
 }

 protected override void OnCreated()
 {
 // Initialise our application
 }

}
```
Внутри вашего приложения вы можете переопределить все методы, которые будут
выполняться при возникновении определенного события. Каждый метод переопределения следует за именами событий, как описано ранее, с префиксом
```On```. Следовательно, для обработки события ```Activated``` вы переопределяете метод ```OnActivated```.
Последний шаг — использовать новый класс, поэтому внутри вашего
 ```App.xaml.cs``` добавьте следующее:
  
```Csharp
protected override Window CreateWindow(IActivationState activationState)
{
  return new StateAwareWindow(MainPage);
}
```
Это создаст новый экземпляр ```StateAwareWindow``` и передаст ему
ссылка на главную страницу приложения. Если вы не передаете ссылку
к реализации ```Page to the Window```, вы столкнетесь с исключениями.
  
# Межплатформенные сопоставления с событиями жизненного цикла платформы
  
Я твердо верю, что, несмотря на то, что .NET MAUI предоставляет нам
эти события, вы должны понимать, как они соотносятся с лежащими в их основе
платформы. Если вы понимаете, что вызывается на конкретной платформе
С другой стороны, это может действительно помочь диагностировать вещи, когда они идут не так, как надо, или, возможно,
указать вам направление лучшего подхода для ваших сценариев.
Давайте рассмотрим, как события жизненного цикла .NET MAUI сопоставляются с
специфичные для платформы события, а затем показать биты, которые не отображаются, если вам когда-нибудь понадобится их использовать. См. Таблицу 3-1.
  
  **Таблица 3-1**. Межплатформенные события жизненного цикла, сопоставленные с конкретными для платформы событиями
  
   |Событие|Android|iOS/MacCatalyst|Windows|
   |:---|:----|:---|:---|
   |Создано|ПриПослеСоздания|ЗавершеноЗапуск|Создано|
   |Activated|OnResume|OnActivated|Activated(код активирован и указатель активирован)|
   |Деактивировано|OnPause|OnResignActivation|Активировано|(Деактивировано)|
   |Остановлено|Приостановке|DidEnterBackground|Видимость изменена|
   |Возобновлено|При перезапуске|WillEnterForeground|Возобновлено|
   |Уничтожение|ПриУничтожении|Будет Завершено|Закрыто|
  
Этот список может не дать слишком много смысла прямо сейчас, и я бы не стал
беспокойтесь о необходимости знать это. Цель здесь состоит в том, чтобы предоставить вам с быстрым поиском, чтобы иметь возможность затем исследовать, есть ли какие-либо события жизненного цикла идет не так или, возможно, не подходит для вашего решения.
  
## События жизненного цикла для конкретных платформ

На самом деле существует множество событий жизненного цикла платформы, которые .NET MAUI не сопоставляется. Что предоставляет .NET MAUI, так это набор событий жизненного цикла, которые отображают последовательно на всех платформах. Остальные в этом разделе действительно индивидуально для каждой отдельной платформы. Не буду описывать все подробности каждого отдельного события; однако я расскажу, как использовать один из них, чтобы
вы будете знать, как использовать событие, которое лучше подходит для вашего варианта использования.

**Замечание:** При поиске информации о конкретной платформе событие, не стесняйтесь искать специфичные для .NET MAUI документация. У вас есть возможность использовать API-интерфейсы платформы. Ты должен иметь возможность искать информацию в контексте Android или iOS, и код должен быть относительно легко переведен на C#.

Чтобы зарегистрироваться на мероприятие для конкретной платформы, вам необходимо использовать метод ```ConfigureLifecycleEvents``` в классе ```MauiAppBuilder```.

Давайте рассмотрим конкретный пример для каждой платформы. Код в каждом из
следующие примеры в основном одинаковы, но дублирование было сохранено показать большую картину. Я выделил различия жирным шрифтом, чтобы показать
ключевые отличия.
  
# Андроид
  
Чтобы получить уведомление о событии жизненного цикла Android, вы вызываете метод ```ConfigureLifecycleEvents``` для объекта ```MauiAppBuilder```. Ты
затем можно использовать метод ```AddAndroid``` и указать события, которые вы
хотите обращаться и как вы хотите обращаться с ними.
  
```Csharp
using Microsoft.Maui.LifecycleEvents;
namespace WidgetBoard;
public static class MauiProgram
{
 public static MauiApp CreateMauiApp()
 {
 var builder = MauiApp.CreateBuilder();
 builder
 .UseMauiApp<App>()
 .ConfigureLifecycleEvents(events =>
  {
  #if ANDROID
  events.AddAndroid(lifecycle=>
  lifecycle.OnStart((activity) =>
  OnStart(activity)));
  static void OnStart(Activity activity)
  {
  // Perform your OnStart logic
  }
  #endif
  });
 return builder.Build();
 }
}
   
```
Для получения дополнительной информации о доступных событиях жизненного цикла я рекомендую просмотр следующих страниц документации:

Microsoft: https://learn.microsoft.com/dotnet/maui/fundamentals/app-lifecycle#android

Android: https://developer.android.com/guide/components/activities/activity-lifecycle


##  iOS and MacCatalyst
  
Чтобы получить уведомление о событии жизненного цикла iOS, вы вызываете метод
```ConfigureLifecycleEvents``` для объекта ```MauiAppBuilder```. Затем вы можете использовать метод ```AddiOS``` и указать желаемые события.
обращаться и как вы хотите обращаться с ними.
  
```Csharp
using Microsoft.Maui.LifecycleEvents;
namespace WidgetBoard;
public static class MauiProgram
{
 public static MauiApp CreateMauiApp()
 {
 var builder = MauiApp.CreateBuilder();
 builder
 .UseMauiApp<App>()
 .ConfigureLifecycleEvents(events =>
  {
  #if IOS || MACCATALYST
  events.AddiOS(lifecycle =>
  lifecycle.OnActivated((app) =>
  OnActivated(app)));
  static void OnActivated(UIKit.UIApplication
  application)
  {
  // Perform your OnActivated logic
  }
  #endif
  });
 return builder.Build();
 }
}
```
  
Для получения дополнительной информации о доступных событиях жизненного цикла я рекомендую
просмотр следующих страниц документации:
Майкрософт: https://learn.microsoft.com/dotnet/maui/
fundamentals/app-lifecycle#ios
iOS: https://developer.apple.com/documentation/uikit/app_and_
environment/managing_your_app_s_life_cycle?language=objc
  
# Windows
  
Чтобы получить уведомление о событии жизненного цикла Windows, вы вызываете метод ```ConfigureLifecycleEvents``` для объекта ```MauiAppBuilder```. Затем можно использовать метод ```AddWindows``` и указать события, которые вы
хотите обращаться и как вы хотите обращаться с ними.
  
```Csharp
using Microsoft.Maui.LifecycleEvents;
namespace WidgetBoard;
public static class MauiProgram
{
 public static MauiApp CreateMauiApp()
 {
 var builder = MauiApp.CreateBuilder();
 builder
 .UseMauiApp<App>()
 .ConfigureLifecycleEvents(events =>
 {
#if WINDOWS
 events.AddWindows(lifecycle =>
 lifecycle.OnActivated((window, args) =>
OnActivated(window, args)));
 static void OnActivated(Microsoft.
UI.Xaml.Window window, Microsoft.UI.Xaml.
WindowActivatedEventArgs args)
 {
 // Perform your OnActivated logic
 }
#endif
 });
 return builder.Build();
 }
}  
```
  
Для получения дополнительной информации о доступных событиях жизненного цикла я рекомендую
проверить следующую страницу документации:
Майкрософт: https://learn.microsoft.com/dotnet/maui/
fundamentals/app-lifecycle#windows
  
**Замечание:** Возможно, вы заметили использование операторов #if. Из-за
характер компиляции для нескольких платформ в одном проекте, вы
потребуется написать код для конкретной платформы. Если, как и я, вам не нравится
оператор #if или вы хотели бы свести его использование к минимуму,
тогда не бойтесь: мы подробнее рассмотрим, как свести его к минимуму в
Глава 13.

# Краткое содержание
  
В этой главе:

• Познакомились с основными компонентами .NET MAUI. приложение

• Узнали о процессе запуска

• Узнали о жизни приложения .NET MAUI.
  
В следующей главе вы будете:

• Узнайте о различных возможностях, которые у вас есть
для проектирования своих приложений

• Решите, какую архитектуру использовать

• Пройдитесь по конкретному примеру, создав свой виджет часов

• Узнайте, как оптимизировать внедрение с помощью пакетов NuGet  

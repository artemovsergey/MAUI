# ГЛАВА 4

# Архитектура, которая вам подходит

В этой главе вы познакомитесь с некоторыми возможными архитектурными шаблонами, которые можно использовать для создания приложений ```.NET MAUI```. Цель состоит в том, чтобы предоставить вам достаточно подробностей, чтобы помочь вам найти архитектуру, которая лучше всего подходит тебе. Я хочу отметить, что нет правильных ответов относительно какую архитектуру выбрать. Лучший вариант - пойти с тем, что вы чувствую, что это принесет пользу вам и вашей команде.

Я стремлюсь разрушить следующие мифы в ходе этой главы:

- «Вы вынуждены использовать XAML».

- «Вы вынуждены использовать MVVM».

Кажется, существует распространенное заблуждение, что ```Xamarin.Forms``` и
.NET MAUI в основном построен на использовании только XAML и MVVM. Пока
это наиболее распространенный подход разработчиков, он не навязывается
на нас.

## Мерная линейка

Вы создадите один и тот же элемент управления с каждым из вариантов, чтобы обеспечить способ сравните отличия. Элемент управления, который вы будете создавать, представляет собой ```ClockWidget```.

Целью этого контроля является выполнение следующих действий:

- Отображение текущего времени в вашем приложении.
- Обновление времени каждую минуту.

На рис. 4-1 показана очень грубая схема управления с током.

Дата и время. Вы уберете это позже с возможностью форматирования даты
и информацию о времени в Главе 5, но сейчас давайте просто сосредоточимся на ограниченном, например, чтобы выделить различия в параметрах. Рисунок 4-1 показывает, как ```ClockWidget``` будет отображаться в вашем приложении, когда вы закончите с этой главой.

![изображение](https://user-images.githubusercontent.com/26972859/231101118-c96f6a35-9a87-4899-9c95-3c9ec04a662c.png)

Рисунок 4-1. Схема того, как будет отображаться элемент управления ClockWidget

## Предпосылки

Прежде чем приступить к работе с каждой из архитектур, которые вы будете рассматривать в этой главе вам нужно немного подготовиться к фоновой настройке.

Вам нужно добавить один новый класс. Эта реализация позволит ваши виджеты, чтобы запланировать действие работы, которое будет выполнено после определенного период времени. В вашем сценарии ```ClockWidget``` вы можете запланировать обновление пользовательского интерфейса. Давайте добавим этот класс планировщика в ваш проект.

- Щелкните правой кнопкой мыши проект ```WidgetBoard```.
- Выберите «Добавить» ➤ «Класс».
- Дайте ему имя ```Scheduler```.
- Нажмите Добавить.

Вы хотите изменить содержимое файла, чтобы оно выглядело следующим образом:

```Csharp
using System.Threading.Tasks;
public class Scheduler
{
 public void ScheduleAction(TimeSpan timeSpan, Action action)
 {
 Task.Run(async () =>
    {
    await Task.Delay(timeSpan);
    action.Invoke();
    });
 }
}
```

В следующих разделах вы будете рассматривать примеры кода, а не
чем реализовать их напрямую. Это направлено на обеспечение некоторых сравнений, чтобы вы могли узнать, что будет хорошо подходить для вас, поскольку вы создавайте свои приложения и развивайтесь как кроссплатформенный разработчик. В конце главы, вы возьмете выбранный вами подход и добавите его в свой приложение, чтобы вы могли видеть окончательный результат вашего ```ClockWidget```.

# Представление модели ViewModel (MVVM)

```Model View ViewModel``` — это шаблон проектирования программного обеспечения, ориентированный на отделение пользовательского интерфейса (представления) от бизнес-логики (модели). Это
достигается это с использованием промежуточного слоя (ViewModel). MVVM
позволяет четко разделить представление и бизнес-логику. Рисунок 4-2
показывает четкое разделение между компонентами MVVM
архитектурой.

![изображение](https://user-images.githubusercontent.com/26972859/231101565-52e3465a-79fc-4f29-ae59-6c08bccd94fb.png)
Рисунок 4-2. Обзор шаблона MVVM

Результат создания этого разделения между пользовательским интерфейсом и бизнес-логикой приносит ряд преимуществ:

- Облегчает модульное тестирование
- Позволяет заменять представления или даже перезаписывать их, не затрагивая другие части
- Поощряет повторное использование кода
- Предоставляет возможность отделить разработку пользовательского интерфейса от разработка бизнес-логики

Ключевой частью любого шаблона проектирования является знание того, где найти части кода, чтобы он подходил и соблюдал правила. Давайте более подробно рассмотрим каждой из трех ключевых частей этого шаблона.

# Model

Модель — это место, где вы храните свою бизнес-логику. Обычно он загружается
из базы данных/веб-сервиса среди многих других вещей.
Для вашей бизнес-логики вы будете полагаться на класс ```Scheduler```.
который вы создали ранее в разделе «Предварительные требования» этой главы.

# View

Представление определяет макет и внешний вид приложения. Это то, что
пользователь будет видеть и взаимодействовать. В .NET MAUI представление обычно написаны на XAML, где это возможно, но будут случаи, когда логика
в ```code-behind``` нужно будет написать. Вы узнаете об этом позже в этой
главе; вам вообще не нужно использовать XAML, поэтому, если вы не чувствуете, что XAML прямо для вас, не бойтесь.
Представление в .NET MAUI обычно представляет собой ```ContentPage``` или реализацию, который будет наследоваться от ```ContentPage``` или ```ContentView```. Вы используете ```ContentPage```, если
вы хотите отобразить полную страницу в своем приложении (в основном представление, которое заполнит приложение). Вы используете ```ContentView``` для чего-то меньшего (например, для виджета!).
Для вашей реализации вы будете наследоваться от ```ContentView```.
В главе 2 я говорил, что большинство XAML-файлов имеют
связанный файл C#. Представление на основе XAML не является исключением из этого правила. Имея в виду, давайте посмотрим на содержимое, которое вам нужно поместить в каждый из файлов.

# XAML

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentView xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.ClockWidget">

 <ContentView.BindingContext>
    <viewmodels:ClockWidgetViewModel />
 </ContentView.BindingContext>

 <Label Text="{Binding Time}"
        FontSize="80"
        VerticalOptions="Center"
        HorizontalOptions="Center" />

</ContentView>
```

## C# (код программной части)

Следующий код уже создан для вас .NET MAUI. Он включен для справки.

```Csharp
namespace WidgetBoard;

public partial class ClockWidget : ContentView
{
 public ClockWidget()
 {
    InitializeComponent();
 }
}
```
Приведенный выше вызов метода ```InitializeComponent``` необходим, когда
создание представлений на основе XAML. Это приводит к загрузке XAML и
анализируется в экземпляр элементов управления, которые были определены в
XAML-файл.

# ViewModel

```ViewModel``` действует как мост между представлением и моделью. Ты
раскрывать свойства и команды в ```ViewModel```, которые ```View``` будет
связываются. Для сравнения с созданием приложений только с программным обеспечением мы могли бы сказать, что свойства в основном сопоставляются со ссылками на элементы управления и команды являются событиями. Связывание обеспечивает механизм для как ```View```, так и ```ViewModel``` для отправки и получения обновлений.

Чтобы ваша ```ViewModel``` уведомляла ```View``` об изменении свойства
и поэтому представление обновит значение, отображаемое на экране, вы
необходимо использовать интерфейс ```INotifyPropertyChanged```. Это предлагает
одно событие ```PropertyChanged```, которое вы должны реализовать и в конечном итоге поднять, когда значение, связанное с данными, изменилось. Всем этим занимается Механизм привязки XAML, который вы более подробно рассмотрите в следующей главе. Давайте создадим ваш класс ```ViewModel```, а затем разберем, что продолжается.

```Csharp
public class ClockWidgetViewModel : INotifyPropertyChanged
{

 public event PropertyChangedEventHandler PropertyChanged;
 private readonly Scheduler scheduler = new();
 private DateTime time;

 public DateTime Time
 {
    get
    {
        return time;
    }
    set
    {
        if (time != value)
        {
            time = value;
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Time)));
        }
    }
}

public ClockWigetViewModel()
 {
    SetTime(DateTime.Now);
    }
    public void SetTime(DateTime dateTime)
    {
    Time = dateTime;
    scheduler.ScheduleAction(TimeSpan.FromSeconds(1),() => SetTime(DateTime.Now));
 }
}
```

У вас есть
• Создан класс ```ClockWidgetViewModel```.
• Реализован интерфейс ```INotifyPropertyChanged```.
• Добавлено свойство, которое при установке будет проверять, его значение действительно изменилось, и если да, поднимите cобытие ```PropertyChanged``` с именем свойства что изменилось
• Добавлен метод установки свойства ```Time``` и повтора каждую секунду, чтобы виджет выглядел как часы считая

# Обновление представления модели (MVU)

```Model View Update``` — это шаблон проектирования программного обеспечения для создания интерактивных приложений. Концепция исходит из языка программирования Elm.
Как следует из названия, ```MVU``` состоит из трех ключевых частей:
• Model: это состояние вашего приложения.
• View: это визуальное представление вашего состояния.
• Update: это механизм обновления вашего состояния.

На рис. 4-3 показано, как каждый из этих компонентов соотносится и взаимодействует.
друг с другом.  

![изображение](https://user-images.githubusercontent.com/26972859/231108112-c6062936-3975-4593-919e-f7a61de4c338.png)

Рисунок 4-3. Обзор шаблона MVU

Этот шаблон предлагает несколько преимуществ:
• Четко определенные правила относительно того, где государству разрешено
быть обновленным
• Простота тестирования

Ключевой частью любого шаблона проектирования является знание того, где найти части
кода, чтобы он подходил и соблюдал правила. Давайте более подробно рассмотрим
каждой из трех ключевых частей этого шаблона.

# Начало работы с Comet

Во-первых, вы должны установить шаблоны проекта ```Comet```. Для этого откройте
окно терминала и выполните следующую команду:

```dotnet new –install Clancey.Comet.Templates.Multiplatform```

Это установит шаблон, чтобы вы могли создать новый проект. К сожалению, это достаточно отличается от проекта ```WidgetBoard```, который у вас есть. работал с до сих пор.
Далее необходимо создать проект. Это снова делается через терминал
на данный момент:

```dotnet new comet -–name WidgetBoard.Mvu```

Это создаст новый проект, который вы можете начать изменять.

## Добавление вашей реализации MVU

Идите вперед и откройте проект, который вы только что создали. Первое, что вам нужно сделать, это использовать тот же класс ```Scheduler```, который вы создали в примере модели MVVM для вашего MVU выполнение. Вот еще раз для облегчения жизни:

```Csharp
public class Scheduler
{
 public void ScheduleAction(TimeSpan timeSpan,Action action)
 {
    Task.Run(async () =>
    {
    await Task.Delay(timeSpan);
    action.Invoke();
    }
 }
}

```
Наконец, продолжайте и создайте свой класс ```ClockWidget```:

```Csharp
public class ClockWidget : View
{
 [State]
 readonly Clock clock = new();
 [Body]
 View body()
 => new Text(() => $"{clock.Time}")
 .FontSize(80)
 .HorizontalLayoutAlignment(LayoutAlignment.Center)
 .VerticalLayoutAlignment(LayoutAlignment.Center);
 
    public class Clock : BindingObject
    {
    readonly Scheduler scheduler = new();
    public DateTime Time
    {
    get => GetProperty<DateTime>();
    set => SetProperty(value);
    }
    public Clock()
    {
    SetTime(DateTime.Now);
    }
    void SetTime(DateTime dateTime)
    {
    Time = dateTime;
    scheduler.ScheduleAction(
    TimeSpan.FromSeconds(1),
    () =>
    {
    SetTime(DateTime.Now);
    });
    }
    }
}
```

Теперь, когда вы добавили массу кода, давайте обобщим то, что вы сделали.

• Вы создали новый класс ```ClockWidget```.
• Вы определили свой тип состояния как Clock.
• Вы инициализировали (известный как init в MVU узор) ваша модель полевых часов.
• Вы определили свое представление с помощью функции ```body()```.
• Вы определили свою функцию обновления в виде метод ```SetTime```.

Обратите внимание, что существует два распространенных сценария вызова обновления:
когда есть взаимодействие с пользователем (например, щелчок/нажатие кнопки) и вокруг
асинхронная фоновая работа. Ваш пример здесь относится ко второму
сценарий.

# Разметка XAML и C#

XAML зарекомендовал себя как важная часть создания пользовательских интерфейсов приложений в ```Xamarin.Forms```, и это, вероятно, продолжится в .NET MAUI, но я хочу прояснить ситуацию.
что вам не нужно его использовать. Так что, как некоторые друзья и коллеги, от многословия XAML тошнит, решение есть!

Все, что вы можете создать в XAML, в конечном итоге может быть создано в С#. Кроме того, существуют способы улучшить читабельность кода C#. Требуется для создания интерфейсов.
Некоторые преимущества создания пользовательских интерфейсов исключительно с помощью C#:

• Один файл для просмотра. Нет сопряжения ```.xaml.cs``` и ```.xaml-файлы```.

• Улучшенные параметры рефакторинга: переименование свойств или команды в XAML не будут обновлять C#.

Давайте рассмотрим, как вы можете создать свой ```ClockWidget``` на C# во всех его проявлениях.
многословие, а затем я покажу, как можно упростить его с помощью разметки C#. (Я
должен добавить, что это пакет с открытым исходным кодом, который вам нужно принести). Также,
эти примеры по-прежнему создаются с использованием MVVM.

# Обычный С#

Как уже упоминалось, все, что вы можете построить на XAML, можно также построить на C#.
В следующем коде показано, как точно такое же определение XAML вашего
```ClockWidget``` можно построить, используя только C#:

```Csharp
using WidgetBoard.ViewModels;
namespace WidgetBoard.Views;
public class ClockWidget : ContentView
{
 public ClockWidget()
 {
 BindingContext = new ClockWidgetViewModel();
 var label = new Label
 {
 FontSize = 80,
 HorizontalOptions = LayoutOptions.Center,
 VerticalOptions = LayoutOptions.Center
 };
 label.SetBinding(
 Label.TextProperty,
 nameof(ClockWidgetViewModel.Time));
 Content = label;
 }
}
```

Приведенный выше код выполняет следующие действия:
• Создает один файл, представляющий виджет ```ClockWidget```.
• Направляет ```BindingContext``` вашего виджета на ```ClockWidgetViewModel```
• Создает метку и привязывает ее свойство ```Text``` к свойство модели представления ```Time```
• Присваивает метку содержимому представления

# Разметка C#

Недавно я начал ценить возможность бегло создавать пользовательские интерфейсы. Я не склонен делать это часто, потому что лично я чувствую себя комфортно построение с помощью XAML или, возможно, это стокгольмский синдром ☺
(Я работаю с XAML уже более 10 лет). Когда я это делаю, это должно быть как можно проще для чтения и создания, учитывая, что это не то, что я делать часто.
Являясь специалистом по сопровождению ```.NET MAUI Community Toolkit```, одним из
```Packege```, которые мы предоставляем, это ```CommunityToolkit.Maui.Markup```. Он предоставляет набор методов расширения и помощников для быстрого создания пользовательских интерфейсов.

```Csharp
using CommunityToolkit.Maui.Markup;
using WidgetBoard.ViewModels;
namespace WidgetBoard.Views;
public class ClockWidget : ContentView
{
 public ClockWidget()
 {
  BindingContext = new ClockWidgetViewModel();
  Content = new Label()
 .Font(size: 80)
 .CenterHorizontal()
 .CenterVertical()
 .Bind(Label.TextProperty,nameof(ClockWidgetViewModel.Time));
 }
}
```

Этот код выполняет те же шаги, что и простой пример C#; однако, код намного легче читать. Я уверен, вы можете себе представить, что когда увеличивается сложность пользовательского интерфейса, такой беглый подход действительно может начать принести вам пользу.

# Архитектура, выбранная для этой книги

В этой книге мы будем использовать архитектуру на основе MVVM.
при создании пользовательского интерфейса через XAML.

Причины, по которым я выбрал MVVM, следующие:

• Я провел последние 10 с лишним лет, используя эту архитектуру, поэтому
это, безусловно, кажется мне естественным.

• Это был очень распространенный способ создания приложений.
за последнее десятилетие, поэтому существует обилие ресурсы в Интернете, чтобы помочь в преодолении проблем вокруг него.

• Это общий шаблон для всех продуктов Microsoft и имеет проверенный послужной список.

Теперь, когда я рассмотрел различные варианты архитектуры и решили использовать MVVM, давайте перейдем к добавлению конкретных представлений и ```ViewModels```, чтобы его можно было использовать внутри приложения. Тогда я показать, как начать упрощать реализацию, чтобы код действительно нужно только включить основную логику, избегая необходимости добавлять много
шаблонный код.

# Добавление ViewModels

Сначала добавьте новую папку в свой проект.

• Щелкните правой кнопкой мыши проект ```WidgetBoard```.
• Выберите «Добавить» ➤ «Новая папка».
• Введите имя ViewModels.
• Щелкните Добавить.

В этой папке будут храниться модели представления вашего приложения. Давайте приступим к
добавление первого.

# Добавляем IWidgetViewModel

Первый элемент, который вам нужно добавить, — это интерфейс. Он будет представлять все виджеты
просматривать модели, которые вы создаете в своем приложении.
• Щелкните правой кнопкой мыши папку ViewModels.
• Выберите «Добавить» ➤ «Новый элемент».
• Выберите тип интерфейса.
• Введите имя IWidgetViewModel.
• Щелкните Добавить.
Измените этот файл на следующее:

```Csharp
namespace WidgetBoard.ViewModels;
public interface IWidgetViewModel
{
 int Position { get; set; }
 string Type { get; }
}
```

# Добавление BaseViewModel

Он будет служить базовым классом для всех ваших моделей представления, так что вы можете
нужно написать какой-то шаблонный код один раз. Не волнуйся; вы увидите, как
оптимизировать это еще больше!

• Щелкните правой кнопкой мыши папку ViewModels.
• Выберите «Добавить» ➤ «Класс».
• Введите имя BaseViewModel.
• Щелкните Добавить.

Вы можете заменить содержимое файла класса следующим кодом:

```Csharp
using System.ComponentModel;
using System.Runtime.CompilerServices;
namespace WidgetBoard.ViewModels;
public abstract class BaseViewModel : INotifyPropertyChanged
{
 public event PropertyChangedEventHandler PropertyChanged;
 protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
 {
 PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
 }
 protected bool SetProperty<TValue>(ref TValue backingField,TValue value, [CallerMemberName] string propertyName = "")
 {
 if (Comparer<TValue>.Default.Compare(backingField, value) == 0)
 {
    return false;
 }
 backingField = value;
 OnPropertyChanged(propertyName);
 return true;
 }
}
```
Вы должны быть знакомы с первой строкой внутри класса:

```public event PropertyChangedEventHandler PropertyChanged;```

Это определение события, которое вы должны добавить как часть реализации
интерфейс ```INotifyPropertyChanged``` и служит механизмом
ваша модель представления для обновления представления.
Следующий метод обеспечивает механизм легкого обновления cобытие ```PropertyChanged```:

```Csharp
protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
{
 PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
}
```
Метод ```OnPropertyChanged``` можно вызывать с передачей или без нее в значении для ```propertyName```. Передавая значение, вы указываете какое имя свойства в вашей модели представления изменилось. Если нет, то атрибут [CallerMemberName] указывает, что имя вызывающего абонента будет использовал. Не беспокойтесь, если сейчас это немного неясно; это станет много яснее, когда вы добавляете свою собственность в свой ```ClockWidgetViewModel```, поэтому просто терпите меня. Последний метод добавляет много ценности:

```Csharp
protected bool SetProperty<TValue>(ref TValue backingField, TValue value,
 [CallerMemberName] string propertyName = "")
{
    if (Comparer<TValue>.Default.Compare(backingField, value) == 0)
    {
        return false;
    }
    backingField = value;
    OnPropertyChanged(propertyName);
    return true;
} 
```

Метод ```SetProperty``` делает следующее:

• Позволяет вызывать его из установщика свойств, передавая
поле и устанавливаемое значение

• Проверяет, отличается ли значение от резервного
поле, в основном определяющее, имеет ли свойство
действительно изменился

• Если он изменился, он запускает событие ```PropertyChanged```.
используя ваш новый метод ```OnPropertyChanged```

• Возвращает логическое значение, указывающее, было ли значение
действительно измениться. Это может быть очень полезно, когда нужно
для обновления других свойств или команд!

На этом реализация базовой модели представления завершена. Давайте приступим к
используя его в качестве основы для ```ClockWidgetViewModel```, чтобы действительно оценить
ценность, которую он обеспечивает.

# Добавляем ClockWidgetViewModel

Давайте добавим новый файл класса в вашу папку ViewModels, как вы сделали для
Файл BaseViewModel.cs. Назовите этот файл ClockWidgetViewModel и измените
содержание к следующему:

```Csharp
using System;
using System.ComponentModel;
namespace WidgetBoard.ViewModels;
public class ClockWidgetViewModel : BaseViewModel,IWidgetViewModel
{
 private readonly Scheduler scheduler = new();
 private DateTime time;

 public DateTime Time
 {
    get => time;
    set => SetProperty(ref time, value);
 }

 public int Position { get; set; }
 public string Type => "Clock";
 public ClockWidgetViewModel()
 {
    SetTime(DateTime.Now);
 }
 
 public void SetTime(DateTime dateTime)
 {
    Time = dateTime;
    scheduler.ScheduleAction(
    TimeSpan.FromSeconds(1), () => SetTime(DateTime.Now));
 }
}
```
Приведенный выше код должен быть вам знаком. Вы видели это при просмотре
MVVM. Сделанная здесь оптимизация заключается в уменьшении размера окна Time.
свойство сократилось до 5 строк, тогда как в исходном примере было 16 строк.
кода..

# Добавление представлений

Сначала добавьте новую папку в свой проект.
• Щелкните правой кнопкой мыши проект ```WidgetBoard```.
• Выберите «Добавить» ➤ «Новая папка».
• Введите имя Представления.
• Щелкните Добавить.

В этой папке будут храниться представления вашего приложения. Приступим к добавлению
твой первый.

# Добавление IWidgetView

Первый элемент, который вам нужно добавить, — это интерфейс для представления всех представлений виджета модели, которые вы создаете в своем приложении.

• Щелкните правой кнопкой мыши папку Представления.
• Выберите «Добавить» ➤ «Новый элемент».
• Выберите тип интерфейса.
• Введите имя IWidgetView.
• Щелкните Добавить.

Измените содержимое этого файла на следующее

```Csharp
using WidgetBoard.ViewModels;
namespace WidgetBoard.Views;
public interface IWidgetView
{
 int Position { get => WidgetViewModel.Position; set => WidgetViewModel.Position = value; }
 IWidgetViewModel WidgetViewModel { get; set; }
}
```

# Добавляем ClockWidgetView

Следующим элементом, который вам нужно добавить, является ContentView. Это первый раз, когда ты
делают это, поэтому выполните следующие действия:

• Щелкните правой кнопкой мыши папку Представления.

• Выберите «Добавить» ➤ «Новый элемент».

• Выберите вкладку .NET MAUI.

• Выберите параметр .NET MAUI ContentView (XAML).

• Введите имя ClockWidgetView.

• Щелкните Добавить.

Обратите внимание, что в ваш проект добавлены два новых файла:
```ClockWidgetView.xaml``` и ```ClockWidgetView.xaml.cs```. Вы можете
обратите внимание, что файл ```ClockWidgetView.xaml.cs``` скрыт в решении
панели проводника и что вам нужно развернуть стрелку слева от
Файл ```ClockWidgetView.xaml```.

Давайте обновим оба файла, чтобы они соответствовали тому, что было в исходных примерах.

Откройте файл ```ClockWidgetView.xaml``` и измените содержимое на следующий:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<Label
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.Views.ClockWidgetView"
 FontSize="60"
 VerticalOptions="Center"
 HorizontalOptions="Center"
 x:DataType="viewmodels:ClockWidgetViewModel"
 Text="{Binding Time}">
</Label>
```
Откройте файл ```ClockWidgetView.xaml.cs``` и измените содержимое на
следующее:

```Csharp
using WidgetBoard.ViewModels;
namespace WidgetBoard.Views;
public partial class ClockWidgetView : Label, IWidgetView
{
 public ClockWidgetView()
 {
    InitializeComponent();
    WidgetViewModel = new ClockWidgetViewModel();
    BindingContext = WidgetViewModel;
 }
 public IWidgetViewModel WidgetViewModel { get; set; }
}
```

На этом работа по добавлению ClockWidget в вашу кодовую базу завершена.
Теперь вам нужно изменить свое приложение, чтобы вы могли видеть этот виджет
в бою!

# Просмотр вашего виджета

Для того, чтобы просмотреть ваш виджет в вашем приложении, вам нужно сделать некоторые
изменения в файлах ```MainPage.xaml``` и ```MainPage.xaml.cs```, которые были
генерируется при первом создании проекта.

## Изменение MainPage.xaml
Просто замените содержимое файла следующим.

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:views="clr-namespace:WidgetBoard.Views"
 x:Class="WidgetBoard.MainPage">
 <views:ClockWidgetView />
</ContentPage>
```
В исходном файле был базовый пример, который поставляется с .NET MAUI.
шаблон, но в этом приложении от него мало толку.

## Изменение MainPage.xaml.cs

Вам нужно изменить содержимое этого файла, потому что вы удалили некоторые
элементы управления из файла ```MainPage.xaml```. Если вы не обновите этот файл, Visual
Studio сообщит об ошибках компиляции. Вы можете заменить все содержимое

файла MainPage.xaml.cs со следующим, чтобы удалить ссылки на
элементы управления, которые вы удалили из файла XAML:

```Csharp
namespace WidgetBoard;
public partial class MainPage : ContentPage
{
 public MainPage()
 {
    InitializeComponent();
 }
}
```

На этом изменения, которые необходимо внести в приложение, завершены.
Давайте посмотрим, как теперь выглядит ваше приложение!

## Прием заявки на спин

Если вы создадите и запустите свое приложение так же, как вы научились в главе 2,
вы можете видеть, что он отображает ClockWidget так же, как я изначально разработал.
На рис. 4-4 показан виджет часов, отображаемый в работающем приложении.
на макОС.

![изображение](https://user-images.githubusercontent.com/26972859/231113621-1d4143c8-c703-431e-8177-4a9651cbb16c.png)

Рисунок 4-4. Виджет часов, отображаемый в работающем приложении на macOS

Вы рассмотрели способы оптимизации вашей кодовой базы при использовании MVVM.
но я хотел бы предоставить дополнительную информацию о том, как вы можете использовать
силу сообщества, чтобы еще больше улучшить ваш опыт.

## Усовершенствования MVVM

Есть две ключевые части, которые я расскажу о том, как вы можете использовать существующие
пакеты, чтобы уменьшить объем кода, который требуется написать.

# Фреймворки MVVM

Существует несколько сред MVVM, которые могут расширить это, предоставив
реализация базового класса для вас с различными уровнями других дополнительных
функции. Чтобы перечислить несколько,
• CommunityToolkit.Mvvm

• MVVMLight
• FreshMVVM
• Prism
• Refractored.MVVMHelpers
• ReactiveUI

Эти пакеты в конечном итоге предоставят вам базовый класс очень
аналогично классу ```BaseViewModel```, который вы создали ранее. Например,
библиотека ```Prism``` предоставляет класс ```BindableBase```, который вы можете использовать. Это предлагает еще одну оптимизацию с точки зрения меньшего количества кода, который вам нужно написать и в конечном итоге сохранить.
Можно пойти еще дальше, но нужно верить…

# Магия

Да, верно: магия реальна! Эти подходы включают автоматическую генерацию
требуемый шаблонный код, чтобы нам, как разработчикам, не приходилось это делать.
Есть два основных пакета, предлагающих эту функциональность. Они обеспечивают это
через разные механизмы, но работают они одинаково хорошо.

• Fody: генерация IL, https://github.com/Fody/Home.

• CommunityToolkit.Mvvm: Генераторы исходников (да, это
получает второе упоминание), https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/

Раньше я скептически относился к использованию таких пакетов. Я чувствовал, что я
теряя контроль над частями, за которые мне нужно было держаться. Теперь я могу оценить
что я был наивен, и это впечатляет.

Давайте посмотрим, как эти пакеты могут помочь еще больше сократить
код. В этом примере используется CommunityToolkit.Mvvm, который предоставляет

Базовый класс ```ObservableObject``` и прекрасный способ добавления атрибутов
([ObservableProperty]) в поля, которые вы хотите инициировать ```PropertyChanged```
события при изменении их значения. Затем это создаст свойство с
то же имя, что и у поля, но с заглавной первой буквой, поэтому время
становится Time.

```Csharp
public partial class ClockWidgetViewModel : ObservableObject
{
 [ObservableProperty]
 private DateTime time;
 public ClockWigetViewModel()
 {
 SetTime(DateTime.Now);
 }
 public void SetTime(DateTime dateTime)
 {
 Time = dateTime;
 scheduler.ScheduleAction(
 TimeSpan.FromSeconds(1),
 () => SetTime(DateTime.Now));
 }
}
```

Это на 17 строк меньше 2 по сравнению с исходным примером! Часть, которую я
действительно нравится то, что он уменьшает весь шум шаблонного кода, поэтому есть
больше внимания уделяется коду, который нам нужно писать как разработчикам.
Возможно, вы заметили, что вы все еще ссылаетесь на свойство Time.
в коде, но вы не предоставили определение для этого свойства. Этот
вот где волшебство приходит! Если щелкнуть правой кнопкой мыши свойство Time и выбрать
Перейти к определению… откроется следующий исходный код, чтобы вы могли просмотреть
что инструментарий создал для вас:

```Csharp
// <auto-generated/>
#pragma warning disable
#nullable enable
namespace WidgetBoard.ViewModels
{
 partial class ClockWidgetViewModel
 {
 /// <inheritdoc cref="time"/>
 [global::System.CodeDom.Compiler.
GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.ObservablePropertyGenerator", "8.0.0.0")]
 [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
 public global::System.DateTime Time
 {
 get => time;
 set
 {
 if (!global::System.Collections.Generic.EqualityComparer<global::System.DateTime>.
Default.Equals(time, value))
 {
 OnTimeChanging(value);
 OnPropertyChanging(global::CommunityToolkit.Mvvm.ComponentModel.__Internals.__
 KnownINotifyPropertyChangingArgs.Time);
 time = value;
 OnTimeChanged(value);
 OnPropertyChanged(global::CommunityToolkit.Mvvm.ComponentModel.__Internals.__
 KnownINotifyPropertyChangedArgs.Time);
 }
 }
 }
 /// <summary>Executes the logic for when <see
cref="Time"/> is changing.</summary>
 [global::System.CodeDom.Compiler.
GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.ObservablePropertyGenerator", "8.0.0.0")]
 partial void OnTimeChanging(global::System.DateTime value);
 /// <summary>Executes the logic for when <seecref="Time"/> just changed.</summary>
 [global::System.CodeDom.Compiler.GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.
ObservablePropertyGenerator", "8.0.0.0")]
 partial void OnTimeChanged(global::System.
DateTime value);
 }
}
```
Вы можете видеть, что сгенерированный исходный код выглядит немного зашумленным, но это
на самом деле генерирует необходимое вам свойство. Посмотреть выделенный раздел
жирным шрифтом выше.
Я только действительно поцарапал поверхность относительно функциональности
которые предлагает CommunityToolkit.Mvvm. Я настоятельно рекомендую вам обратиться
в документации по адресу https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/, чтобы узнать, как это может помочь вашему приложению.
разработка.

# Краткое содержание

Надеюсь, я ясно дал понять, что не существует единственно правильного способа делать что-то или
создавать приложения. Вы должны выбрать и выбрать, какие подходы будут лучше всего
соответствовать вашей среде. Учитывая это, целью настоящей главы было чтобы дать вам хороший обзор нескольких различных подходов к архитектуре ваше приложение. Вокруг всегда много мнений
указать, какие архитектуры люди предпочитают, но я настоятельно призываю вас оцените, что поможет вам достичь ваших целей лучше всего.

В этой главе у вас есть

• Узнали о различных возможностях, которые у вас есть
проектируя свои приложения

• Решили, какую архитектуру использовать

• Прошелся по конкретному примеру, создав виджет часов

• Узнали, как оптимизировать внедрение с помощью пакетов NuGet

В следующей главе вы будете

• Создайте и примените значок в своем приложении.

• Добавьте несколько страниц-заполнителей и просмотрите модели.

• Заполните свою первую страницу пользовательским интерфейсом и настройте привязки к модель представления

• Узнайте о привязке данных и ее многочисленных применениях.

• Получите представление о XAML

• Узнайте о возможных макетах, которые можно использовать для группировки.
другие элементы управления

• Получить представление о «Шелл» и применить его к
построение структуры вашего приложения

• Применить навигацию Shell, чтобы вы могли перемещаться

• Создайте всплывающее меню

# Исходный код

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introducing-MAUI/tree/main/ch04.
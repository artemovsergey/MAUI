# ГЛАВА 5

# Основы пользовательского интерфейса

В этой главе вы собираетесь исследовать основные части
создание приложения .NET MAUI. Вы собираетесь применить значок и
экран-заставку, добавьте несколько страниц и связанных с ними моделей просмотра, а также настроить некоторые привязки между вашей страницей и моделью представления. Вы будете также получить представление о том, что такое XAML и что он может предложить, когда вы создайте страницы и оболочку вашего приложения. Вы также узнаете, как ```Shell``` позволяет вам перемещаться между страницами вашего приложения.

# Предпосылки

Вам нужно выполнить некоторые настройки, прежде чем вы сможете перейти к использованию ```Shell```. Если ```Shell``` все еще чувствуя себя неизвестной концепцией, не бойтесь. Я буду освещать это немного
чуть позже в этой главе в разделе «Shell». Давайте продолжим и добавим следующие папки в ваш проект.

# Модели

Здесь будут размещены все ваши классы моделей. Если вы помните из главы 4, эти где находится часть вашей бизнес-логики. В папке «Модели» вы нужно создать три класса.

# BaseLayout.cs

Он будет служить базовым классом для параметров макета, которые вы предоставляете. В течение этой книге вы будете создавать только платы с фиксированным макетом, но я хотел заложите основу, чтобы, если вы чувствуете себя авантюрным, вы могли уйти и создавать альтернативные варианты компоновки без необходимости реструктуризации приложение. На самом деле, я хотел бы услышать, где вы его берете!

```Csharp
namespace WidgetBoard.Models;
public abstract class BaseLayout
{
}
```

# FixedLayout.cs

Это будет представлять фиксированный макет, как я упоминал в предыдущем разделе. Ваш фиксированный макет предложит пользователю приложения возможность выбрать количество строк и столбцов, а затем размещать в них свои виджеты.

```Csharp
namespace WidgetBoard.Models;
public class FixedLayout : BaseLayout
{
 public int NumberOfColumns { get; init; }
 public int NumberOfRows { get; init; }
}
```

# Board.cs

Ваша окончательная модель представляет собой общую плату.

```Csharp
namespace WidgetBoard.Models;
public class Board
{
 public string Name { get; init; }
 public BaseLayout Layout { get; init; }
} 
```

# Pages

В нем будут размещены страницы вашего приложения. я различаю между
страницу и представление, потому что они ведут себя по-разному в .NET MAUI. Mожно думать о странице как об экране, который вы видите, тогда как представление — это меньший компонент. Страница может содержать несколько представлений. Давайте продолжим и создадим следующие файлы в папке ```Pages```.

Следующие шаги показывают, как добавить новые страницы.

Щелкните правой кнопкой мыши папку «Страницы».
• Выберите «Добавить» ➤ «Новый элемент».
• Выберите вкладку .NET MAUI.
• Выберите .NET MAUI ContentPage (XAML).
• Щелкните Добавить.

## BoardDetailsPage

Это страница, которая позволяет вам создавать и редактировать свои доски. На данный момент, вы не будете трогать содержимое этого файла. Обратите внимание, что вы должны увидеть cозданы файлы ```BoardDetailsPage.xaml``` и ```BoardDetailsPage.xaml.cs```.

Вам также необходимо перейти к файлу ```MauiProgram.cs``` и зарегистрировать этот страница со службами внутри метода ```CreateMauiApp```.

```Csharp
builder.Services.AddTransient<BoardDetailsPage>();
```
# FixedBoardPage

Это страница, на которой будут отображаться доски, созданные вами на предыдущей странице. Пока вы не будете трогать содержимое этого файла. Обратите внимание, что вы должны см. созданные файлы ```FixedBoardPage.xaml``` и ```FixedBoardPage.xaml.cs```.

Вам также нужно будет перейти к файлу ```MauiProgram.cs``` и зарегистрироваться эта страница со службами внутри метода ```CreateMauiApp```.

```builder.Services.AddTransient<FixedBoardPage>();```

# ViewModels

Здесь находятся ваши ViewModels, которые являются основой как для ваших страниц, так и для Views. Вы создали эту папку в предыдущей главе, но вам нужно добавить количество занятий. Следующие шаги показывают, как добавить новые страницы.

• Щелкните правой кнопкой мыши папку ViewModels.
• Выберите «Добавить» ➤ «Новый класс».
• Щелкните Добавить.

# AppShellViewModel

Это служит моделью представления для файла ```AppShell```, созданного для вас по оснастке.

```Csharp
namespace WidgetBoard.ViewModels;
public class AppShellViewModel : BaseViewModel
{
}
```

Вам также необходимо перейти к файлу ```MauiProgram.cs``` и зарегистрировать этот страница со службами внутри метода ```CreateMauiApp```.

```Csharp
builder.Services.AddTransient<AppShellViewModel>();
```

# BoardDetailsPageViewModel

Это служит моделью представления для созданного вами файла ```BoardDetailsPage```.

```Csharp
namespace WidgetBoard.ViewModels;
public class BoardDetailsPageViewModel : BaseViewModel
{
}
```
Вам также необходимо перейти к файлу MauiProgram.cs и зарегистрировать этот
страница со службами внутри метода CreateMauiApp.

```Csharp
builder.Services.AddTransient<BoardDetailsPageViewModel>();
```

# FixedBoardPageViewModel

Это служит моделью представления для созданного вами файла FixedBoardPage.

```Csharp
namespace WidgetBoard.ViewModels;
public class FixedBoardPageViewModel : BaseViewModel
{
}
```
Вам также необходимо перейти к файлу MauiProgram.cs и зарегистрировать этот
страница со службами внутри метода CreateMauiApp.

```builder.Services.AddTransient<FixedBoardPageViewModel>();```


**Замечание:** Вы должны были заметить общую закономерность при создании этих
файлы и необходимость добавления их в файл MauiProgram.cs. Это
чтобы вы могли в полной мере использовать внедрение зависимостей, предоставляемое Framework, о котором вы узнали в главе 3.
---

# Значки приложений

Каждому приложению нужна иконка, и для многих это будет именно так.
получить их первое впечатление. К счастью, в наши дни экраны устройств позволяют для больших размеров значков и, следовательно, для включения в них большего количества деталей.

Как и в случае с общими ресурсами изображений, для каждой платформы требуются разные размеры и многие другие комбинации, которые будут предоставлены. Например, iOS ожидает следующее:

• Пять различных размеров значка приложения

• Три разных размера для функции Spotlight

• Три разных размера для уведомлений

• Три разных размера для настроек

Это до 14 различных размеров изображений, необходимых только для вашего приложения значок только на iOS. См. https://developer.apple.com/design/humaninterface-guidelines/ios/icons-and-images/app-icon/.

.NET MAUI управляет процессом создания всех необходимых образов для тебя. Все, что вам нужно сделать, это предоставить файл изображения SVG. Поскольку SVG векторные, они могут масштабироваться до любого требуемого размера.

## Добавление собственной иконки

На рис. 5-1 показан значок, который вы будете использовать для своего приложения. Можете получить копию файлов, которые вы будете использовать, с https://github.com/bijington/introduction-dotnet-maui/tree/main/chapter05 и
поместите их в папку ```Resources/AppIcon```. Вы должны заметить, что они
заменить два существующих файла.

![изображение](https://user-images.githubusercontent.com/26972859/231117066-af76bc3f-63d8-4fcd-84cb-0bed1613b9e7.png)

Рисунок 5-1. Значок вашего приложения

Если вы посмотрите содержимое вашего файла проекта, вы увидите
следующая запись:

```<MauiIcon Include="Resources\AppIcon\appicon.svg" />```

Это говорит инструментам использовать файл ```appicon.svg``` и преобразовывать его во все необходимые размеры для каждой платформы при строительстве. Обратите внимание, что вы хотите только один ```MauiIcon``` в вашем файле проекта. Если у вас их несколько, первый будет использоваться.
Вам не нужно заменять вышеуказанную запись, так как файл, который вы должны
скачанный должен иметь имя ```appicon.svg```. Если имя файла
другой, либо переименуйте его, либо обновите имя в файле проекта.

# Различия платформ

Стоит отметить, что некоторые платформы применяют разные правила к значкам приложений, а также может давать весьма разные результаты.

## Андроид

Иконки приложений на Android могут принимать разные формы из-за разных
производители устройств и свой вариант операционной системы Android. Чтобы учесть это, Google представила адаптивную иконку. Это позволяет
разработчику определить два слоя в своей иконке:
• Фон: Обычно это однотонный или последовательный узор.
• Передний план: сюда входят основные детали.

.NET MAUI позволяет поддерживать адаптивный значок с помощью
```IncludeFile``` и свойства ```ForegroundFile``` на ```MauiIcon```
элемент. Вы можете видеть, что ```IncludeFile``` уже определен в вашем проекте.

Это представляет фон. Вы можете разделить значок приложения на
две части, а затем предоставить детали ```ForegroundFile```. Обратите внимание, что это может применяться ко всем платформам, и это мой рекомендуемый способ доставки значок приложения.

## iOS и macOS

Apple не допускает прозрачности значков приложений. Вы также можете
убедитесь, что вы предоставляете изображение без прозрачных пикселей, или вы можете используйте свойство ```Color``` элемента ```MauiIcon```, которое заполнит любой прозрачные пиксели с этим определенным цветом.

# SplashScreen

Заставка — это первое, что видит пользователь, когда запускает ваш
приложение. Это дает вам как разработчику способ показать пользователю
что-то во время запуска приложения. Как только все
завершится загрузка, экран-заставка будет скрыт, а ваша главная страница
быть показаны.
Подобно тому, как управляется значок приложения, экран-заставка
также имеет запись в файле проекта и может генерировать экран на основе
SVG-файл. Фактически, вы будете использовать одно и то же изображение, чтобы сэкономить усилия.

```xml
<MauiSplashScreen Include="Resources\SplashScreen\SplashScreen.svg"
                  Color = "#512BD4"
                  BaseSize = "128 128" />
```
Обратите внимание, что экраны-заставки, построенные таким образом, должны быть статическими. Вы не можете иметь любую анимацию, чтобы показать прогресс. Свойство ```Color``` позволяет определить цвет фона для
заставка.

# XAML

Как разработчик .NET MAUI, вы много раз услышите упоминание XAML,
XAML означает расширяемый язык разметки приложений. Это язык на основе XML, используемый для определения пользовательских интерфейсов. Он происходит из WPF и Silverlight, но версия .NET MAUI имеет свои отличия.
Существует два разных типа файлов XAML, с которыми вы столкнетесь.
при создании приложения:

• ResourceDictionary: это один файл, который содержит ресурсы, которые можно легко использовать во всем ваше приложение. Resources/Styles/Styles.xaml
является прекрасным примером этого. Файл ```Styles.xaml``` представляет собой
набор стилей по умолчанию, который предоставляется при создании
новое приложение .NET MAUI. Если вы хотите изменить
некоторые встроенные стили, это очень хорошее место для этого.

• Файл на основе представления: он содержит как ```.xaml```, так и
Файл ```.xaml.cs```. Они соединяются вместе с помощью ключевое слово частичного класса.

**Замечание:**

При работе с этим вторым пунктом вы должны убедиться, что
строка ```InitializeComponent``` вызывается внутри конструктора;
в противном случае XAML не будет правильно интерпретирован, и вы увидите
выброшено исключение.

Стоит отметить, что XAML не предоставляет такого богатого набора функций, как
C# делает, и по этой причине почти всегда есть файл xaml.cs, который
вместе с файлом XAML. Этот файл C# предоставляет возможность использовать богатый набор функций языка C#, когда XAML не позволяет. Например, обработка
событие взаимодействия с кнопкой должно быть выполнено в файле кода C#.

## Анализ файла XAML

В разделе предварительных требований этой главы вы создали файл ```BoardDetailsPage.xaml```. Теперь вы собираетесь изменить его и добавить некоторые содержательный контент, чтобы вы могли начать видеть, как ваше приложение обретает форму. Код, который вы должны увидеть в этом файле, показан ниже.

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 x:Class="WidgetBoard.Pages.BoardDetailsPage"
 Title="BoardDetailsPage">
 
 <VerticalStackLayout>
  <Label
  Text="Welcome to .NET MAUI!"
  VerticalOptions="Center"
  HorizontalOptions="Center" />
 </VerticalStackLayout>
</ContentPage>
```

Если вы разобьете это на маленькие кусочки, вы сможете начать понимать
не только то, что составляет пользовательский интерфейс вашего приложения, но и некоторые основы представления XAML.

Корневой элемент — это ```ContentPage```. Как уже упоминалось, типичный вид в
.NET MAUI — это либо ```ContentPage```, либо ```ContentView```. Как следует из названия, это страница, на которой представлено ее содержимое, и это будет единственное представление, поскольку ее содержание.
Как уже упоминалось, XAML — это язык, основанный на XML, и существуют
следующие ключевые части для понимания XAML:

1. Свойства задаются атрибутами вашего элемента, поэтому

```<Label Text="Добро пожаловать в .NET MAUI!" />```

фактически то же самое, что писать

```Csharp

new Label()
{
 Text ="Добро пожаловать в .NET MAUI!"
};
```

2. XAML представляет визуальную иерархию в файле состав. Вы можете понять, что ```ContentPage``` имеет дочерний элемент ```VerticalStackLayout```, и у него есть дочерний элемент ```Label```. Это может быть особенно полезно. Комплекс XAML приведет к сложному визуальному дереву и вы хотите сделать все возможное, чтобы избежать этого.

3. Тег ```xmlns``` работает как оператор ```using``` в C#. Этот
позволяет ссылаться на другие функции, которые могут не быть доступным из коробки. Например, вы можете добавить строка ```xmlns:views="clr-namespace:WidgetBoard.Views"```, и это эквивалентно добавлению ```using WidgetBoard.Views;``` в файле С#. Это позволяет вам
обратитесь к представлениям в вашей кодовой базе.

Содержимое вашей ```ContentPage``` в вашем XAML представляет собой
```VerticalStackLayout```. Я расскажу о макетах немного позже в этой главе.
но в качестве очень краткого обзора они позволяют вам иметь несколько дочерних представлений как содержание и, следовательно, открыть возможности для создания ваших пользовательских интерфейсов. Это стоит отметить, что у ```ContentPage``` может быть только один дочерний элемент, что делает
Макеты действительно важные элементы управления для использования при создании пользовательских интерфейсов.

Теперь, когда вы рассмотрели некоторые ключевые концепции XAML, давайте продолжим и начнем создавать первую страницу вашего приложения.

# Создание первой XAML-страницы

Мне всегда нравится работать с четким определением того, что должно быть достигнуто, чтобы давайте определим, что ваша страница должна делать. Нужно сделать следующее:

• Разрешить пользователю создавать новую доску.

• Подходит для различных размеров экрана.

• Разрешить пользователю указывать имя доски.

• Разрешить пользователю выбирать тип макета.

• Применить любые допустимые свойства для определенного макета тип выбран.

Теперь, когда вы знаете, чего нужно достичь, давайте продолжим и сделаем
это. Вам необходимо удалить существующее содержимое страницы и заменить его
с границей. ```Border``` похож на ```ContentView``` тем, что может иметь только один ребенок, но он предлагает вам некоторые дополнительные свойства, которые позволяют вам обеспечить красивый пользовательский интерфейс. В частности, вы заботитесь о ```StrokeShape``` и свойства штриха. Вы можете заметить, что на самом деле вы не устанавливаете эти свойства в ```XAML```, и вы были бы правы! Есть два основные причины этого:

У вас есть подходящие значения по умолчанию, определенные в ```Resources/```
Созданный для вас файл ```Styles/Styles.xaml```. Примечание что если вы хотите переопределить их, это совершенно нормально. я мы рассмотрим это немного позже в этой главе в раздел «Стиль».

• Считается хорошей практикой определять только свойства, которые вам нужно предоставить, что в основном все, что отличается от значений по умолчанию. В то время

Компилятор XAML неплохо справляется с созданием Пользовательский интерфейс, который определяется во время компиляции, некоторые биты все еще потенциально интерпретируется во время выполнения, и это имеет влияние производительности.

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 x:Class="WidgetBoard.Pages.BoardDetailsPage">
 <Border
  MinimumWidthRequest="300"
  HorizontalOptions="Center"
  VerticalOptions="Center"
  Padding="0">
 </Border>
</ContentPage>
```
Самая важная часть свойств, которые вы устанавливаете, — это Горизонтальные параметры и вертикальные параметры. Они позволяют определить, где в родительском это представление будет отображаться. По умолчанию представление будет заполнять родители довольны, но вы собираетесь заставить его плавать в центре. Главная причина в том, что он останется там независимо от размера экрана, на котором он работает.
Конечно, есть более подробные способы обработки разных размеров экрана.
и вы будете исследовать их в следующих главах. Хотя у вас есть гораздо больше содержимого, которое можно добавить в этот XAML, мы собираемся сделать это в контексте следующих тем. Ваш следующий шаг чтобы добавить несколько дочерних представлений. Для этого вам нужно будет выбрать
подходящий макет.

# Макеты

.NET MAUI предоставляет вам набор готовых классов компоновки, которые позволяют вам группировать и упорядочивать представления в приложении. Цель этого раздела состоит в том, чтобы изучите каждый элемент управления макетом и то, как его можно использовать для вашего приложения.
Я настоятельно рекомендую поэкспериментировать с каждым из макетов, чтобы увидеть, что лучше всего подходит для каждого отдельного случая использования, и всегда помните о сохранении визуальное дерево максимально простым.

## Абсолютный макет

Как следует из названия, ```AbsoluteLayout``` позволяет позиционировать его
детей с абсолютными значениями. X, y, ширина и высота дочернего элемента
управляется через присоединенное свойство ```LayoutBounds```. Это значит, что ты использовать следующим образом:

```xml
<AbsoluteLayout>
 <Label
 AbsoluteLayout.LayoutBounds="0,0,600,200"/>
</AbsoluteLayout>

```

На рис. 5-2 показано, как элемент управления расположен внутри
Абсолютный макет.

![изображение](https://user-images.githubusercontent.com/26972859/231118592-0177bb26-72bc-4ac1-a2f1-d0bee584bb69.png)

Рисунок 5-2. Обзор абсолютной компоновки

Существует также возможность определить границы макета, пропорциональна самому ```AbsoluteLayout```. Вы можете контролировать это с помощью
Присоединенное свойство ```AbsoluteLayout.LayoutFlags```.

```Csharp
<AbsoluteLayout>
 <Label
 AbsoluteLayout.LayoutBounds="0,0,0.5,0.2"
 AbsoluteLayout.LayoutFlags="All"/>
</AbsoluteLayout>
```

Это приведет к тому, что метка будет расположена на 0,0, но ширина будет
быть 50% от ```AbsoluteLayout``` и высота будет 20%. Это обеспечивает
много сил при определении пользовательского интерфейса, который может увеличиваться до размера устройство также увеличивается.
Опция ```LayoutFlags``` дает вам много возможностей. Ты можешь выберите, какая часть ```LayoutBounds``` применяется абсолютно, а какая применяются пропорционально. Вот возможные значения для ```LayoutFlags```.
и на что они влияют:

|Значение|Описание|
|:--|:--|
|Нет|Все значения являются абсолютными.|
|XProportional|Свойство X пропорционально размерам AbsoluteLayout.|
|YProportional|Свойство Y пропорционально размерам AbsoluteLayout|
|WidthProportional|Свойство Width пропорционально размерам AbsoluteLayout.|
|HeightProportional|Свойство Height пропорционально размерам AbsoluteLayout.|
|PositionProportional|Свойства X и Y пропорциональны размерам AbsoluteLayout.|
|SizeProportional|Свойства Width и Height пропорциональны размерам AbsoluteLayout.|
|Все|Все свойства пропорциональны размерам AbsoluteLayout|

```AbsoluteLayout``` - может быть невероятно мощным макетом при использовании
в правильном сценарии. Для вашего сценария он предлагает больше сложностей, чем я действительно думаю, что вам нужно справиться.

# FlexLayout

```FlexLayout``` поставляется с большим количеством свойств для настройки.
как расположены его дети. Если вы хотите, чтобы ваши элементы управления переносились, это управление для вас! Хорошим примером использования ```FlexLayout``` является мультимедийный галерея.

На рис. 5-3 показано, как можно расположить элементы управления внутри ```FlexLayout```.

![изображение](https://user-images.githubusercontent.com/26972859/231120286-f2d319da-8575-4241-8f2f-7a2f00618c60.png)

Рисунок 5-3. Обзор FlexLayout

Приведенный выше макет может быть реализован с помощью следующего примера кода:

```xml
<FlexLayout
 AlignItems="Start"
 Wrap="Wrap"
 Margin="30"
 JustifyContent="SpaceEvenly">
 <Border
 BackgroundColor="LightGray"
 WidthRequest="100"
 HeightRequest="100" />
 <Border
 BackgroundColor="LightGray"
 WidthRequest="100"
 HeightRequest="100" />
 <Border
 BackgroundColor="LightGray"
 WidthRequest="100"
 HeightRequest="100" />
 <Border
 BackgroundColor="LightGray"
 WidthRequest="100"
 HeightRequest="100" />
</FlexLayout>
```
Каждое из свойств, которые вы используете, позволяет вам настроить, где
каждый элемент позиционируется в процессе рендеринга и как они будут
перемещаться в приложении, если его размер изменен. Для дополнительной информации о возможных способах настройки ```FlexLayout``` читайте в Microsoft документацию по адресу https://learn.microsoft.com/dotnet/maui/userinterface/layouts/flexlayout.
На странице ```BoardDetailsPage``` нужны только элементы управления, расположенные вертикально, чтобы ```FlexLayout``` кажется слишком сложным макетом для этой цели.

# Сетка

Я люблю Гридс. Обычно они являются моим предпочтительным вариантом макета, в основном потому, что я привык думать о том, как они располагают элементы управления и потому что они, как правило, позволяют вам сохранять глубину вашего визуального дерева неглубокой. Макет по существу работает, позволяя вам определить набор строк и столбцы, а затем определить, какой элемент управления должен отображаться в какой строке/комбинация столбцов.
На рис. 5-4 показано, как можно расположить элементы управления внутри сетки.

![изображение](https://user-images.githubusercontent.com/26972859/231120630-3dfe23e1-5573-4d5f-b3f3-de708c5b260e.png)

Рисунок 5-4. Обзор компоновки сетки

Элементы управления внутри сетки могут накладываться друг на друга, что может
предоставить дополнительный инструмент в наборе инструментов разработчика, когда нужно показать/скрыть элементы управления. Элементы управления в сетке упорядочиваются, сначала определяя

Определения столбцов и определения строк. Давайте посмотрим, как создать
приведенный выше макет с сеткой.

```xml
<Grid
 ColumnDefinitions ="*,2*,250,Auto"
 ColumnSpacing="20"
 Margin="30"
 RowDefinitions="*,*"
 RowSpacing="20">
 <Border
 BackgroundColor="LightGray"
 Grid.Column="0"
 Grid.Row="0" />
 <Border
 BackgroundColor="LightGray"
 Grid.Column="1"
 Grid.Row="1" />
 <Border
 BackgroundColor="LightGray"
 Grid.Column="2"
 Grid.Row="0" />
 <Border
 BackgroundColor="LightGray"
 Grid.Column="3"
 Grid.Row="1"
 WidthRequest="30"
 HeightRequest="30" />
</Grid>
```

Вы можете видеть, что вы создали столбцы, используя различные
параметры:

• 250: это фиксированная ширина 250.
• Авто: это означает, что столбец будет увеличиваться в ширину.
исходя из его содержания. Рекомендуется использовать это
параметр экономно, так как это приведет к управлению сеткой
необходимости измерять его дочерние элементы и принудительно перерисовывать
себе и другим детям
• *: Это пропорционально и приведет к остатку
пространство выделяется. В этом примере два
столбцы используют обозначение *. Это приводит к тем двум
столбцы, занимающие 1/3 и 2/3 оставшихся
ширина соответственно. Это потому, что * на самом деле
считается 1*.

В вашем сценарии вам понадобится несколько групп элементов управления.
По этой причине я считаю, что сетки лишь немного усложнят задачу.
для тебя.

# Горизонтальный стекмакет

Название действительно выдает это. Он позиционирует своих дочерних элементов горизонтально. ```HorizontalStackLayout``` не несет ответственности за предоставление размеров информацию своим детям, поэтому дети несут ответственность за вычисление их собственный размер.
На рис. 5-5 показано, как можно расположить элементы управления внутри
Горизонтальный стекмакет.

![изображение](https://user-images.githubusercontent.com/26972859/231121064-a7d256a7-0b2b-4c5b-b497-d979ecfe8b33.png)

Рисунок 5-5. Обзор HorizontalStackLayout

Приведенный выше макет может быть реализован с помощью следующего примера кода:

```xml
<HorizontalStackLayout
 Spacing="20"
 Margin="30">
 <Border
 BackgroundColor="LightGray"
 WidthRequest="100" />
 <Border
 BackgroundColor="LightGray"
 WidthRequest="100" />
 <Border
 BackgroundColor="LightGray"
 WidthRequest="100" />
</HorizontalStackLayout>
```
Вы хотите расположить элементы управления вертикально, чтобы вы могли догадаться, где это собирается, хотя на самом деле вы будете использовать его, чтобы сгруппировать некоторые из ваших внутренних контролирует.

# VerticalStackLayout

Название действительно выдает это. Он позиционирует своих потомков вертикально. ```VerticalStackLayout``` следует тем же правилам размеров, что и ```HorizontalStackLayout```, поэтому дети несут ответственность за расчет
их собственный размер. И вот оно: что-то, что размещает своих дочерних элементов по вертикали, что именно то, что вам нужно!
На рис. 5-6 показано, как можно расположить элементы управления внутри
VerticalStackLayout.

![изображение](https://user-images.githubusercontent.com/26972859/231121531-a4a1b9a7-a08f-45dd-a39a-cd66a1952b7c.png)
Рисунок 5-6. Обзор вертикального стека

Приведенный выше макет может быть реализован с помощью следующего примера кода:

```xml
<VerticalStackLayout
 Spacing="20"
 Margin="30">
 <Border
 BackgroundColor="LightGray"
 HeightRequest="100" />
 <Border
 BackgroundColor="LightGray"
 HeightRequest="100" />
 <Border
 BackgroundColor="LightGray"
 HeightRequest="100" />
</VerticalStackLayout>
```
Давайте продолжим и создадим его. Внутри границы, которую вы добавили ранее, добавьте следующее в файл ```BoardDetailsPage.xaml```.

```xml
<VerticalStackLayout>
 <VerticalStackLayout
 Padding="20">
 <Label
 Text="Name"
 FontAttributes="Bold" />
 <Entry />
 <Label
 Text="Layout"
 FontAttributes="Bold" />
 <HorizontalStackLayout>
 <RadioButton
 x:Name="FixedRadioButton"
 Content="Fixed" />
 <!--<RadioButton
 Content="Freeform" />-->
 </HorizontalStackLayout>
 <VerticalStackLayout>
 <Label
 Text="Number of Columns"
 FontAttributes="Bold" />
 <Entry Keyboard="Numeric" />
 <Label
 Text="Number of Rows"
 FontAttributes="Bold" />
 <Entry Keyboard="Numeric" />
 </VerticalStackLayout>
 </VerticalStackLayout>
 <Button
 Text="Save"
 HorizontalOptions="End" />
</VerticalStackLayout>
```
Да, я знаю! Я говорил о простоте визуального дерева, и здесь
вы вкладываете довольно много макетов. Я нахожу, что обычно существует некоторый уровень Прагматизм, который необходимо применить. Эта страница по-прежнему относительно проста в с точки зрения того, что отображается на экране, поэтому я утверждаю, что это нормально. Если вы должны были повторить этот макет несколько раз, вам нужно было бы немного
более строгим и найти лучший способ выложить все это. Довольно часто вы найдете что может существовать баланс между определением чего-либо, чтобы дать лучшая производительность по сравнению с упрощением обслуживания в качестве разработчика. Итак, вы создали свой пользовательский интерфейс, но заметите, что он не работает. Ничего, кроме как позволить пользователю вводить в поля ввода. Вам нужно связать представление до вашей модели представления. Это не является строго частью макетов, но стоит отметить, как вы применяете свойство ```Keyboard``` для ваших элементов управления ```Entry```. Это позволяет информировать операционная система, какую программную клавиатуру отображать и, следовательно, ограничивать тип данных, которые пользователь может ввести. Обратите внимание, что это относится только к мобильным приложения.


# Привязка данных

Приложения на основе пользовательского интерфейса, как следует из их названия, предполагают представление интерфейс для пользователей. Этот пользовательский интерфейс редко представляет собой просто статическое представление и поэтому нуждается в обновлении, вбивайте обновления в приложение или оба. Этот процесс, как правило, управляется событиями, так как обе стороны этого процесса синхронизация должна быть уведомлена, когда другая сторона изменяется. .NET MAUI завершает этот процесс для вас с помощью концепции, называемой привязкой данных. Привязка данных позволяет связать свойства двух объектов, чтобы что изменения в одном свойстве автоматически обновляются во втором.

# Привязка

Чаще всего создаются привязки между одним значение в источнике и одно значение в приемнике. Цель - владелец связываемого свойства. Я использую термины «цель» и «источник», потому что вы не обязательно связывать только представление и модель представления. Есть сценарии, в которых вы можете захотеть привязать один элемент управления к другому. Прежде чем вы приступите к созданию своей первой привязки, вам нужно сначала
создать что-то для привязки. Откройте свой класс ```BoardDetailsPageViewModel```, который является моделью представления для вашего представления, и добавьте следующее:

```Csharp
private string boardName;
public string BoardName
{
 get => boardName;
 set => SetProperty(ref boardName, value);
}
```
Стоит отметить, что привязка должна быть создана для свойства
(например, определение ```BoardName``` из приведенного выше кода). Привязка к полю (например, ```boardName```) не будет работать.

# Контекст привязки

И, наконец, решающий шаг — установить ```BindingContext``` вашей страницы на это просмотреть модель. В главе 4 вы сделали это, установив его непосредственно в XAML, но поскольку вы зарегистрировали свою модель представления на уровне DI, вы можете максимально использовать это и создать модель представления и любые зависимости, которые он имеет для вас. Откройте страницу ```BoardDetails.xaml.cs``` и измените конструктор на

```Csharp
public BoardDetailsPage(BoardDetailsPageViewModel boardDetailsPageViewModel)
{
 InitializeComponent();
 BindingContext = boardDetailsPageViewModel;
}
```

Приведенный выше код позволяет вам полагаться на внедрение конструктора.функциональные возможности, предоставляемые .NET MAUI и Shell.
Действие установки свойства BindingContext означает, что любой привязки, созданные на странице/представлении, и любые дочерние представления будут по умолчанию против этого ```BindingContext```. Теперь, если вы перейдете к файлу BoardDetailsPage.xaml, вы сможете применить привязка к вашему новому свойству ```BoardName``` в вашей модели представления. Вы хотите чтобы изменить первую запись, которую вы добавили, чтобы она выглядела как

```Csharp
<Entry Text="{Binding BoardName}" />
```

Это относительно небольшое изменение, и оно будет выглядеть так же, как привязки, которые вы созданный еще в главе 4 при изучении шаблона MVVM. Нет
много подробностей об этом, но есть достаточное количество неявного поведения, которое я чувствую должен выделить. Давайте сначала рассмотрим, что он говорит вам, а затем то, что он не говорит. Вы создаете привязку между свойством ```BoardName``` (которое существует в вашей модели ```BoardDetailsPageViewModel```) и свойство ```Text``` в Входной контроль.

Теперь о том, что этот код не говорит вам.

## Path

Привязка также может быть записана как

```Text="{Путь привязки=BoardName}"```

Элемент ```Path``` привязки подразумевается, если вы явно не предоставьте его, но только как первую часть определения привязки. Почему я тебе это говорю? Бывают случаи, когда вам нужно будет предоставить Путь = часть.

# Mode

Я упомянул, что привязки синхронизируют два свойства друг с другом.
Когда вы создаете привязку, вы можете определить, в каком направлении будут обновляться поток. В вашем примере вы не предоставили его, который затем полагается на режим по умолчанию для привязываемого свойства, к которому вы привязываетесь. В этом случае это свойство ```Text``` записи, которое имеет привязку по умолчанию режим ```TwoWay```. Я настоятельно призываю вас убедиться, что вы знаете об обоих эти значения по умолчанию и ваши ожидания при создании привязки. Выбор правильный режим также может повысить производительность. Например, ```OneTime``` режим привязки означает, что нет необходимости отслеживать обновления. В вашей сценария, в настоящее время вам не нужно разрешать модели представления обновлять cвойство «Текст записи»; однако по мере продвижения эта страница также позволит для редактирования доски, так что вы оставите его в покое. Если вам не нужно
для редактирования, теоретически вы можете изменить свою привязку на 

```xml
Text="{Binding Path=BoardName, Mode=OneWay}".
```

Существует несколько вариантов режимов привязки:

• **По умолчанию**: как следует из названия, используется значение по умолчанию, которое определено в целевом свойстве.

• **TwoWay**: позволяет обновлениям проходить в обоих направлениях между источником и целью. Типичный пример привязка к свойству Text записи, где вы
хотите как получать ввод от пользователя, так и обновлять пользовательский интерфейс, такой как ваш сценарий, который вы только что добавили с помощью
```Entry``` и ее свойство ```Text``` как 
```Text="{Binding Path=BoardName}"```.


• **OneWay**: позволяет получать обновления из источника. к цели. Примером этого является ваш ```ClockWidget``` где вы хотите, чтобы обновления поступали только из вашего источника к вашей цели.

• **OneWayToSource**: позволяет получать обновления из цель к источнику. Примером этого является обязательное свойство ```SelectedItem``` в ```ListView``` в значение в вашей модели представления.

• **OneTime**: цель обновляется только один раз, когда меняется контекст привязки.

## Источник

Как уже упоминалось, привязку не нужно создавать против чего-либо. определенный в вашем коде (например, свойство в модели представления). На самом деле это может быть создан против другого элемента управления. Если вы оглянетесь на созданный вами XAML на этой странице вы заметите, что вы дали имя одному из ```RadioButtons``` из ```FixedRadioButton```. Это на самом деле настраивало вас на этот момент: теперь вы можете привязать самую внутреннюю видимость ```VerticalStackLayouts``` к
значение этого ```RadioButton```.

Если вы просто хотите разрешить пользователю дополнительно включить настройку
в пользовательском интерфейсе вместо этого можно использовать элемент управления ```Switch```. Я выбрал ```RadioButton```, так как это будет очень хорошо сочетаться с вашим дополнительным заданием, в конце этой главы.

```xml
<VerticalStackLayout 
IsVisible="{Binding IsChecked, Source={x:Reference FixedRadioButton}}">
```

**Замечание**

Крепления могут быстро начать выглядеть сложными, и это хорошо. Например, но если вы разберете его, вам будет намного легче следовать. Вы привязываете свойство ```IsVisible``` к вашему ```VerticalStack```. Макет свойства ```IsChecked``` из источника, который является cсылка на ```RadioButton``` под названием ```FixedRadioButton```.

# Применение оставшихся привязок

Применим оставшиеся привязки к вашей странице и модели представления, чтобы все поля теперь обновляют вашу модель представления. В вашем классе ```BoardDetailsPageViewModel``` вам нужно добавить резервные поля и свойства для привязки.

```Csharp
private bool isFixed = true;
private int numberOfColumns = 3;
private int numberOfRows = 2;
public bool IsFixed
{
 get => isFixed;
 set => SetProperty(ref isFixed, value);
}
public int NumberOfColumns
{
 get => numberOfColumns;
 set => SetProperty(ref numberOfColumns, value);
}
public int NumberOfRows
{
 get => numberOfRows;
 set => SetProperty(ref numberOfRows, value);
}
```
Затем в вашем файле ```BoardDetailsPage.xaml``` вам нужно привязаться к этим
новые свойства с полужирными разделами ниже, выделенными вашими дополнениями.
Измените первый ```RadioButton``` на

```xml
<RadioButton
 Content="Fixed"
 x:Name="FixedRadioButton"
 IsChecked="{Binding IsFixed}" />
```
Then change the Entry that follows after the RadioButton to be

```xml
<Entry
 Text="{Binding NumberOfColumns}"
 Keyboard="Numeric" />
```
And finally change the Entry that follows that to be

```xml
<Entry
 Text="{Binding NumberOfRows}"
 Keyboard="Numeric" />
```
# MultiBinding

Могут быть случаи, когда вы хотите связать несколько исходных свойств.
к одному целевому свойству в представлении. Чтобы сделать небольшой крюк, давайте переработаем ваш ```ClockWidgetViewModel``` должен иметь два свойства: одно с датой и один со временем. Вы должны получить следующий код (жирный выделяет новые части):

```Csharp
namespace WidgetBoard.ViewModels;
public class ClockWidgetViewModel : ViewModelBase
{
 private readonly Scheduler scheduler = new();
 private DateOnly date;
 private TimeOnly time;
 public ClockWidgetViewModel()
 {
 SetTime(DateTime.Now);
 }
 public DateOnly Date
 {
 get => date;
 set => SetProperty(ref date, value);
 }
 public TimeOnly Time
 {
 get => time;
 set => SetProperty(ref time, value);
 }
 private void SetTime(DateTime dateTime)
 {
 Date = DateOnly.FromDateTime(dateTime);
 Time = TimeOnly.FromDateTime(dateTime);
 scheduler.ScheduleAction(
 TimeSpan.FromSeconds(1),
 () =>
 {
  SetTime(DateTime.Now);
 });
 }
}
```
Изменение модели представления фактически открывает ряд возможностей.
возможности для вас. Вы могли бы

• Добавляйте отдельные метки для отображения информации в
разные локации.

• Используйте ```MultiBinding``` и визуализируйте обе части
информация на одной этикетке.

Именно последний вы будете использовать здесь. Откройте ваш ```ClockWidgetView.xaml``` и внесите изменения, выделенные жирным шрифтом.

```xml
<?xml version="1.0" encoding="utf-8" ?>
<Label
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.Views.ClockWidgetView"
 FontSize="80"
 VerticalOptions="Center"
 HorizontalOptions="Center">
 <Label.BindingContext>
 <viewmodels:ClockWidgetViewModel />
 </Label.BindingContext>
 <Label.Text>
 <MultiBinding StringFormat="{}{0} {1}">
 <Binding Path="Date" />
 <Binding Path="Time" />
 </MultiBinding>
 </Label.Text>
</Label>
```
Чтобы перечислить, что вы сделали здесь, у вас есть
• Удалена строка ```Text="{Binding Time}"```.
• Вышеупомянутая функциональность перемещена в

Раздел ```MultiBinding```

Вы должны заметить, что синтаксис немного отличается от одиночной привязки.
подход. На самом деле, вы можете написать одну привязку аналогичным образом, например:

```xml
<Label.Text>
 <Binding Path="Time" />
</Label.Text>
```

Тем не менее, я уверен, что вы можете оценить, что оригинал
```Text="{Binding Time}"``` намного лаконичнее и удобнее для чтения. Каждый из свойства, описанные в разделе «Привязка», применяются к каждому
элементов ```Binding``` в ```MultiBinding```.

**Замечание:**

Вы должны предоставить либо ```StringFormat```, либо ```Converter``` в
```MultiBinding``` или исключение. Причина этого заключается в том, чтобы разрешить сопоставление нескольких значений с одним значение на цели.


# Command

Очень часто вам потребуется, чтобы ваши приложения реагировали на взаимодействие с пользователем. Это можно сделать, коснувшись или щелкнув кнопку или выбрав что-либо в список. Это взаимодействие записывается в вашем представлении, но обычно требуется чтобы логика для обработки этого взаимодействия выполнялась в представлении модель. Это происходит в форме команды и необязательного связанного набор свойств ```CommandParameter```. Само свойство ```Command``` может быть привязывается от представления к модели представления и позволяет модели представления не только обрабатывать взаимодействие, но и определять, является ли взаимодействие можно выполнить в первую очередь. Вы уже добавили кнопку в свой ```BoardDetailsPage.xaml```, но вы его не подключили, так что давайте сделаем именно это! Вам просто нужно изменить свою кнопку, чтобы она была (изменения выделены жирным шрифтом).

```xml
<Button
 Text="Save"
 HorizontalOptions="End"
 Command="{Binding SaveCommand}" />
```

Основываясь на изученном вами содержании привязки, вы можете сказать, что
это свойство команды кнопок теперь привязано к свойству в вашем представлении
модель под названием ```SaveCommand```. Вы на самом деле не создали это свойство еще. Если вы думаете, что было бы здорово, если бы инструменты могли это знать и сообщите об этом мне, тогда следующий раздел поможет вам. ```«Составлено Bindings»``` покажет вам, как информировать инструментарий о том, как сообщить об этом ты. Однако сначала откройте файл ```BoardDetailsPageViewModel.cs``` и добавьте реализация вашей команды.
Ваша реализация состоит из нескольких частей.
1. Вы определяете само свойство:

```public Command SaveCommand { get; }``` 

Обычно вы определяете команду как свойство только для чтения поскольку вы редко хотите, чтобы он менялся. Вы, вероятно, встретите команды, определяемые с использованием ```ICommand``` интерфейс, а не класс ```Command```. Причина, по которой вы использование последнего заключается в том, чтобы вы могли использовать конкретный метод (см. часть 3), чтобы обновить часть вашего представления.

2. Вы определяете, какое действие будет выполнено, когда команда выполняется (в основном, когда кнопка постучал/щелкнул в этом сценарии).

```Csharp
public BoardDetailsPageViewModel()
{
 SaveCommand = new Command(
 () => Save(),
 () => !string.IsNullOrWhiteSpace(BoardName));
}
private void Save()
{
 var board = new Board
 {
 Name = BoardName,
 Layout = new FixedLayout
 {
 NumberOfColumns = NumberOfColumns,
 NumberOfRows = NumberOfRows
 }
 };
}
```

Класс ```Command``` принимает два параметра. Первый это действие, которое нужно выполнить, когда команда выполняется, а второй, необязательный,
способ определить, может ли команда быть казнен. Хороший вариант использования для этого, если вы хотите убедитесь, что пользователь ввел все необходимые информация. В вашем сценарии вы убедитесь, что пользователь ввел имя для доски.

3. Вы уведомляете представление, когда статус того, является ли
команда может быть выполнена изменения. Чтобы было ясно, вы не нужно знать, что статус изменился; ты может просто сообщить представлению, что оно должно запросить статус. Здесь класс ```Command``` и его метод ```ChangeCanExecute```. Для этого вам нужно настроить свойство BoardName на
следующий:

```Csharp
public string BoardName
{
 get => boardName;
 set
 {
 SetProperty(ref boardName, value);
 SaveCommand.ChangeCanExecute();
 }
}
```
Это изменение означает, что каждый раз при изменении свойства ```BoardName```
(и это будет сделано через привязку из представления), кнопка, которая
привязанная к ```SaveCommand```, запросит проверку того, может быть казнен. Если это возможно, кнопка будет включена, и пользователь сможет
взаимодействовать с ним; если нет, он будет отключен.

# Скомпилированные привязки

Скомпилированные привязки — отличная функция, которую следует использовать практически во всех случаях включать! Они помогают ускорить ваши приложения, потому что они помогают компилятор знает, какие привязки будут установлены, и уменьшит количество отражение, которое требуется. Отражение, как известно, плохо влияет на производительность поэтому по возможности настоятельно рекомендуется избегать его использования. Привязки по умолчанию используйте количество отражений, чтобы обработать значение изменения между источником и целью. Скомпилированные привязки, как только что обсуждалось, помогите уменьшить это, поэтому давайте научимся их включать. Скомпилированные привязки также обеспечивают проверку во время разработки. Если вы установите
привязка к несуществующему свойству вашей модели представления (представьте, что вы допустил опечатку, чего делаю много!), без скомпилированных привязок приложение все равно будет строиться, но ваша привязка ничего не сделает. С скомпилированным привязка, приложение не будет собрано, и инструментарий сообщит, что свойство, которое вы опечатали, не существует.

```xml

<ContentPage
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.Pages.BoardDetailsPage"
 x:DataType="viewmodels:BoardDetailsPageViewModel">

```
Теперь, когда вы настроили свою страницу ```BoardDetailsPage```, чтобы разрешить вход пользователя и даже выполнять действие, когда кнопка «Сохранить» взаимодействует с вами, вы необходимо структурировать ваше приложение, чтобы вы могли видеть, как это происходит.

# Shell

Оболочка в .NET MAUI позволяет вам определить, каким будет ваше приложение.
изложены не с точки зрения реальных визуальных эффектов, а путем определения таких вещей, как вы хотите, чтобы ваши страницы просматривались во вкладках или только по одной странице за раз. Это также позволяет вам определить всплывающее меню, которое является боковым меню в вашем приложении.
Вы можете сделать так, чтобы он всегда был виден, или переключать его, чтобы он скользил вперед/назад, и это также может варьироваться в зависимости от типа устройства, на котором вы работаете. Обычно рабочий стол имеет больше визуального пространства, поэтому вы можете сохранить всплывающее окно
тогда всегда открыты. Для вашего приложения вы собираетесь использовать всплывающее окно, позволяющее вам определить несколько досок, которые вы можете настроить и загрузить. я действительно нравится идея иметь одну доску, когда я работаю, а затем переключаться на что-то еще при работе над побочным проектом или даже для игр.
Чтобы не возвращаться в эту область и менять биты, вы собираетесь
сразу переходите к более подробному варианту и многофункциональному результату. Однако не волнуйтесь; открывая для себя каждую новую концепцию, вы будете погружаться в некоторые подробности, чтобы рассказать, что это такое и почему вы используете вместе с применяя эту концепцию к вашему приложению.

## ShellContent

Если вы посмотрите на свой файл ```AppShell.xaml```, вы увидите очень мало
внутри. В настоящее время он имеет следующую строку:

```xml
<ShellContent
 Title="Home"
 ContentTemplate="{DataTemplate local:MainPage}"
 Route="MainPage" />

```
Этот код устанавливает основное содержимое приложения как экземпляр
главная страница. На самом деле, вы хотите удалить эту строку и заменить ее на

```xml
<ShellContent
 ContentTemplate="{DataTemplate pages:BoardDetailsPage}" />
```
Здесь нет большой разницы, но вы должны изучить, что
это значит. Основное содержимое вашего приложения теперь будет экземпляром вашего недавно созданный ```BoardDetailsPage```. Вам не нужен заголовок или маршрут вариантов больше, так как вы будете контролировать их по-разному.
Свойство Title будет установлено на основе отображаемой страницы, поэтому вы
узнаете об этом чуть позже. Свойство ```Route```, которым вы будете управлять в рамках следующего раздела, «Навигация».
Наконец, вам нужно будет добавить
 ```xmlns:pages="clrnamespace:WidgetBoard.Pages"`` в начало файла.

# Navigation

Лично я сторонник упрощения кода, который я пишу, пока он продолжается.
чтобы было легко читать. Имея это в виду, я хотел бы предложить вам
улучшите уже регистрацию своих страниц и их модели просмотра.

## Registering Pages for Navigation

Поэтому я предлагаю вам создать новый метод в вашей программе
```MauiProgram.cs``` -файл.

```Csharp
private static IServiceCollection AddPage<TPage, TViewModel>(
 IServiceCollection services, string route)
 where TPage : Page
 where TViewModel : BaseViewModel
{
 services
 .AddTransient(typeof(TPage))
 .AddTransient(typeof(TViewModel));
 Routing.RegisterRoute(route, typeof(TPage));
 return services;
}
```
Обратите внимание на строку ```Routing.RegisterRoute(route, typeof(TView));```. Это служит очень важной частью в этой теме навигации. Это значит
что когда вы указываете Shell перейти к определенному маршруту, он создаст новый экземпляр типа ```TPage```, который вы передали, и перейдите к нему. Конечно, потому что вы зарегистрировали эти типы с внедрением зависимостей
слой, это означает, что любые зависимости, определенные как параметры для
конструктор будет создан и передан для вас. Вышеприведенное означает, что вместо того, чтобы писать

```Csharp
services.AddTransient<BoardDetailsPage>()
services.AddTransient<BoardDetailsPageViewModel>()
Routing.RegisterRoute(route, typeof(TPage));
```
теперь ты можешь написать

```Csharp
AddPage<BoardDetailsPage, BoardDetailsViewModel>(builder.Services, "boarddetails");
```
с добавленным изменением, которое вы теперь определяете для этого маршрута. Итак, пойдем и
удалите свои старые регистрации и замените на

```Csharp
AddPage<BoardDetailsPage, BoardDetailsPageViewModel>(builder.Services, "boarddetails");
AddPage<FixedBoardPage, FixedBoardPageViewModel>(builder.Services, "fixedboard");
```

Я также рекомендую где-то определять маршруты как постоянные строки в вашей кодовой базе, чтобы избежать опечаток при переходе к ним. Это означает, что вы можете сохранить одну строку кода на странице и просмотреть модель пару, которую вы зарегистрировали, а также код для регистрации маршрута для навигация. Теперь, когда вы зарегистрировали свои страницы, давайте посмотрим, как вы может выполнять навигацию.

# Performing Navigation

Существует несколько способов указать маршрут для навигации, но все они используют
метод ```Shell.Current.GoToAsync```.

Так, например, вы можете перейти на свою страницу ```FixedBoardPage``` с помощью
следующий:

```Csharp
await Shell.Current.GoToAsync(“fixedboard”);
```

Это приведет к созданию ```FixedBoardPage``` и перемещению его на
стек навигации. Это именно то поведение, которое вам нужно в конце
ваше выполнение ```SaveCommand``` в вашем классе ```BoardDetailsPagesViewModel```.

# Навигация назад

Вы также можете извлекать страницы из стека навигации, перемещаясь назад.
Этого можно достичь следующим образом:

```Csharp
await Shell.Current.GoToAsync("..");
```
с компонентом .., сообщающим ```Shell```, что ему нужно вернуться назад. Фактически,
навигация назад и вперед может выполняться вместе:

```Csharp
await Shell.Current.GoToAsync("../board");
```

# Передача данных при навигации

Одна ключевая вещь, которую вам действительно нужно сделать при создании доски
и переход на страницу, которая будет отображать доску, должен передать контекст
на эту страницу, чтобы он знал, что отображать. Есть несколько способов как отправлять данные, так и получать их. Начнем с отправки.

• Вы можете передавать примитивные данные через строку запроса себе, например

```Csharp
await Shell.Current.GoToAsync("fixedboard?boardid=1234");
```
Предоставляя ```boardid```, вы возлагаете ответственность на принимающая страница (или модель просмотра страницы) для получения правая доска, используя указанный ```ID```

• Более сложные данные могут быть отправлены в виде
```IDictionary<string, object>``` в

Метод ```GoToAsync```, например

```Csharp
await Shell.Current.GoToAsync("fixedboard", new Dictionary<string, object>
 {
   { "Board", board}
 });

```
Вы также можете отправить сложный объект, как показано выше, что означает исходная страница (или модель просмотра страницы) отвечает за получение или строите доску, и вы отправляете все это на принимающую страницу. Затем для получения данных можно реализовать ```IQueryAttributable``` интерфейс, предоставляемый ```.NET MAUI```. ```Shell``` либо вызовет это на страница, на которую вы переходите, или если ```BindingContext``` (ваш вид ```model```) реализует интерфейс, он будет вызывать его там. Добавьте это в свой класс ```FixedBoardPageViewModel```, потому что вам нужно будет обработать данные. Вы будете использовать вариант сложного объекта, потому что вы уже загрузили ```Board``` в свой класс ```AppShellViewModel```.

```Csharp
public void ApplyQueryAttributes(IDictionary<string, object> query)
{
 var board = query["Board"] as Board;
}
```
Вы пока ничего не собираетесь делать с этими данными, но они уже готовы. когда вы начнете строить вид макета платы в следующей главе. А пока вы продолжите тему «Шелл» и определите свою
всплывающее меню. Вам также нужно будет реализовать свою модель ```FixedBoardPageViewModel```.
интерфейс ```IQueryAttributable```. Измените определение класса с

```Csharp
public class FixedBoardPageViewModel : BaseViewModel
```

to the following (changes in bold):

```Csharp
public class FixedBoardPageViewModel : BaseViewModel,IQueryAttributable
```

# Flyout

Всплывающее меню — это меню для приложения ```Shell```, доступное через значок или проведя пальцем от края экрана. Всплывающее окно может состоять из необязательный заголовок, всплывающие элементы, необязательные элементы меню и необязательный нижний колонтитул.
Для вашего приложения вы собираетесь предоставить базовый заголовок, а затем
основным контентом будет динамический список всех досок, которые создает ваш пользователь.
Это означает, что вам придется переопределить основной контент, но
К счастью, ```Shell``` упрощает эту задачу. Первое, что мне нравится делать при работе с новым XAML-файлом, — это на скомпилированных привязках, о которых я рассказывал ранее. Если вы помните, это по указав атрибут ```x:DataType```, чтобы сообщить компилятору тип, который
представление будет привязано к. Давайте сделаем это сейчас (выделено жирным шрифтом):

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<Shell
 x:Class="WidgetBoard.AppShell"
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 x:DataType="viewmodels:AppShellViewModel">
```

Это поможет вам, когда вы строите представление, видеть то, чего нет в вашем
просмотреть модель. Конечно, если вы предпочитаете сначала построить модель представления, то это также помогает. Наконец, вам нужно добавить ```xmlns:viewmodels="clrnamespace:WidgetBoard.ViewModels"``` в начало файла.

# Заголовок всплывающего окна

```FlyoutHeader``` может иметь любой элемент управления или макет, и поэтому вы может создать действительно красивый вариант заголовка. Для вашего приложения вы просто добавим заголовок ```Label```. Ниже вашего элемента ```ShellContent``` вы хотите добавить следующее:

```xml
<Shell.FlyoutHeader>
 <Label
 Text="My boards"
 FontSize="20"
 HorizontalTextAlignment="Center" />
</Shell.FlyoutHeader>
```

Надеюсь, вышеизложенное не требует пояснений, но чтобы охватить те части, которые я еще не охвачены, у вас есть возможность указать другой макет информацию в метке, чтобы вы могли сделать текст по центру. Это обычно рекомендуется использовать свойство ```HorizontrolOptions``` поверх свойство ```HorizontalTextAlignment```; однако, если вы попробуете это здесь, вы убедитесь, что он не центрирует метку. Теперь давайте добавим в основную часть вашего меню.

# FlyoutContent

Во-первых, если вы хотите использовать статический набор элементов в своем меню, вы можете просто добавить ```FlyoutItems``` к содержимому. Это может хорошо работать, когда у вас есть фиксированный набор страниц, таких как «Настройки», «Главная» и т. д. Вы будете показывать
доски, которые создает пользователь, поэтому вам понадобится что-то динамичное. Для этого
вам необходимо предоставить FlyoutContent. Что еще более важно, это ваш первый введение в элемент управления ```CollectionView```. ```CollectionView``` позволяет определить, как элемент будет выглядеть и затем повторите это для каждого элемента в коллекции, которая привязана к нему.
Кроме того, ```CollectionView``` предоставляет возможность разрешить пользователю для выбора элементов в коллекции, и вы можете определить поведение, которое будет выполняться, когда этот выбор происходит. Добавим в ваша оболочка:

```xml
<Shell.FlyoutContent>
 <CollectionView
 ItemsSource="{Binding Boards}"
 SelectionMode="Single"
 SelectedItem="{Binding CurrentBoard}">
 <CollectionView.ItemTemplate>
 <DataTemplate x:DataType="models:Board">
 <Label
 Text="{Binding Name}"
 FontSize="20"
 Padding="10,0,0,0" />
 </DataTemplate>
 </CollectionView.ItemTemplate>
 </CollectionView>
</Shell.FlyoutContent>
```
Вам также необходимо добавить xmlns:models="clr-namespace:WidgetBoard.Models" в начало файла.
Ваш ```FlyoutContent``` будет отображать метку, установленную для имени каждой доски экземпляр в коллекции досок в вашей модели представления. Кроме того, cвойство ```CurrentBoard``` в вашей модели представления будет обновлено, когда пользователь выбирает одну из меток в этой коллекции.

Если вы добавили все части, которые я обсуждал, вы, вероятно, заметите что инструментарий сообщает, что вы не добавили ни одного из свойств к которому вы привязываетесь в своей модели представления. Перейдем к твоему ```AppShellViewModel.cs``` и добавьте следующее

# Collection of Boards

```Csharp
public ObservableCollection<Board> Boards { get; } = new ObservableCollection<Board>();
```

```ObservableCollection``` — это особый тип коллекции, реализует ```INotifyCollectionChanged```. Это означает, что что-либо привязанный к нему, будет отслеживать изменения в коллекции и обновлять ее содержимое на экране.
Кроме того, сейчас вы добавите фиксированную запись в эти доски. Коллекция, с которой можно взаимодействовать. Позже вы будете сохранять в и загрузка из базы данных.

```Csharp
public AppShellViewModel()
{
 Boards.Add(
 new Board
 {
 Name = "My first board",
 Layout = new FixedLayout
 {
 NumberOfColumns = 3,
 NumberOfRows = 2
 }
 });
}
```

# Selected Board

Вы привязываете свойство ```SelectedItem``` из ```CollectionView``` к вашему cвойство ```CurrentBoard```. Когда ваше свойство изменится, вы можете перейти к плата, которая была выбрана.

```Csharp
private Board currentBoard;
public Board CurrentBoard
{
 get => currentBoard;
 set
 {
 if (SetProperty(ref currentBoard, value))
 {
 BoardSelected(value);
 }
 }
}
```
Вы, возможно, помните, что в главе 4 я обсуждал потенциальную ценность ```SetProperty``` возвращает логическое значение. Вы наконец нашли применение это! Вы хотите обрабатывать изменение выбора доски только в том случае, если ```CurrentBoard``` свойство действительно изменилось.

# Переход к выбранной доске

Следуя предыдущему разделу «Навигация», вы перейдете к ```route «fixedboard»```, на который настроена ваша ```FixedBoardPage```. Вы будете также передайте выбранную доску, чтобы ее можно было представить на экране.

```Csharp
private async void BoardSelected(Board board)
{
 await Shell.Current.GoToAsync("fixedboard", new Dictionary<string, object>
 {
 { "Board", board}
 });
}
   
```
Прежде чем ваши привязки заработают, вам нужно сделать еще несколько
изменения.

# Setting the BindingContext of Your AppShel

Давайте изменим конструктор вашего файла ```AppShell.xaml.cs```, чтобы установить
Контекст привязки.

```Csharp
public AppShell(AppShellViewModel appShellViewModel)
{
 InitializeComponent();
 BindingContext = appShellViewModel;
}
```

Вы должны помнить, что вы добавили ```AppShellViewModel``` в качестве переходного в файле ```MauiProgram.cs```, что означает, что вам будет предоставлен новый экземпляр, когда ваш класс AppShell создается для вас.

# Register AppShell with the MAUI App Builder

Давайте зарегистрируем AppShell в вашем файле ```MauiProgram.cs```.

```Csharp
builder.Services.AddTransient<AppShell>();
```

# Разрешить AppShell вместо его создания

Измените конструктор в файле ```App.xaml.cs``` следующим образом:

```Csharp
public App(AppShell appShell)
{
 InitializeComponent();
 MainPage = appShell;
}
```
Все вышеперечисленные изменения позволяют вам использовать ```AppShell``` так же, как и любой другой страницу и не нужно создавать экземпляр вручную.

# Tabs

Стоит отметить, что Шелл предлагает вам больше функциональности, чем вы на самом деле
потребность в создании этого приложения ```Shell``` позволяет создавать панели вкладок в вашем приложении. Вы можете иметь снизу, сверху или и то, и другое, чтобы дать гибкость в том, как вы размещаете свой контент. Ты иметь контроль над стилем и навигацией внутри каждой из вкладок.
Я не буду прикрывать вкладки, но я настоятельно рекомендую проверить документация предоставлена ​​корпорацией Майкрософт по адресу 

https://learn.microsoft.com/dotnet/maui/fundamentals/shell/tabs.

# Search

Поиск — еще одна полезная функция, которая входит в состав ```Shell```, но опять же
не то, что вам нужно в этом приложении. ```Shell``` позволяет создавать свой собственный ```SearchHandler```, что означает, что вы можете определить, как результаты встречаются со значениями, введенными в поле поиска, которое автоматически предоставил. Вы даже можете определить макет результатов поиска и поведение при выборе элемента в результатах поиска.
Я не буду охватывать поиск, но я настоятельно рекомендую проверить документацию, предоставленную Microsoft по адресу

https://learn.microsoft.com/dotnet/maui/fundamentals/shell/search.

# Принимаем ваше приложение на раскрутку

Если вы запустите приложение, вы увидите, что вам сначала представлен
экран, чтобы создать новую доску. Вы можете ввести данные и нажать Сохранить.
На рис. 5-7 показано, как выглядит ваше приложение при первой загрузке.

![изображение](https://user-images.githubusercontent.com/26972859/231130136-66d65bb4-ce9a-48fc-ac8a-ecc64796f8d8.png)

Рисунок 5-7. Домашняя страница приложения

Или вы можете выдвинуть меню с левой стороны. Рисунок 5-8 показывает всплывающее меню в вашем приложении.

![изображение](https://user-images.githubusercontent.com/26972859/231130290-4a976a6e-6a72-47da-89ef-2a669ed52266.png)

Рисунок 5-8. Выпадающее меню приложения

Выбрав доску или нажав «Сохранить», вы перейдете к ваша страница ```FixedBoardPage```. На рис. 5-9 показано, как отображается ваша страница ```FixedBoardPage``` с содержимым по умолчанию. Это потому, что вы не подключили плату объект, который вы получаете, но это доказывает, что ваша навигация и ```Shell``` установка работает.

![изображение](https://user-images.githubusercontent.com/26972859/231130422-20a5c724-8453-47e0-8ae1-638ff6528c76.png)

Рисунок 5-9. Страница фиксированной доски после навигации

# Краткое содержание

В этой главе вы:

• Создал и применил значок для вашего приложения

• Добавлено несколько страниц-заполнителей и моделей просмотра.

• Заполнили вашу первую страницу некоторыми привязками пользовательского интерфейса и настройки.

К модели представления

• Скрытая привязка данных и множество ее применений.

• Получил понимание XAML

• Узнали о возможных макетах, которые вы можете использовать для сгруппировать другие элементы управления

• Приобрел понимание ```Shell``` и применил это к построение структуры вашего приложения

• Применена навигация ```Shell```, чтобы вы могли перейти к Ваша следующая страница и следующая глава

• Создали свое всплывающее меню, используя все знания, полученные в эта глава

В следующей главе вы будете

• Создайте свой собственный макет.

• Используйте различные параметры при добавлении характеристики.

• Обеспечьте поддержку команд из вашего макета.

• Используйте свой макет в своем приложении.

# Исходный код

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introducing-MAUI/tree/main/ch05.

# Дополнительное задание

В качестве дополнительного задания я бы хотел, чтобы вы подумали, как бы вы могли добавить
второй тип макета, учитывая, что вы:

• Иметь один тип макета на странице ```BoardDetailsPage```.

• Отображать параметры при выборе этого типа

• Передать экземпляр ```FixedLayout``` в качестве данных вашему ```FixedBoardPage```

Я хотел бы видеть, какие концепции вы придумываете.
























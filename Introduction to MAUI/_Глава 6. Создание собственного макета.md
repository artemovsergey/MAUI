# ГЛАВА 6

# Создание собственного макета

В предыдущей главе вы узнали много об основах построения и связывание ваших пользовательских интерфейсов. В этой главе вы создадите свой собственный макет, используйте различные параметры при добавлении связываемых свойств, обеспечить поддержку команд из вашего макета и использовать ваш макет в вашем приложении. Это послужит основой для добавления гораздо большей функциональность, так как мы рассмотрим различные темы в будущих главах. Давайте вспомним, чего вы достигли в предыдущей главе: вы обеспечили возможность для пользователя создать доску и указать количество столбцов и ряды. Теперь вам нужно выложить доску с количеством столбцов. и строки, настроенные пользователем, и заполните виджеты на доске.
На рис. 6.1 показан пример того, чего вы достигнете к концу этой главы.

![изображение](https://user-images.githubusercontent.com/26972859/231163936-8e925696-fdec-49e7-b357-8a514af45bc2.png)

Рисунок 6-1. Макет доски

В конце предыдущей главы я обсуждал идею создания второго тип макета в разделе «Дополнительное задание». Чтобы продолжить это теме, я структурировал архитектуру макета, чтобы помочь в этом.
путешествие. Я сторонник такого подхода, потому что он позволяет вам потенциально заменить одну часть реализации, не затрагивая другие. ```BoardLayout``` будет отвечать за отображение виджетов. Это будет назначена реализация ```ILayoutManager```, которая будет решать, где разместить виджеты. Вы будете добавлять ```FixedLayoutManager```, чтобы решить эта часть

# Placeholder

Первый элемент, который вам нужно создать, — это Placeholder, показывающий, где виджет будет размещен. В этом элементе управления не так уж много, но его создание позволяет сгруппировать все связанные фрагменты вместе. Рисунок 6-2 показывает, как будет выглядеть ваш элемент управления Placeholder при отображении внутри
приложение.

![изображение](https://user-images.githubusercontent.com/26972859/231164282-09388fa3-3f7c-4816-bcd4-62c45345ca51.png)

Рисунок 6-2. Макет элемента управления Placeholder

Чтобы добиться вышеуказанного вида, вы собираетесь использовать
```Border``` контроль. Это действительно полезный элемент управления. Он позволяет вам предоставлять границы, настраиваемый радиус угла, тени и другие параметры стиля. Это также ведет себя так же, как ```ContentView``` в том, что он может содержать один дочерний элемент
контроль. Создайте папку ```Controls``` в своем основном проекте. В нем будет размещаться
Контроль ```Placeholder``` и, возможно, больше, когда вы создаете свое приложение.
Затем добавьте в папку новый класс и назовите его ```Placeholder```. Обратите внимание, что
вы решили создать элемент управления исключительно на C# без XAML; главный причина в том, что это приводит к меньшему количеству кода. Я всегда нахожу, что никогда не бывает ни одного способ создания вещей, и даже если вам нравится XAML, временами он ничего не добавляет значение, как и в этом сценарии. Конечно, если вы предпочитаете создавать свой пользовательский интерфейс с помощью XAML, вы можете это сделать.

```Csharp
namespace WidgetBoard.Controls;
public class Placeholder : Border
{
 public Placeholder()
 {
 Content = new Label
 {
  Text = "Tap to add widget",
  FontAttributes = FontAttributes.Italic,
  HorizontalOptions = LayoutOptions.Center,
  VerticalOptions = LayoutOptions.Center
 };
 }
 public int Position { get; set; }
}
```
Как уже говорилось, в этой реализации не так уж много, но давайте все же
Сломай. Здесь у вас есть

- Создан элемент управления, наследуемый от ```Border```

- Установите содержимое вашего элемента управления как метку, показывающую
фиксированный текст курсивом и текст выравнивается по центру
горизонтально и вертикально

- Добавлено свойство ```Position```, чтобы знать, где в макете
он будет расположен

Теперь вы можете приступить к созданию макета, который будет отображать заполнители.
и, в конечном счете, ваши виджеты.

# ILayoutManager

Здесь у вас есть небольшой сценарий курицы и яйца. Вам необходимо создать доска и менеджер компоновки, оба из которых должны знать друг о друге; поэтому давайте сначала добавим части ```LayoutManager```. Цель интерфейса ```ILayoutManager``` — определить, как ```BoardLayout``` будет взаимодействовать с реализацией менеджера компоновки.

Создайте папку под названием ```Layouts``` в вашем основном проекте. В нем будет размещаться
Интерфейс ```ILayoutManager``` и многое другое при создании приложения. Затем добавьте в папку новый класс и назовите его ```ILayoutManager```.

```Csharp
namespace WidgetBoard.Layouts;
public interface ILayoutManager
{
 object BindingContext { get; set; }
 BoardLayout Board { get; set; }
 void SetPosition(BindableObject bindableObject, int position);
}
```

Давайте разберем это, чтобы у вас было четкое определение того, что вы только что
созданный:
• Свойство ```BindingContext``` позволяет передавать контекст из ```BoardLayout``` позже. Это
важно для разрешения привязок в менеджере компоновки.
• Свойство ```Board``` позволяет менеджеру взаимодействовать непосредственно с доской он призван помочь.
• Метод ```SetPosition``` позволяет менеджеру использовать параметр ```position``` и установите соответствующий макет настройки виджета/заполнителя.

# Макет платы

Ваш ```BoardLayout``` будет родителем ваших виджетов. Создать макет
внутри папки «Макеты».

• Щелкните правой кнопкой мыши папку «Макеты».

• Выберите «Добавить» ➤ «Новый элемент».

• Выберите вкладку .NET MAUI.

• Выберите параметр .NET MAUI ContentView (XAML).

• Введите имя ```BoardLayout```.

• Щелкните Добавить.

Это даст вам два файла. Вы будете изменять каждый по отдельности

# BoardLayout.xaml

Измените существующее содержимое на следующее:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<Grid
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 x:Class="WidgetBoard.Layouts.BoardLayout"
 x:Name="self">
 <Grid
 x:Name="PlaceholderGrid" />
 <Grid
 x:Name="WidgetGrid"
 ChildAdded="Widgets_ChildAdded"
 BindableLayout.ItemsSource="{Binding ItemsSource,
Source={x:Reference self}}"
 BindableLayout.ItemTemplateSelector="{Binding
ItemTemplateSelector, Source={x:Reference self}}"
 InputTransparent="True"
 CascadeInputTransparent="False" />
</Grid>
```


Вы добавили к этому совсем немного, что может показаться незнакомым, так что еще раз
давайте сломать его. Ваш основной макет представляет собой сетку, а внутри нее еще две сетки.
В первую внутреннюю сетку (```PlaceholderGrid```) вы добавляете. Элемент управления-заполнитель, который вы создали ранее в этой главе. Во вторую внутреннюю сетку (WidgetGrid) вы добавляете виджеты.  Причина, по которой вы построили элемент управления таким образом, в основном заключается в том, что вы можете использовать действительно впечатляющая часть функциональности, которая резко уменьшает количество
кода, который вы должны написать: ```BindableLayout```.

**Замечание:**

Вы не предоставили ```Grid.Row``` или ```Grid.Column``` ни одному из ваши внутренние сетки. Это приводит к тому, что оба элемента управления заполняют пространство
родительская сетка, а вторая перекрывает первую. Это поведение
может обеспечить реальную мощь при создании довольно сложных пользовательских интерфейсов.


# BindableLayout

```BindableLayout``` позволяет превратить элемент управления макетом в элемент управления,
может быть заполнен набором данных. ```BindableLayout``` не является элементом управления
само по себе, но предоставляет возможность улучшить элементы управления макетом, добавив
Свойство ```ItemsSource``` для привязок. Это означает, что все макеты о которых вы узнали в предыдущей главе (например, ```Grid```, ```AbsoluteLayout```,```FlexLayout```, ```HorizontalStackLayout```, ```VerticalStackLayout```) могут быть
превратился в макет, который может отображать определенный набор элементов управления для каждого элемента это предусмотрено. Для этого нужно установить два свойства:

• ```BindableLayout.ItemsSource```: это коллекция элементы, которые вы хотите представить в пользовательском интерфейсе.

• ```BindableLayout.ItemTemplate``` или ```BindableLayout.ItemTemplateSelector```: позволяет определить как предмет будет представлен. В большинстве сценариев ```ItemTemplate``` достаточно, но это работает только тогда, когда вы иметь один тип элемента для отображения в вашей коллекции. Если у вас есть несколько типов, каждый виджет будет отдельным введите свое приложение, поэтому вам нужно использовать ```ItemTemplateSelector```.
На самом деле я пока не буду предоставлять исходный код для этих привязок; этот
будет сделано в Главе 8. Сейчас вам просто нужно сделать возможным связать их.

# BoardLayout.xaml.cs

Теперь, когда вы создали XAML-представление, вам нужно добавить код программной части, который будет работать с ним. Мы немного проследим разный подход к этому и следующему разделу; у тебя много кода добавить сейчас, поэтому вы будете добавлять его поэтапно, и мы поговорим о том, что вы добавляют. Исходный код должен выглядеть следующим образом:

```Csharp
namespace WidgetBoard.Layouts;
public partial class BoardLayout
{
 public BoardLayout()
 {
 InitializeComponent();
 }
}
```

# Добавление свойства LayoutManager

Вы хотите, чтобы потребитель вашего элемента управления ```BoardLayout``` мог предоставить ```LayoutManager```, который будет контролировать размещение виджетов. Для это, вам нужно добавить следующее:

```Csharp
private ILayoutManager layoutManager;
public ILayoutManager LayoutManager
{
 get => layoutManager;
 set
 {
 layoutManager = value;
 layoutManager.Board = this;
 }
}
```

Ключевой деталью этой реализации является то, как она назначает правление свойство в ```LayoutManager``` для вашего элемента управления ```BoardLayout```. Это для разрешить менеджеру взаимодействовать с макетом. Одна очень важная вещь, которую следует учитывать, заключается в том, что при создании свойств, которые можно задать в XAML, их установщики можно вызывать перед вашим элемент управления имеет установленное свойство ```BindingContext```. Поэтому обычно требуется для обработки обоих сценариев при использовании обеих частей функциональности. К приведите конкретный пример этого, у вас есть свойство ```LayoutManager```
что вы добавили. Это также позволит вам установить привязки к нему, но не
передать ```BindingContext```. Для этого нужно переопределить ```OnBindingContextChanged``` в вашем классе ```BoardLayout``` и назначьте значение для вашего ```LayoutManager```.

```Csharp
protected override void OnBindingContextChanged()
{
 base.OnBindingContextChanged();
 layoutManager.BindingContext = this.BindingContext;
}
```
В прошлом я обнаружил, что при построении элементов управления таким образом, даже если вам не нужно использовать этот метод для фактической реализации, он может быть действительно удобным для отладки того, что происходит, когда что-то не так ожидал. Например, вы можете поставить точку останова, чтобы убедиться, что вы присваивается ```BindingContext``` и что он имеет правильный тип.

# Добавление свойства ItemsSource

Ваш ```BoardLayout``` также должен принимать набор виджетов, которые в конечном итоге будет отображаться на экране. Для элементов управления, поддерживающих

```Csharp
using System.Collections;
```

This is to allow you to use the IEnumerable type.

```Csharp
public static readonly BindableProperty ItemsSourceProperty =
 BindableProperty.Create(
 nameof(ItemsSource),
 typeof(IEnumerable),
 typeof(BoardLayout));
 public IEnumerable ItemsSource
{
 get => (IEnumerable)GetValue(ItemsSourceProperty);
 set => SetValue(ItemsSourceProperty, value);
}
```
В большинстве сценариев вы привязываете ```ObservableCollection``` к свойство ```ItemsSource```, которое имеет тип, отличный от ```IEnumerable```. К
решив использовать ```IEnumerable```, он позволяет потребителям вашего макета предоставить любой тип, который поддерживает хранение нескольких элементов. Это значит, что
вы можете предоставить ```ObservableCollection``` или ```List```.
Наконец, вам нужно добавить оператор ```using``` в ваш ```BoardLayout```. файл ```xaml.cs``` вверху.

```Csharp
using System.Collections;
```
# Добавление свойства ItemTemplateSelector

Теперь, когда у вас есть набор элементов для отображения на экране, вы нужно уметь их отображать. Часто можно увидеть элементы управления которые имеют свойство ```ItemsSource```, также имеют ```ItemTemplate``` или ```ItemTemplateSelector``` или даже оба свойства. ```ItemTemplate``` позволяет разработчик, чтобы определить, как будет отображаться каждый элемент в ```ItemsSource``` на экране. Причина, по которой вы не используете этот подход, заключается в том, что вы можете определить только один шаблон для всех элементов. Вы будете привязывать свой виджет просматривать модели в свойстве ```ItemsSource```, что означает, что у вас будет несколько разных представлений, которые вы хотите отобразить. Вот где
Появляется свойство ```ItemTemplateSelector```.

```Csharp
public static только для чтения BindableProperty
ItemTemplateSelectorProperty =
 BindableProperty.Создать(
 nameof(ItemTemplateSelector),
 typeof(DataTemplateSelector),
 typeof(BoardLayout));
общедоступный DataTemplateSelector ItemTemplateSelector
{
 get => (DataTemplateSelector) GetValue (ItemTemplateSelector
Свойство);
 set => SetValue (ItemTemplateSelectorProperty, значение);
}
```

Вы используете тип ```DataTemplateSelector``` для своего свойства здесь. Вы создадите реализацию немного позже в этой главе, но для теперь он позволяет переопределить метод ```OnSelectTemplate``` и предоставить подходящий шаблон для передаваемого элемента.

# Обработка события ChildAdded

Ранее я обсуждал, как функция ```BindableLayout``` позволяет вам заполнять
элемент управления с несколькими представлениями на основе привязок. Вам нужно подключиться к
событие ```ChildAdded```, чтобы ваша реализация ```LayoutManager``` могла
определить, где должен располагаться новый ребенок.

```Csharp
private void Widgets_ChildAdded (отправитель объекта,
ElementEventArgs e)
{
 если (e.Element - это IWidgetView widgetView)
 {
 LayoutManager.SetPosition(e.Element, widgetView.
Позиция);
 }
}
```
Этот обработчик проверяет, относится ли новый добавляемый дочерний элемент к
```IWidgetView```, и если это так, он делегирует ```LayoutManager```
реализация для установки позиции виджета.

# Добавляем оставшиеся биты

У вас есть несколько дополнительных методов и свойств для добавления, которые будут использоваться с помощью ```FixedLayoutManager```. Давайте добавим их и обсудим их назначение
как вы идете. Добавьте оператор ```using``` в начало файла.

```Csharp
using WidgetBoard.Controls;
```
Затем добавьте первый новый метод.

```Csharp
public void AddPlaceholder(Placeholder placeholder) =>
PlaceholderGrid.Children.Add(placeholder);
```
Этот метод позволяет вызывающей стороне передать заполнитель, который будет добавлен
в ```PlaceholderGrid```. Это полезно при первой загрузке доски или при
работа с виджетом, удаляемым из определенной позиции.

```Csharp
public void RemovePlaceholder(Placeholder placeholder) =>
PlaceholderGrid.Children.Remove(placeholder);
```
Этот метод позволяет вызывающей стороне передать заполнитель, который будет удален из ```PlaceholderGrid```. Это полезно при работе с виджет добавляется в определенную позицию.

```Csharp
public void AddColumn (ColumnDefinition columnDefinition)
{
 PlaceholderGrid.ColumnDefinitions.Add(columnDefinition);
 WidgetGrid.ColumnDefinitions.Add(columnDefinition);
}
```
Этот метод позволяет определить столбцы доски как на
```PlaceholderGrid``` и ```WidgetGrid```.

```Csharp
public void AddRow (RowDefinition rowDefinition)
{
 PlaceholderGrid.RowDefinitions.Add(rowDefinition);
 WidgetGrid.RowDefinitions.Add(rowDefinition);
}
```
Этот метод позволяет определить строки доски как на
```PlaceholderGrid``` и ```WidgetGrid```.

```Csharp
public IReadOnlyList<Placeholder> Placeholders =>
PlaceholderGrid.Children.OfType<Placeholder>().ToList();
```
Это свойство предоставляет все дочерние элементы из ```PlaceholderGrid```, которые
типа Заполнитель. Это позволяет определить, какой заполнитель
необходимо удалить при добавлении виджета.

# FixedLayoutManager

Последняя часть, которую вам нужно создать, — это класс ```FixedLayoutManager```. Это будет
предоставить логику для

• Принять количество строк и столбцов для доски.
• Обеспечьте поддержку нажатия/щелчка с помощью команды.
• Создайте макет платы.
• Установите правильную позицию строки/столбца для каждого виджета.
Создайте файл, а затем вы можете добавить каждый из
вышеуказанные части функциональности. Давайте добавим новый файл класса и назовем его
```FixedLayoutManager.cs```. Добавьте следующее содержимое:

```Csharp
namespace WidgetBoard.Layouts;
public class FixedLayoutManager
{
}
```
Для начала вам нужно добавить следующие операторы ```using```:

```Csharp
using System.Windows.Input;
using WidgetBoard.Controls;
```
А также сделайте так, чтобы ваш класс наследовался от ```BindableObject``` и реализовывал
ваш интерфейс ```ILayoutManager```. Теперь ваш класс должен выглядеть следующим образом:

```Csharp
using System.Windows.Input;
using WidgetBoard.Controls;
namespace WidgetBoard.Layouts;
public class FixedLayoutManager : BindableObject,
ILayoutManager
{
}
```
Причина наследования от ```BindableObject``` заключается в том, что
что вам нужно добавить некоторые связываемые свойства в этот класс, чтобы
разработчики, использующие эту реализацию, могут привязывать значения к свойствам.

# Принятие количества строк и столбцов для доски

Вам нужно добавить возможность установить количество строк и столбцов, которые будут
отображается на вашей доске с фиксированным макетом. Для этого вы добавите два
привязываемые свойства к вашему классу ```FixedLayoutManager```.

# Добавление свойства NumberOfColumns

```Csharp
public static readonly BindableProperty
NumberOfColumnsProperty =
 BindableProperty.Create(
 nameof(NumberOfColumns),
 typeof(int),
 typeof(FixedLayoutManager),
 defaultBindingMode: BindingMode.OneWay,
 propertyChanged: OnNumberOfColumnsChanged);
public int NumberOfColumns
{
 get => (int)GetValue(NumberOfColumnsProperty);
 set => SetValue(NumberOfColumnsProperty, value);
}
static void OnNumberOfColumnsChanged(BindableObject bindable,
object oldValue, object newValue)
{
 var manager = (FixedLayoutManager)bindable;
 manager.InitialiseGrid();
}
```
Ключевое отличие этой реализации от предыдущей привязываемой
Созданные вами свойства — это использование параметра ```propertyChanged```. Это
позволяет определить метод (см. ```OnNumberOfColumnsChanged```), который будет
вызывается всякий раз, когда изменяется значение свойства.

---
Метод изменения свойства будет вызываться только тогда, когда значение
изменения. Это означает, что он может не вызываться изначально, если значение
не отличается от значения по умолчанию.
---

# Добавление свойства NumberOfRows

```Csharp
public static readonly BindableProperty NumberOfRowsProperty =
 BindableProperty.Create(
 nameof(NumberOfRows),
 typeof(int),
 typeof(FixedLayoutManager),
 defaultBindingMode: BindingMode.OneWay,
 propertyChanged: OnNumberOfRowsChanged);
public int NumberOfRows
{
 get => (int)GetValue(NumberOfRowsProperty);
 set => SetValue(NumberOfRowsProperty, value);
}
static void OnNumberOfRowsChanged(BindableObject bindable,
object oldValue, object newValue)
{
 var manager = (FixedLayoutManager)bindable;
 manager.InitialiseGrid();
}
```
Это практически идентично свойству ```NumberOfColumns```, которое вы только что
добавлено, за исключением значения ```NumberOfRows```.

# Предоставление поддержки Tap/Click с помощью команды

Следующим пунктом в вашем списке является предоставление возможности обработки нажатия/щелчка.
поддерживать. Вы впервые оказываете командную поддержку; ты использовал
команды в ваших привязках, но это было на стороне источника, а не
целевая сторона, как здесь.
Во-первых, вам нужно добавить свойство ```bindable```, которое должно начать ощущаться
довольно знакомо.

```Csharp
public static readonly BindableProperty
PlaceholderTappedCommandProperty =
 BindableProperty.Create(
 nameof(PlaceholderTappedCommand),
 typeof(ICommand),
 typeof(FixedLayoutManager));
public ICommand PlaceholderTappedCommand
{
 get => (ICommand)GetValue(PlaceholderTappedCommand
Property);
 set => SetValue(PlaceholderTappedCommandProperty, value);
}
```
Далее нужно добавить код, который будет выполнять команду. Ты
будет полагаться на использование ```TapGestureRecognizer```, добавив его в
ваш элемент управления ```Placeholder``` внутри вашего метода ```InitialiseGrid```, который вы
будет добавлено в следующем разделе. На данный момент вы можете добавить метод, который
будет использоваться, чтобы вы могли сосредоточиться на том, как выполнить команду. Давайте
добавьте код, а затем просмотрите детали.

```Csharp
private void TapGestureRecognizer_Tapped(object sender,
EventArgs e)
{
 if (sender is Placeholder placeholder)
 {
 if (PlaceholderTappedCommand?.CanExecute(placeholder.
Position) == true)
 {
 PlaceholderTappedCommand.Execute(placeholder.
Position);
 }
 }
}
```
Вы можете видеть из реализации, что есть три основные части для
логика выполнения команды:
• Во-первых, убедитесь, что эта команда имеет значение.
• Во-вторых, вы проверяете, можете ли вы выполнить команду.
Если вы помните, в главе 5 вы предоставили метод
предотвратить выполнение команды, если пользователь
не ввел ```BoardName```.
• Наконец, вы выполняете команду и передаете
параметр команды. Для этого сценария вы будете
переходя в текущую позицию заполнителя, поэтому
при добавлении виджета его можно поместить в тот же
позиция.

# Создание макета платы

Теперь вы можете сосредоточиться на компоновке базовых сеток, чтобы они отображались
в соответствии с введенными пользователем значениями для строк и столбцов.

Во-первых, добавьте свойство для хранения текущей доски, потому что вам нужно использовать
это при построении макета. Вам также необходимо записать, построили ли вы
макет, чтобы предотвратить любые ненужные обновления, перестраивающие пользовательский интерфейс.

```Csharp
private BoardLayout board;
private bool isInitialised;
public BoardLayout Board
{
 get => board;
 set
 {
 board = value;
 InitialiseGrid();
 }
}
```
Ваш метод построения макета сетки состоит из нескольких частей, поэтому давайте добавим
их, как вы идете и обсудить их ценность. Сначала нужно убедиться, что
у вас есть допустимые значения для ```Board```, ```NumberOfRows``` и ```NumberOfColumns```
properties плюс вы еще не создали пользовательский интерфейс.

```Csharp
private void InitialiseGrid()
{
 if (Board is null ||
 NumberOfColumns == 0 ||
 NumberOfRows == 0 ||
 isInitialised == true)
 {
 return;
 }
 isInitialised = true;
}
```
Следующим шагом будет использование значения ```NumberOfColumns``` и добавление его в
ваш Совет. Давайте добавим это в конец метода ```InitialiseGrid```.

```Csharp
for (int i = 0; i <NumberOfColumns; i++)
{
 Board.AddColumn (новый ColumnDefinition (новый GridLength (1,
GridUnitType.Star)));
}
```
Значение ````GridUnitType.Star```` означает, что каждый столбец будет иметь
четная доля ширины сетки. Итак, если сетка имеет ширину 300 пикселей и
у вас есть 3 столбца, тогда каждый столбец имеет результирующую ширину 100 пикселей.
Следующим шагом будет использование значения ```NumberOfRows``` и добавление их в ваш
Доска. Давайте добавим это в конец метода ```InitialiseGrid```.

```Csharp
for (int i = 0; i < NumberOfRows; i++)
{
 Board.AddRow(new RowDefinition(new GridLength(1,
GridUnitType.Star)));
}
```
Последним шагом в вашем методе ```InitialiseGrid``` является заполнение каждой ячейки
(строка и столбец) в сочетании с элементом управления ```Placeholder```.

```Csharp
for (int column = 0; column < NumberOfColumns; column++)
{
 for (int row = 0; row < NumberOfRows; row++)
 {
 var placeholder = new Placeholder();
 placeholder.Position = row * NumberOfColumns + column;
 var tapGestureRecognizer = new TapGestureRecognizer();
tapGestureRecognizer.Tapped += TapGestureRecognizer_Tapped;
 placeholder.GestureRecognizers.Add(tapGesture
Recognizer);
 Board.AddPlaceholder(placeholder);
 Grid.SetColumn(placeholder, column);
 Grid.SetRow(placeholder, row);
 }
}
```
В приведенном выше коде вы
• Перебор комбинаций строк/столбцов
• Создан элемент управления ```Placeholder```
• Установите его положение для использования позже
• Добавлен ```TapGestureRecognizer``` для обработки пользователя.
взаимодействие
• Добавлен заполнитель на доску
• Поместил заполнитель в правильный столбец и
положение строки

# Установка правильной позиции строки/столбца для каждого виджета

Заключительная часть построения макета платы — предоставление метода
требуется интерфейсом ```ILayoutManager```, чтобы ваш ```FixedLayoutManager```
реализует. Этот метод будет:

• Рассчитать значение столбца/строки на основе позиции
переданный параметр.
• Поместите параметр ```bindableObject```, переданный в
рассчитанное положение столбца и строки.
• Удалите любой существующий заполнитель в позиции.

```Csharp
public void SetPosition(BindableObject bindableObject, int
position)
{
 if (NumberOfColumns == 0)
 {
 return;
 }
 int column = position % NumberOfColumns;
 int row = position / NumberOfColumns;
 Grid.SetColumn(bindableObject, column);
 Grid.SetRow(bindableObject, row);
 var placeholder = Board.Placeholders.Where(p => p.Position
== position).FirstOrDefault();
 if (placeholder is not null)
 {
 Board.RemovePlaceholder(placeholder);
 }
}
```
Теперь, когда вы завершили работу по предоставлению ```BoardLayout```
и управлять его макетом с помощью класса ```FixedLayoutManager```, вы должны
идите вперед и используйте его в своем приложении.

# Использование вашего макета

Прежде чем вы сможете начать использовать созданный вами макет ```BoardLayout```,
есть еще немного работы, которую нужно сделать. Вам нужно
• Добавьте фабрику, которая будет создавать экземпляры ваших виджетов.
• Добавьте в ```DataTemplateSelector```, о котором я говорил.
ранее.
• Обновите модель ```FixedBoardPageViewModel```, чтобы
привязки будут работать.

# Добавление фабрики, которая будет создавать экземпляры ваших виджетов

Для этого вы создадите новый класс под названием ```WidgetFactory``` в
корень вашего проекта.

```Csharp
using WidgetBoard.ViewModels;
using WidgetBoard.Views;
namespace WidgetBoard;
public class WidgetFactory
{
}
```
У этой фабрики три основных цели:
• Позволяет регистрировать виды виджетов и
просмотреть модели
• Создание виджета
• Создание модели представления виджета
Итак, давайте поддержим эти три требования.

# Разрешение регистрации представлений виджетов и моделей представлений

Вам необходимо добавить следующий код:

```Csharp
private static IDictionary<Type, Type> widgetRegistrations =
new Dictionary<Type, Type>();
private static IDictionary<string, Type>
widgetNameRegistrations = new Dictionary<string, Type>();
public static void RegisterWidget<TWidgetView,
TWidgetViewModel>(string displayName) where TWidgetView :
IWidgetView where TWidgetViewModel : IWidgetViewModel
{
 widgetRegistrations.Add(typeof(TWidgetViewModel),
typeof(TWidgetView));
 widgetNameRegistrations.Add(displayName,
typeof(TWidgetViewModel));
}
public IList<string> AvailableWidgets =>
widgetNameRegistrations.Keys.ToList();
```
Вышеизложенное может показаться немного сложным, но если вы разберете его,
надеюсь, должно стать ясно. Вы добавили два поля, которые будут хранить
информация о типе и имени, необходимые для создания
экземпляры виджетов.
Метод ```RegisterWidget``` принимает параметр отображаемого имени и
Два типа:
• ```TWidgetView```: должен реализовать ваш ```IWidgetView```.
интерфейс.
• ```TWidgetViewModel```: должен реализовать ваш
Интерфейс IWidgetViewModel.

Затем вы сохраняете сопоставление между типом модели представления и представлением
тип (виджетрегистрации). Это позволяет вам создавать представление, когда вы
перейти в модель представления. Это действительно поможет вам сохранить четкое разделение
между вашим представлением и моделью представления.
Вы также сохраняете сопоставление между отображаемым именем и представлением.
тип модели (```widgetNameRegistrations```). Это позволит вам представить
вариант на экране для пользователя. Как только они выбирают название виджета, они
хотел бы добавить, фабрика создаст его экземпляр.

# Создание виджета

Сначала вам нужно добавить зависимость к вашему конструктору.

```Csharp
private readonly IServiceProvider serviceProvider;
public WidgetFactory(IServiceProvider serviceProvider)
{
 this.serviceProvider = serviceProvider;
}
```
```IServiceProvider``` позволит вам создать новый экземпляр
ваших виджетов и убедитесь, что они снабжены всеми
их зависимости. Не беспокойтесь о необходимости регистрации
Реализация ```IServiceProvider``` с вашим ```MauiAppBuilder```, как вы
сделали с другими зависимостями, которые вам нужны. Это автоматически
предоставлено .NET MAUI.
Теперь давайте добавим возможность создания представления виджета.

```Csharp
public IWidgetView CreateWidget(IWidgetViewModel
widgetViewModel)
{
 if (widgetRegistrations.TryGetValue(widgetViewModel.
GetType(), out var widgetViewType))
 {
  var widgetView = (IWidgetView)serviceProvider.GetRequir
edService(widgetViewType);
 widgetView.WidgetViewModel = widgetViewModel;
 return widgetView;
 }
 return null;
}
```
Разрушая это,
• Вы проверяете, поддерживает ли поставляемый ```widgetViewModels```
Тип зарегистрирован на заводе.
• Если это так, вы используете ```IServiceProvider```, чтобы получить
экземпляр связанного вида виджета.
• Вы присваиваете значение параметра ```widgetViewModel``` объекту
```WidgetViewModel``` в представлении виджета. Это
чтобы разрешить настройку виджетов ```BindingContext```
свойство.

# Создание модели представления виджета

Также необходимо предоставить возможность создания модели представления виджета
потому что это требуется в вашей модели представления.

```Csharp
public IWidgetViewModel CreateWidgetViewModel(string
displayname)
{
 if (widgetNameRegistrations.TryGetValue(displayname, out
var widgetViewModelType))
 {
  return (IWidgetViewModel)serviceProvider.GetRequiredSer
vice(widgetViewModelType);
 }
 return null;
}
```
Разрушая это,
• Вы проверяете, было ли предоставленное отображаемое имя
зарегистрирован на заводе.
• Если это так, вы используете ```IServiceProvider```, чтобы получить
экземпляр связанной модели представления виджета.

# Регистрация фабрики с помощью MauiAppBuilder

Внутри файла ```MauiProgram.cs``` вам необходимо зарегистрировать свой ```WidgetFactory```.
с ```MauiAppBuilder```, чтобы убедиться, что любые зависимости могут решить эту проблему.
Откройте этот файл и добавьте следующую строку в метод ```CreateMauiApp```:

```Csharp
builder.Services.AddSingleton<WidgetFactory>();
```
# Регистрация вашего ClockWidget на заводе

Теперь, когда у вас есть ```WidgetFactory```, вам нужно изменить его так, чтобы
factory может создать виджет для вас. Это требует ряда шагов, поэтому
давайте пройдемся по нему.
Сначала откройте файл ```ClockWidgetView.xaml.cs``` и измените его на
следующий:

```Csharp
using WidgetBoard.ViewModels;
namespace WidgetBoard.Views;
public partial class ClockWidgetView : Label, IWidgetView
{
  public ClockWidgetView(ClockWidgetViewModel
clockWidgetViewModel)
 {
 InitializeComponent();
 WidgetViewModel = clockWidgetViewModel;
 BindingContext = clockWidgetViewModel;
 }
 public IWidgetViewModel WidgetViewModel { get; set; }
}
```
Это приводит к тому, что ваш ```ClockWidgetView``` зависит от
```ClockWidgetViewModel```.
Далее вам необходимо зарегистрировать свой виджет на фабрике. Открыть
ваш файл ```MauiProgram.cs``` и добавьте следующие строки в
Метод ```CreateMauiApp```:

```Csharp
WidgetFactory.RegisterWidget<ClockWidgetView, ClockWidgetView
Model>("Clock");
builder.Services.AddTransient<ClockWidgetView>();
builder.Services.AddTransient<ClockWidgetViewModel>();
```
Это позволит ```WidgetFactory``` возвращать виджет часов как
вариант, когда он представлен в вашем оверлее.

# WidgetTemplateSelector

Основная цель этой реализации - обеспечить преобразование
между моделями представления виджетов, которые вы будете хранить на своем
```FixedBoardPageViewModel``` и что-то, что действительно можно отрендерить
на экране. Вы будете зависеть от имеющейся у вас ```WidgetFactory```.
только что созданный. Создайте класс в корневой папке проекта.

```Csharp
using WidgetBoard.ViewModels;
namespace WidgetBoard.Views;
public class WidgetTemplateSelector : DataTemplateSelector
{
 private readonly WidgetFactory widgetFactory;
 public WidgetTemplateSelector(WidgetFactory widgetFactory)
 {
 this.widgetFactory = widgetFactory;
 }
 protected override DataTemplate OnSelectTemplate(object
item, BindableObject container)
 {
 if (item is IWidgetViewModel widgetViewModel)
 {
 return new DataTemplate(() => widgetFactory.Create
Widget(widgetViewModel));
 }
 return null;
 }
}
```
Основная часть, на которой вам нужно сосредоточиться, это ```OnSelectTemplate```.
метод. Ранее я кратко обсуждал назначение этого метода; Давайте
взгляните глубже сейчас. Его основная цель — предоставить ```DataTemplate``` и
то, что можно отобразить на экране. Это отличный способ сохранить
разделение между представлением и моделью представления.
В вашей реализации вы можете видеть, что
• Вы проверяете, реализует ли переданный элемент ваши
Интерфейс ```IWidgetViewModel```.
• Если да, то вы создаете новый ```DataTemplate``` и полагаетесь на
```WidgetFactory```, чтобы вернуть представление виджета, которое
сопоставляется с типом моделей представлений.

# Регистрация селектора шаблонов в MauiAppBuilder

Внутри вашего файла ```MauiProgram.cs``` вам необходимо зарегистрировать
```WidgetTemplateSelector``` с ```MauiAppBuilder```, чтобы убедиться, что
зависимости могут решить эту проблему. Откройте этот файл и добавьте следующую строку в
метод ```CreateMauiApp```:

```Csharp
builder.Services.AddSingleton<WidgetTemplateSelector>();
```
# Обновление модели FixedBoardPageViewModel

Вам нужно добавить свойства, к которым вы можете привязаться в своем представлении.

```Csharp
private string boardName;
private int numberOfColumns;
private int numberOfRows;
public string BoardName
{
 get => boardName;
 set => SetProperty(ref boardName, value);
}
public int NumberOfColumns
{
 get => numberOfColumns;
 set => SetProperty(ref numberOfColumns, value);
}
public int NumberOfRows
{
 get => numberOfRows;
 set => SetProperty(ref numberOfRows, value);
}
public ObservableCollection<IWidgetViewModel> Widgets { get; }
public WidgetTemplateSelector WidgetTemplateSelector { get; }

```
Обратите внимание, что свойства ```Widgets``` и ```WidgetTemplateSelector```
не вызывайте метод ```SetProperty``` для уведомления пользовательского интерфейса об изменениях. Этот вполне допустимый сценарий. Вы знаете, что значение будет установлено в
конструктор, и поэтому значение будет установлено до того, как привязка будет
применяемый.
Вам также необходимо добавить оставшийся код в ваш
```ApplyQueryAttributes```, который вы добавили в предыдущей главе. Это
теперь должно выглядеть следующим образом:

```Csharp
public void ApplyQueryAttributes(IDictionary<string, object> query)
{
 var board = query["Board"] as Board;
 BoardName = board.Name;
 NumberOfColumns = ((FixedLayout)board.Layout).
 NumberOfColumns;
 NumberOfRows = ((FixedLayout)board.Layout).NumberOfRows;
}
```
Наконец, вам нужно добавить ```WidgetTemplateSelector``` в качестве
зависимость в вашем конструкторе. Теперь это должно выглядеть следующим образом:

```Csharp
public FixedBoardPageViewModel(
 WidgetTemplateSelector widgetTemplateSelector
)
{
 WidgetTemplateSelector = widgetTemplateSelector;
 Widgets = new ObservableCollection<IWidgetViewModel>();
}
```
Теперь вы готовы добавить макет на свою страницу.

# Наконец, использование макета

Теперь, когда вы создали свой макет, вы должны использовать его. Ты
ранее добавил FixedBoardPage, чтобы вы могли изменить его
к следующему:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:layouts="clr-namespace:WidgetBoard.Layouts"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.Pages.FixedBoardPage"
 Title="FixedBoardPage"
 x:DataType="viewmodels:FixedBoardPageViewModel">
<layouts:BoardLayout
 ItemsSource="{Binding Widgets}"
 ItemTemplateSelector="{Binding Widget
TemplateSelector}">
 <layouts:BoardLayout.LayoutManager>
 <layouts:FixedLayoutManager
 NumberOfColumns="{Binding NumberOfColumns}"
 NumberOfRows="{Binding NumberOfRows}" />
 </layouts:BoardLayout.LayoutManager>
 </layouts:BoardLayout>
</ContentPage>
```
Теперь это включает в себя ваш новый блестящий ```BoardLayout``` со всеми
привязки, которые вы создали, чтобы сделать его функциональным.

# Краткое содержание

В этой главе вы
• Создал свой собственный макет
• Использованы различные параметры при добавлении привязываемых
характеристики
• Обеспечена поддержка команд из вашего макета
• Использовали ваш макет в приложении
В следующей главе вы будете
• Получите представление о том, что такое доступность
• Узнайте, почему важно создавать инклюзивные
Приложения
• Посмотрите, как можно использовать .NET MAUI.
функциональность
• Рассмотрите другие сценарии и способы их поддержки
• Рассмотрите несколько вариантов тестирования, которые помогут вам в вашем путешествии.
для создания доступных приложений

# Исходный код

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introducing-MAUI/tree/main/ch06.

# Дополнительное задание

Вы могли заметить, что во многих названиях присутствует слово ```Fixed```.
Продолжим дополнительное задание из предыдущей главы и построим
доска, которая является вариацией этого подхода. Мне очень нравится идея
доска произвольной формы, на которой пользователь может размещать свои виджеты в любом месте.
нравиться. Это немного сложнее, но если учесть, как ```BoardLayout```
может использовать ```AbsoluteLayouts```, а не ```Grids```, тогда новый ```ILayoutManager```
реализация, надеюсь, должна быть там, где потребуется альтернативная логика
применяться. Если вы отправитесь в это путешествие, пожалуйста, не стесняйтесь поделиться
ваш опыт и выводы.













































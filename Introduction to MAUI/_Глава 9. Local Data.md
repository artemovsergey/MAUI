# ГЛАВА 9

# Local Data

В этой главе вы узнаете о различных типах локальных данных, что для чего лучше всего их использовать и как применять их в своем приложении. 
Варианты будут включать понимание того, когда и где хранить данные, которые
необходимо держать в безопасности. Вы измените свое приложение, чтобы хранить доски, которые ваш пользователь создает так, чтобы их можно было отображать в выдвижном меню, а также открыт. Вы также запишете последнюю открытую доску, чтобы при возврате к приложению эта доска будет представлена ​​пользователю.

# Что такое локальные данные?

При создании приложения, независимо от того, предназначено ли оно для одного или несколько платформ, вам, скорее всего, потребуется хранить некоторые данные о состояние приложения. Типы данных, которые вам необходимо хранить, могут различаться. Между сохранением «простых» настроек, кэшированием файлов/данных или даже сохранением полный набор данных внутри локальной базы данных. Эти типы данных называются локальными. данные, так как они находятся на устройстве, на котором запущено ваше приложение. Данные которые поступают из удаленной конечной точки, называются удаленными данными, и это будет
рассматривается в главе 10 .NET MAUI предоставляет несколько вариантов, когда вы хотите хранить данные локально на устройстве. Каждый вариант лучше подходит для конкретной цели и размер данных. Вот краткий обзор этих вариантов:

Файловая система: Хранит свободные файлы прямо на устройстве.
через доступ к файловой системе

• База данных: сохраняет данные в файле, оптимизированном для доступа

• Настройки: сохраняет данные в виде пар "ключ-значение".

• Безопасное хранилище: хранит данные в парах ключ-значение, например
предпочтения, но сохраняет их в безопасном месте на
Устройство

# Файловая система

NET MAUI предоставляет некоторые полезные абстракции для нескольких платформ.
что он поддерживает. Одной из таких абстракций является вспомогательный класс ```FileSystem```. Это исходит из старой библиотеки ```Xamarin.Essentials``` и теперь является основной частью
.NET Maui. Это позволяет вам получить полезные биты информации, чтобы помочь с общие задачи, связанные с файловой системой. Давайте взглянем на свойства, которые предлагает вам класс ```FileSystem```. помогает узнать, когда их следует использовать и для какого типа данных.

# Каталог кеша

Вам не нужно ничего кэшировать как часть приложения, которое мы
построение в этой книге; тем не менее, я чувствую, что это ценная информация
упомянуть. Это свойство позволяет вам получить наиболее подходящее местоположение
для хранения данных кэша. В этом каталоге можно хранить данные любого типа.
Обычно вы сохраняете его, когда хотите сохранить его дольше, чем просто удерживая
это в памяти. Ваше приложение не должно полагаться на эти данные для работы.
потому что операционная система может и будет очищать это хранилище.

# Каталог данных приложения

Свойство ```AppDataDirectory``` предоставляет каталог верхнего уровня приложения.
для хранения любых файлов. Эти файлы резервируются вместе с операционной системой.
синхронизирующая структура.
Это свойство как раз то, что вам нужно будет использовать, когда
создание и открытие файлов базы данных в следующем разделе. Итак, настроим
биты, которые вам понадобятся.
Вспомогательный класс ```FileSystem``` предоставляет набор статических свойств,
значит можно просто написать

```var appDataDirectory = FileSystem.AppDataDirectory;```

Однако, как вы уже обнаружили в этой книге, это не
хорошо поддаются модульному тестированию. Вместо этого вы можете положиться на ```IFileSystem```
интерфейс и зарегистрируйте реализацию .NET MAUI в своем приложении.
строитель. Давайте откроем ваш файл ```MauiProgram.cs``` и добавим следующую строку
в метод ```CreateMauiApp```:

```builder.Services.AddSingleton(FileSystem.Current);```

Это зарегистрирует свойство ```FileSystem.Current``` как ```IFileSystem```.
интерфейс, поэтому всякий раз, когда вы заявляете, что ваши классы зависят от ```IFileSystem```,
они будут предоставлены с экземпляром ```FileSystem.Current```.
Теперь, когда вы рассмотрели файловую систему и готовы создать свою
файлы базы данных, вы можете узнать о доступе к базе данных в .NET MAUI.

# База данных

База данных представляет собой набор данных, которые организованы. В базе данных данные
организована или структурирована в виде таблиц, состоящих из строк и столбцов.
Базы данных — гораздо лучший подход, чем хранение данных в файлах. 
возможность индексировать данные упрощает запросы и манипулирование ими. Там
различные типы баз данных, от реляционных до
распределенные базы данных, облачные базы данных и базы данных NoSQL. В этом
В главе вы сосредоточитесь на реляционных базах данных и базах данных NoSQL.
Каждое приложение, которое я когда-либо создавал, требовало той или иной формы базы данных.
и я подозреваю, что большинство приложений, которые вы создадите, также будут
требуют один. База данных действительно полезна, когда вам нужно связать данные
вместе или эффективно фильтровать и сортировать данные.
В своем приложении вы собираетесь предоставить возможность сохранять
board и вернуть список досок, созданных пользователем. Чтобы абстрагироваться от этого
немного, вы будете использовать шаблон репозитория. Вы также предоставите
возможность хранить, где были размещены виджеты, чтобы они были
запоминается, когда пользователь снова загружает доску. Рисунок 9-1 показывает
диаграмма отношений сущностей для базы данных, которую вы будете создавать.

![изображение](https://user-images.githubusercontent.com/26972859/231455605-31c043ce-716f-4b2f-b172-d0a7ee33a5d5.png)

Рисунок 9-1. Диаграмма отношений сущностей ваших моделей баз данных

# Шаблон репозитория

Шаблон репозитория позволяет скрыть всю логику, связанную с
создание, чтение, обновление и удаление (также называемых CRUD) сущностей
внутри вашего приложения. Использование этого шаблона позволяет сохранить все
знания о том, как объекты загружаются, сохраняются и многое другое в
единственное место. Это имеет дополнительное преимущество: если вы хотите полностью
изменить, откуда загружаются ваши данные, вам нужно только изменить
реализация внутри репозитория. Это также позволяет вам предоставлять макет
реализации, когда вы хотите выполнять такие вещи, как модульное тестирование, и вы
не хотите полагаться на существующую базу данных.

Давайте добавим новую папку с именем ```Data```, а затем добавим интерфейс для вашего репозиторий в эту папку с именем ```IBoardRepository```. Измените код, чтобы посмотреть следующее:

```Csharp
using WidgetBoard.Models;
namespace WidgetBoard.Data;
public interface IBoardRepository
{
 void CreateBoard(Board board);
 void CreateBoardWidget(BoardWidget boardWidget);
 void DeleteBoard(Board board);
 IReadOnlyList<Board> ListBoards();
 Board LoadBoard(int boardId);
 void UpdateBoard(Board board);
}
```
Теперь, когда вы определили свой интерфейс, вы можете обновить свой
кодовая база приложения для использования этого интерфейса при загрузке и сохранении
ваши доски.

# Создание доски

В первую очередь нужно обновить класс ```BoardDetailsPageViewModel```, который обеспечивает поддержку для создания новой доски. Откройте класс и сделайте следующие модификации. Добавьте новое поле ```IBoardRepository```.

```private readonly IBoardRepository boardRepository```

Назначьте допустимый экземпляр в поле ```boardRepository```; модификации
выделены жирным шрифтом.

```Csharp
public BoardDetailsPageViewModel(
  ISemanticScreenReader semanticScreenReader,
  IBoardRepository boardRepository)
{
 this.semanticScreenReader = semanticScreenReader;
 this.boardRepository = boardRepository;
 SaveCommand = new Command(
 () => Save(),
 () => !string.IsNullOrWhiteSpace(BoardName));
}
```
Используйте поле ```boardRepository``` при сохранении; модификации
жирным шрифтом.

```Csharp
private async void Save()
{
 var board = new Board
 {
 Name = BoardName,
 NumberOfColumns = NumberOfColumns,
 NumberOfRows = NumberOfRows
 };
 this.boardRepository.CreateBoard(board);
 semanticScreenReader.Announce($"A new board with the name
{BoardName} was created successfully.");
 await Shell.Current.GoToAsync(
 "fixedboard",
 new Dictionary<string, object>
 {
 { "Board", board}
 });
}
```
# Список ваших досок

В предыдущих главах вы просто добавили фиксированную плату и добавили ее в
Коллекция Boards в вашем классе ```AppShellViewModel```. Теперь вы собираетесь измените его так, чтобы он мог быть заполнен досками, которые создает пользователь, и вы хранить в базе данных. Откройте файл ```AppShellViewModel.cs``` и сделайте следующие изменения. Добавьте поле для вашего ```IBoardRepository```.

```private readonly IBoardRepository boardRepository```

Измените свой конструктор, чтобы использовать ```IBoardRepository``` в качестве зависимость.

```Csharp
public AppShellViewModel(
 IBoardRepository boardRepository)
{
 this.boardRepository = boardRepository;
}
```
Загрузите список досок и заполните свою коллекцию.

```Csharp
public void LoadBoards()
{
 var boards = this.boardRepository.ListBoards();
 foreach (var board in boards)
 {
  Boards.Add(board);
 }
}
```
Есть еще одно изменение, которое вам нужно сделать, чтобы разрешить
```AppShellViewModel``` для фактической загрузки платы. Вам нужно подключиться к некоторые события жизненного цикла, применимые к страницам в 
.NET MAUI. ```AppShell``` наследуется от ```Page```, что означает, что вы получаете полный доступ к этим жизненным циклам события. Конкретное событие, о котором вы сейчас заботитесь, — это событие ```OnAppearing```. Это вызывается, когда ваша страница отображается на экране.

**Замечание:**
Метод ```OnAppearing``` может вызываться несколько раз в течение
время жизни страницы, поэтому рекомендуется сделать свой метод
идемпотент или проверьте, вызывался ли он раньше, чтобы
предотвратить странное поведение при вызове во второй раз.

```OnAppearing``` — отличный выбор для вашего сценария, потому что в результате в вашем коде, выполняемом каждый раз, когда появляется представление; это может быть каждый раз, когда открывается всплывающее меню. Это дает вам возможность чтобы обновлять список досок каждый раз, когда пользователь открывает всплывающее меню. Основная причина, по которой это подходит для вашего сценария, заключается в том, что вы будете загружать
данные из локальной базы данных с ограниченным количеством досок для загрузки, поэтому будет довольно быстро. В сценариях, когда вы загружаете с внешнего веб-сервиса, его выполнение может занять гораздо больше времени и, следовательно, вы можете захотеть поддерживать некоторый уровень кэширования и предотвратить вызов веб-сервис каждый раз, когда появляется представление. Лучший вариант под это сценарий и, вероятно, наиболее типичные сценарии в приложениях .NET MAUI: использовать метод ```OnNavigatedTo```. Давайте откроем ваш файл ```AppShell.xaml.cs``` и воспользуемся этим
метод жизненного цикла.

```Csharp
protected override void OnAppearing()
{
 base.OnAppearing();
 ((AppShellViewModel)BindingContext).LoadBoards();
}
```
Когда метод вызывается, вы используете недавно добавленные ```LoadBoards```
метод на вашей модели представления. Основная причина, по которой вы подключаетесь к этому жизненному циклу событие, когда вы в конце концов пытаетесь перейти к последней использовавшейся доске в метод ```LoadBoards```, нужно убедиться, что приложение запустилось рендеринг; в противном случае навигация не удастся.

# Загрузка доски

До этого момента вы полагались на передачу Правления в
```FixedBoardPageViewModel``` и отображение деталей этого. Загрузка
процесс стал бы довольно неэффективным, если бы вы загружали все доски и
связанные ```BoardWidgets``` при перечислении всех досок в системе, так что вы нужно сделать это в два этапа: сначала перечислите доски, как вы это делали в
предыдущий раздел и, во-вторых, загрузите плату в модель представления. Это будет
быть немного сложным процессом, поэтому давайте пройдемся по нему шаг за шагом. Открыть
файл ```FixedBoardPageViewModel.cs``` и внесите следующие изменения
Добавьте следующие поля для хранения загруженной платы и
репозиторий для выполнения загрузки:

```Csharp
private Board board;
private readonly IBoardRepository boardRepository;
```

В конструкторе добавьте зависимость репозитория платы и назначьте
во вновь созданное поле. Изменения выделены жирным шрифтом.

```Csharp
public FixedBoardPageViewModel(
 WidgetTemplateSelector widgetTemplateSelector,
 WidgetFactory widgetFactory,
 IBoardRepository boardRepository)
{
 WidgetTemplateSelector = widgetTemplateSelector;
 this.widgetFactory = widgetFactory;
 this.boardRepository = boardRepository;
 Widgets = new ObservableCollection<IWidgetViewModel>();
 AddWidgetCommand = new Command(OnAddWidget);
 AddNewWidgetCommand = new Command<int>(index =>
 {
 IsAddingWidget = true;
 addingPosition = index;
 });
}
```
Теперь давайте загрузим ```Board``` внутри вашего метода ```ApplyQueryAttributes```. Изменения выделены жирным шрифтом.

```Csharp
public void ApplyQueryAttributes(IDictionary<string,object> query)
{
 var boardParameter = query["Board"] as Board;
 board = boardRepository.LoadBoard(boardParameter.Id);
 BoardName = board.Name;
 NumberOfColumns = board.NumberOfColumns;
 NumberOfRows = board.NumberOfRows;
 foreach (var boardWidget in board.BoardWidgets)
 {
  var widgetViewModel = widgetFactory.CreateWidgetViewModel(boardWidget.WidgetType);
 widgetViewModel.Position = boardWidget.Position;
 Widgets.Add(widgetViewModel);
 }
}
```
Далее добавьте возможность сохранять положение виджета на доске.

```Csharp
private void SaveWidget(IWidgetViewModel widgetViewModel)
{
 var boardWidget = new BoardWidget
 {
 BoardId = board.Id,
 Position = widgetViewModel.Position,
 WidgetType = widgetViewModel.Type
 };
 boardRepository.CreateBoardWidget(boardWidget);
}
```
Приведенный выше метод создаст новый класс модели ```BoardWidget``` и сохранит его в базу данных для вас. Наконец, вам нужно вызвать метод ```SaveWidget```. С целью ваше приложение, вы собираетесь предоставить функцию автоматического сохранения, поэтому каждый когда виджет добавляется на доску, вы сразу же сохраняете его в база данных. Для этого вам просто нужно добавить жирную строку в ваш метод ```AddWidget```.

```Csharp
private void OnAddWidget()
{
 if (SelectedWidget is null)
 {
 return;
 }
 var widgetViewModel = widgetFactory.CreateWidgetViewModel(S
electedWidget);
 widgetViewModel.Position = addingPosition;
 Widgets.Add(widgetViewModel);
 SaveWidget(widgetViewModel);
 IsAddingWidget = false;
}
```

Вы еще не можете запустить свой код, потому что у вас нет реализации
вашего интерфейса ```IBoardRepository```, поэтому давайте рассмотрим две разные базы данных варианты, которые позволят вам обеспечить реализацию для вашего ```IBoardRepository```.

# SQLite

```SQLite``` — это легкая кроссплатформенная база данных, ставшая
вариант перехода для обеспечения поддержки баз данных в мобильных приложениях база данных хранится локально в одном файле в файловой системе устройства ```SQLite``` изначально поддерживается Android и iOS; однако они требуют доступ через С++. Существует несколько оболочек C# вокруг нативного SQLite движок, который могут использовать разработчики .NET. Самый популярный выбор — C# оболочка под названием ```SQLite-net```.

# Установка SQLite-net

Чтобы установить и использовать ```Sqlite-net```, вам необходимо установить пакет NuGet. называется ```Sqlite-net-pcl```. Вы можете заметить дополнительный суффикс -pcl в NuGet.
имя пакета и найти это запутанным. Это артефакт старой части
технологий, используемых в приложениях ```Xamarin.Forms```. Имя было
сохраняется, но не волнуйтесь; это правильный пакет для добавления в .NET
проект МАУИ.
Вы можете сделать это, выполнив следующие действия.
1. Щелкните правой кнопкой мыши проект ```WidgetBoard```.
2. Щелкните Управление пакетами NuGet.
3. В поле поиска введите ```Sqlite-net-pcl```.
4. Выберите пакет ```Sqlite-net-pcl``` и нажмите кнопку Добавить.
Упаковка.
5. Появится диалоговое окно подтверждения. Просмотрите и примите
детали лицензии, если вы счастливы.
6. Повторите вышеуказанные шаги для следующих пакетов:
а. ```SQLitePCLRaw.bundle_green```
б. ```SQLitePCLRaw.provider.dynamic_cdecl```
в. ```SQLitePCLRaw.provider.sqlite3```

# Использование Sqlite-сети

Первым шагом является создание реализации ```IBoardRepository```. Добавить
новый файл класса с именем ```SqliteBoardRepository``` в вашей папке данных и сделайте он реализует ваш интерфейс ```IBoardRepository```.

```Csharp
using SQLite;
using WidgetBoard.Models;
namespace WidgetBoard.Data;
public class SqliteBoardRepository : IBoardRepository
{
 public void CreateBoard(Board board)
 {
 throw new NotImplementedException();
 }
 public void CreateBoardWidget(BoardWidget boardWidget)
 {
 throw new NotImplementedException();
 }
 public void DeleteBoard(Board board)
 {
 throw new NotImplementedException();
 }
 public IReadOnlyList<Board> ListBoards()
 {
 throw new NotImplementedException();
 }
 public Board LoadBoard(int boardId)
 {
 throw new NotImplementedException();
 }
 public void UpdateBoard(Board board)
 {
 throw new NotImplementedException();
 }
}
```
Вам также необходимо зарегистрировать свою реализацию в конструкторе приложений в ```MauiProgram.cs```. Вы можете добавить следующую строку

```Csharp
builder.Services.AddTransient<IBoardRepository,
SqliteBoardRepository>();
```
# Подключение к базе данных SQLite

Как уже упоминалось, база данных ```SQLite``` содержится в одном файле, поэтому при подключении к базе данных необходимо указать путь к этому файлу.
Вы можете сделать это через класс ```SqliteConnection```. Обратите внимание, что если вы хотите чтобы использовать ```async/await```, вы можете использовать класс ```SqliteAsyncConnection```.
Давайте отредактируем ваш класс репозитория, чтобы поддерживать открытие соединения с вашим база данных. Добавьте поле для подключения к базе данных.

```private readonly SQLiteConnection database;```

Добавьте конструктор, чтобы открыть соединение.

```Csharp
public SqliteBoardRepository(IFileSystem fileSystem)
{
 var dbPath = Path.Combine(fileSystem.AppDataDirectory,"widgetboard_sqlite.db");
 database = new SQLiteConnection(dbPath);
}
```
Здесь вы используете зарегистрированную вами реализацию ```IFileSystem```.
в предыдущем разделе. Затем вы используете его, чтобы определить, где
сохранить файл базы данных. Наконец, вы открываете соединение, используя путь к ваш файл базы данных. Обратите внимание, что если файл не существует, он будет создан для тебя.

# Сопоставление ваших моделей

```Sqlite-net``` предоставляет возможность определять информацию о сопоставлении в вашем классы модели, которые в конечном итоге будут использоваться для создания определения вашей таблицы автоматически для вас. Существует богатый набор опций, начиная от настройки ```PrimaryKey``` до определения, имеет ли столбец ```MaxLength``` или даже если
он должен быть уникальным. Откройте файл ```Board.cs``` и сделайте следующее:
модификации выделены жирным шрифтом:

```Csharp
using SQLite;
namespace WidgetBoard.Models;
public class Board
{
 [PrimaryKey, AutoIncrement]
 public int Id { get; set; }
 public string Name { get; init; }
 public int NumberOfColumns { get; init; }
 public int NumberOfRows { get; init; }
}
```
Вы добавляете новый столбец ```Id```, помечая его как ```PrimaryKey```, и указываете, что
это будет автоинкремент, что означает, что ```Sqlite``` будет управлять генерацией идентификатора
для тебя.
Ваш второй класс модели находится в файле ```BoardWidget.cs```. Это представляет каждый виджет, который размещен на доске и где он расположен.

```Csharp
using SQLite;
namespace WidgetBoard.Models;
public class BoardWidget
{
 [PrimaryKey, AutoIncrement]
 public int Id { get; set; }
 public int BoardId { get; set; }
 public int Position { get; set; }
 public string WidgetType { get; set; }
}
```

# Создание ваших таблиц

Вы можете сообщить соединению ```Sqlite-net```, чтобы оно создало для вас таблицу. Этот
можно сделать, вызвав метод ```CreateTable<T>``` и передав
соответствующий тип модели. Обратите внимание, что функция ```CreateTable``` является идемпотентной, поэтому, если
вы измените свою модель, вызов ```CreateTable``` во второй раз будет иметь
без влияния. Вы можете изменить свой ```SqliteBoardRepository```, чтобы вызвать
Метод ```CreateTable``` в его конструкторе выглядит следующим образом: изменения выделены жирным шрифтом.
  
```Csharp
public SqliteBoardRepository(IFileSystem fileSystem)
{
 var dbPath = Path.Combine(fileSystem.AppDataDirectory,
"widgetboard_sqlite.db");
 connection = new SQLiteConnection(dbPath);
 connection.CreateTable<Board>();
 connection.CreateTable<BoardWidget>();
} 
```

# Вставка в базу данных SQLite

Теперь вы можете добавить возможность вставки доски в вашу базу данных,
предоставив следующую реализацию в метод ```CreateBoard```:

```Csharp  
public void CreateBoard(Board board)
{
 connection.Insert(board);
}
```
  
# Чтение коллекции из базы данных SQLite

Вам нужно только вернуть список досок, созданных вашим пользователем в
приложение.
 
```Csharp
public IReadOnlyList<Board> ListBoards()
{
 return connection.Table<Board>().ToList();
}
```

Возможно, вам следует рассмотреть возможность сортировки этих досок по алфавиту.
```Sqlite-net``` предлагает богатый набор функций при запросе данных в
база данных. Вы можете использовать выражения на основе ```LINQ```, что дает вам
следующее (дополнение выделено жирным шрифтом):

```Csharp
public IReadOnlyList<Board> ListBoards()
{
 return connection.Table<Board>()
 .OrderBy(b => b.Name)
 .ToList();
}
```

# Чтение одного объекта из базы данных SQLite

При чтении платы из базы данных также необходимо загрузить любой
BoardWidgets, которые относятся к нему. Для этого можно написать следующее:

```Csharp
public Board LoadBoard(int boardId)
{
 var board = connection.Find<Board>(boardId);
 if (board is null)
 {
 return null;
 }
 var widgets = connection.Table<BoardWidget>().Where(w =>
w.BoardId == boardId).ToList();
 board.BoardWidgets = widgets;
 return board;
}
```
Первая строка, вызывающая ```Find```, позволяет вам найти объект с предоставленным
значение первичного ключа. Это извлекает доску. Далее необходимо получить
Коллекция ```BoardWidgets```. Выполняется очень похожим образом
для загрузки вашей коллекции досок. Наконец, вы назначаете виджеты, которые вы
загружается в доску, прежде чем вернуть ее вызывающему абоненту.
Стоит отметить, что пакет ```sqlite-net-pcl``` не предоставляет больше
сложные операции запросов, такие как соединения. Если это то, что вы
все еще требуется, можно написать SQL напрямую и выполнить против
связь. Если вы хотите присоединиться к своим столам ```Board``` и ```BoardWidget```
вместе, вы можете добиться этого следующим образом:

```Csharp
var board = connection.Query<Board>("SELECT B.* FROM Board B
JOIN BoardWidget BW ON BW.BoardId = B.BoardId WHERE B.BoardId =
?", boardId);
```
Обратите внимание, что приведенный выше запрос предназначен исключительно для демонстрации того, как работают соединения.
он не предоставляет вам ничего особенно полезного в контексте вашей
приложение.

# Удаление из базы данных SQLite

Хотя я еще не сосредоточился на предоставлении этой функциональности, это очень общий вариант использования.
  
```Csharp
public void DeleteBoard(Board board)
{
 connection.Delete(board);
}
```
# Обновление объекта в базе данных SQLite

Хотя я еще не сосредоточился на предоставлении этой функциональности, это очень общий вариант использования.
 
```Csharp
public void UpdateBoard(Board board)
{
 connection.Update(board);
}
```
# LiteDB

```LiteDB``` — это простой, быстрый и легкий встроенный документ .NET.
база данных. ```LiteDB``` был вдохновлен базой данных ```MongoDB```, и его API очень похож на официальный ```MongoDB``` .NET API.

# Установка LiteDB

Чтобы установить и использовать ```LiteDB```, вам необходимо установить пакет NuGet. называется ```LiteDB```. Не волнуйся; совершенно нормально установить как ```LiteDB```, и пакеты ```SQLite``` рядом с вашим проектом. На самом деле это именно что вы будете делать здесь.
Вы можете сделать это, выполнив следующие действия.
1. Щелкните правой кнопкой мыши проект ```WidgetBoard```.
2. Щелкните Управление пакетами ```NuGet```.
3. В поле поиска введите ```LiteDB```.
4. Выберите пакет ```LiteDB``` и выберите Добавить пакет.
5. Появится диалоговое окно подтверждения. Просмотрите и примите
детали лицензии, если вы счастливы

# Использование LiteDB

Первым шагом является создание реализации ```IBoardRepository```. Добавить
новый файл класса с именем ```LiteDBBoardRepository``` в вашей папке данных и сделайте он реализует ваш интерфейс ```IBoardRepository```.

```Csharp
using LiteDB;
using WidgetBoard.Models;
namespace WidgetBoard.Data;
public class LiteDBBoardRepository : IBoardRepository
{
 public void CreateBoard(Board board)
 {
 throw new NotImplementedException();
 }
 public void CreateBoardWidget(BoardWidget boardWidget)
 {
 throw new NotImplementedException();
 }
 public void DeleteBoard(Board board)
 {
 throw new NotImplementedException();
 }
 public IReadOnlyList<Board> ListBoards()
 {
 throw new NotImplementedException();
 }
 public Board LoadBoard(int boardId)
 {
 throw new NotImplementedException();
 }
 public void UpdateBoard(Board board)
 {
 throw new NotImplementedException();
 }
}
```
Вам также необходимо зарегистрировать свою реализацию в приложении.
построитель в ```MauiProgram.cs```. Вы можете добавить следующую строку. Просто сделай убедитесь, что вы удалили или закомментировали строку для регистрации
Реализация ```SqliteBoardRepository```.

```Csharp
builder.Services.AddTransient<IBoardRepository,LiteDBBoardRepository>();  
```
# Подключение к базе данных LiteDB

```LiteDB``` хранит все свои данные в одном файле на диске, поэтому ваша первая задача — укажите, где находится этот файл, чтобы вы могли создать и открыть файл для пользователей в вашем приложении. Для этой части вы позаимствуете концепцию из немного дальше в этой главе (раздел «Файловая система»). Отредактируйте свой класс репозитория, чтобы поддерживать открытие соединения с вашим база данных. Добавьте поле для хранения сведений о доступе к базе данных.

```Csharp
private readonly LiteDatabase database;
```
Добавьте конструктор, чтобы открыть соединение.

```Csharp
public LiteDBBoardRepository(IFileSystem fileSystem)
{
 var dbPath = Path.Combine(fileSystem.AppDataDirectory,
"widgetboard_litedb.db");
 database = new LiteDatabase(dbPath);
}  
```

Вышеприведенное должно выглядеть очень похоже на способ ```Sqlite``` для доступа к база данных. Здесь вы используете реализацию ```IFileSystem```, которую вы зарегистрирован в предыдущем разделе. Затем вы используете это, чтобы определить где хранить файл базы данных. Наконец, вы открываете соединение, используя путь к файлу вашей базы данных. Обратите внимание, что если файл не существует, он будет создан для вас.

# Сопоставление ваших моделей

Во-первых, вам нужно добавить поле для хранения коллекции досок и одно для
коллекция виджетов для досок

```Csharp
private readonly ILiteCollection<Board> boardCollection;
private readonly ILiteCollection<BoardWidget>
boardWidgetCollection;
```
Затем вам нужно получить доступ к этой коллекции, чтобы позволить вам
выполнять свои операции против него.

```Csharp
boardCollection = database.GetCollection<Board>("Boards");
boardCollection = database.GetCollection<BoardWidget>("Board
Widgets");
```
Заключительная часть настройки сопоставления — определение информации об индексации о вашей модели. Для этого вы используете метод ```SureIndex```.

```Csharp
boardCollection.EnsureIndex(b => b.Id, true);
```
В ```LiteDB``` любое свойство, которое вы хотите сделать уникальным или
для запроса необходимо иметь определение, предоставленное через
метод ```SureIndex```.

# Создание ваших таблиц
  
На самом деле вам не нужно ничего делать, чтобы создать свои таблицы здесь. Ключ
Разница между ```LiteDB``` и другими базами данных, которые вы можете использовать, заключается в том, что
схема данных хранится вместе с данными.

# Вставка в базу данных LiteDB

Теперь вы можете добавить возможность вставки доски в вашу базу данных,
предоставив следующую реализацию в метод ```CreateBoard```:

```Csharp
public void CreateBoard(Board board)
{
 boardCollection.Insert(board);
}
```

# Чтение коллекции из базы данных LiteDB
  
 Вам нужно только вернуть список досок, созданных вашим пользователем в
приложение.
  
```Csharp
public IReadOnlyList<Board> ListBoards()
{
 return boardCollection.Query()
 .ToList();
}  
```
  
Возможно, вам следует рассмотреть возможность сортировки этих досок по алфавиту.
```LiteDB``` предлагает тот же набор функций, что и ```Sqlitenet```. Выражения на основе ```LINQ``` можно использовать для заказа ваших досок, которые
дает вам следующее (добавление выделено жирным шрифтом):  
  
```Csharp
public IReadOnlyList<Board> ListBoards()
{
 return connection.Table<Board>()
 .OrderBy(b => b.Name)
 .ToList();
}
```
Вам также нужно добавить следующую строку в свой конструктор, чтобы сделать
возможен уверенный запрос:  
  
```Csharp
boardCollection.EnsureIndex(b => b.Name, false);
```
  
# Чтение одного объекта из базы данных LiteDB  
  
При чтении платы из базы данных также необходимо загрузить любой
BoardWidgets, которые относятся к нему. Для этого можно написать следующее:

```Csharp
public Board LoadBoard(int boardId)
{
  var board = boardCollection.FindById(boardId);
  var boardWidgets = boardWidgetCollection.Find(w =>w.BoardId == boardId).ToList();
  board.BoardWidgets = boardWidgets;
  return board;
}
```
Первая строка вызывает ```FindById```, что позволяет найти объект с
предоставленное значение первичного ключа. Это извлекает доску. Далее вам нужно для получения коллекции ```BoardWidgets```. Это выполняется в очень
аналогично загрузке вашей коллекции досок. Наконец, вы назначаете
виджеты, которые вы загрузили на доску, прежде чем вернуть ее вызывающему абоненту.
  
# Удаление из базы данных LiteDB

Хотя я не сосредоточился на предоставлении этой функции, она очень распространена случай использования.

```Csharp
public void DeleteBoard(Board board)
{
 boardCollection.Delete(board.Id);
}
```

# Обновление объекта в базе данных LiteDB

Хотя я не сосредоточился на предоставлении этой функции, она очень распространена. Cлучай использования.  
  
```Csharp
public void UpdateBoard(Board board)
{
 boardCollection.Update(board);
}
```

# Сводка базы данных
  
Существует множество вариантов, когда дело доходит до выбора не только
какая база данных, но и слой ORM поверх нее. Цель этого
раздел предназначен для того, чтобы дать представление о том, что предлагают некоторые варианты, и побудить вас
чтобы решить, что принесет наибольшую пользу вашему приложению и команде.
Оба варианта, которые я рассмотрел, обеспечивают поддержку шифрования.  
  
**Замечание:**
Я настоятельно рекомендую вам оценить, какая база данных предоставит
вы с лучшим опытом разработки и пользователи вашего
приложение с лучшим пользовательским интерфейсом. Некоторые базы данных выполняют лучше в разных сценариях.
  
В дальнейшем с этим приложением вы продолжите использовать ```LiteDB```.  
  
# Настройки приложения (Настройки)

Довольно часто вы захотите сохранить данные о вашем приложении, которые вы
действительно не нужна база данных для. Мне нравится называть эти биты данных как настройки приложения. Если у вас есть опыт создания .NET
приложений, это будет похоже на ```app.config``` или ```appsettings.json```.
файл. Однако термин .NET MAUI — Preferences, и это API, который
вы посмотрите на доступ.
Элемент в настройках хранится в виде пары ключ-значение. Ключ представляет собой строку
и рекомендуется, чтобы имя было коротким.
Как и в случае со всеми другими API, предоставляемыми .NET MAUI, вы регистрируете
Реализация настроек с помощью конструктора приложений в ```MauiProgram.cs```
файл. Вы можете добавить следующую строку в метод ```CreateMauiApp```:  
  
```Csharp
builder.Services.AddSingleton(Preferences.Default);
```

# Что можно хранить в настройках?
  
Существует ограничение на тип данных, которые могут храниться в настройках.
API предоставляет возможность хранить следующие типы .NET:  
  
  • Boolean
  • Double
  • Int32
  • Single
  • Int64
  • String
  • DateTime

Возможность указать строковое значение, безусловно, означает, что вы можете
теоретически хранить там что угодно, верно? Хотя это технически возможно
настоятельно рекомендуется хранить только небольшие объемы текста.
В противном случае производительность хранения и поиска может быть снижена.
ваши приложения.  
  
 # Установка значения в настройках
  
Вы можете сохранить значение в настройках с помощью метода Set.
Вы можете указать ключ, значение, а также необязательное общее имя. 
настройки, хранящиеся в вашем приложении, видны только этому приложению.
Вы также можете создать общую настройку, которую могут использовать другие
расширения или приложение для часов.
Идеальным вариантом использования вашего приложения является хранение идентификатора последнего
доступ к доске и открыть ее при следующей загрузке приложения. Давайте хранить
идентификатор изначально. Внутри вашего класса ```FixedBoardPageViewModel``` вы можете сделать следующие изменения. Добавьте поле настроек.
  
```Csharp
private readonly IPreferences preferences;
Update the constructor to set the preferences field; changes in bold.
public FixedBoardPageViewModel(
 WidgetTemplateSelector widgetTemplateSelector,
 IPreferences preferences)
{
 WidgetTemplateSelector = widgetTemplateSelector;
 this.preferences = preferences;
 Widgets = new ObservableCollection<IWidgetViewModel>();
}
```
Наконец, запишите идентификатор платы, которая была предоставлена, когда
переход на страницу. Вы можете сделать это, добавив жирную строку в свой
Метод ```ApplyQueryAttributes```:
  
```Csharp
public void ApplyQueryAttributes(IDictionary<string,
object> query)
{
 var board = query["Board"] as Board;
 preferences.Set("LastUsedBoardId", board.Id);
 BoardName = board.Name;
 NumberOfColumns = board.NumberOfColumns;
 NumberOfRows = board.NumberOfRows;
}
```

Это означает, что каждый раз, когда пользователь открывает доску для ее просмотра, идентификатор будет
запомнить в настройках. Когда приложение снова открывается в
в будущем он будет использовать этот идентификатор для открытия последней просмотренной доски.  
  
Возможный альтернативный способ достижения этого типа функциональности мог бы
поддерживать последний открытый столбец в базе данных и всегда находить
последний из этого набора.  
  
# Получение значения в настройках
  
Вы можете получить значение из ```Preferences``` с помощью метода ```Get```. Ты необходимо предоставить ключ, идентифицирующий настройку, и значение по умолчанию, которое должно быть
возвращается, если ключ не существует. При желании вы можете указать ```sharedName```,
очень похоже на метод ```Set```, описанный в предыдущем разделе.
Вы уже написали код для хранения ```LastUsedBoardId``` в
Настройки, поэтому давайте прочитаем их при загрузке ваших досок для отображения.
Откройте файл ```AppShellViewModel.cs``` и внесите следующие изменения.
Добавьте поле настроек.  
  
```Csharp
private readonly IPreferences preferences;
```
Задайте поле настроек в конструкторе; изменения выделены жирным шрифтом.  
  
```Csharp
public AppShellViewModel(
 IBoardRepository boardRepository,
 IPreferences preferences)
{
 this.boardRepository = boardRepository;
 this.preferences = preferences;
}
```
Обновите метод ```LoadBoards```, чтобы он поддерживал переход к последнему использовавшемуся
доска; изменения выделены жирным шрифтом.  
  
```Csharp
public void LoadBoards()
{
 var boards = this.boardRepository.ListBoards();
 var lastUsedBoardId = preferences.
Get("LastUsedBoardId", -1);
 Board lastUsedBoard = null;
 foreach (var board in boards)
 {
 Boards.Add(board);
 if (lastUsedBoardId == board.Id)
 {
 lastUsedBoard = board;
 }
 }
 if (lastUsedBoard is not null)
 {
 Dispatcher.GetForCurrentThread().Dispatch(() =>
 {
 BoardSelected(lastUsedBoard);
 });
 }
}
```
Здесь есть несколько новых концепций, поэтому давайте разберем их на
понятные куски.
Использование метода ```preferences.Get```, о котором вы узнали ранее
написание приведенного выше кода. Вы указываете имя ключа и значение по умолчанию для быть возвращено, если ключ не существует. Вы используете -1 по умолчанию, потому что это
недействительный идентификатор для ключа базы данных.
Последней новой концепцией является использование Dispatcher. Это позволяет вам
запустить отложенное действие и убедиться, что оно отправлено в пользовательский интерфейс
нить. Ваш метод будет вызываться в потоке пользовательского интерфейса, но вы хотите, чтобы
Логика OnAppearing для завершения, прежде чем вы попытаетесь перейти куда-либо,  
вызывая ```Dispatcher.GetForCurrentThread().Dispatch```, который вы ставите в очередь
up действие, которое будет выполняться после того, как поток пользовательского интерфейса перестанет быть занят. .СЕТЬ
MAUI выполняет большую часть диспетчеризации для вас, когда вы запускаете обновления.
в привязках, но бывают случаи, когда вам нужно убедиться, что вы
обновление вещей в потоке пользовательского интерфейса.
Если вы запустите свой код сейчас, вы сможете создать новую доску и просмотреть ее один раз.
сохранен. Если вы затем закроете и снова откроете приложение, вы увидите, что
созданная вами доска теперь отображается для вас. Предоставление опыта, как
это может иметь большое значение для приятного пользовательского опыта (UX), поскольку они
вернуться туда, где они были раньше.  
  
# Проверка наличия ключа в настройках
  
Могут быть случаи, когда вы не можете предоставить подходящее значение по умолчанию.
значение методу Get, чтобы узнать, было ли значение
установить, например, с помощью логического значения. false является допустимым значением, поэтому
значение по умолчанию не сможет отличить, было ли оно установлено как ложное
или значение по умолчанию false. В этом случае вы можете использовать
Метод СодержитКей. Поэтому вместо того, чтобы писать
  
```Csharp
var lastUsedBoardId = preferences.Get("LastUsedBoardId", -1);
you could have first checked whether the key existed, like
if (preferences.ContainsKey("LastUsedBoardId"))
{
 // Perform your logic
}
```

# Удаление предпочтения

Могут быть случаи, когда вам нужно удалить опцию из
Настройки сохраняют или даже удаляют все параметры. Если вы хотите удалить свой
Предпочтение LastUsedBoardId, вы можете написать
  
```Csharp
Preferences.Remove("LastUsedBoardId");
```
  
Если вы хотите удалить все параметры, вы можете написать  

```Csharp
Preferences.Clear();
```
# Безопасное хранилище  
  
При создании приложения довольно часто будет случай, когда
вам нужно хранить токен API или какую-либо форму данных, которые необходимо хранить
надежно. .NET MAUI предоставляет другой API, который гарантирует, что значения
которые вы предоставляете, надежно хранятся в безопасном хранилище каждой из платформ
места.
Как всегда с новым API, предоставляемым .NET MAUI, вы должны зарегистрировать его.
с помощью ```MauiAppBuilder``` в файле ```MauiProgram.cs```, так что давайте откроем этот
файл и добавьте следующую строку в метод ```CreateMauiApp```:  
  
```Csharp
builder.Services.AddSingleton(SecureStorage.Default);
```
Это позволит вам объявить зависимость от ```ISecureStorage``` в
ваши конструкторы классов и предусмотрели их для вас.  
  
# Безопасное хранение значения  
  
В настоящее время вам пока не нужно записывать безопасное значение. Это будет
следовать в следующей главе, но дать краткое объяснение этого типа
локальные данные, вы можете взглянуть на пример.  
Чтобы сохранить значение в безопасном хранилище с помощью ключа apiToken и значения
из 1234567890 можно написать следующее:  
  
```Csharp
await SecureStorage.Default.SetAsync("apiToken", "1234567890");
```
# Чтение безопасного значения
  
Также можно безопасно получить значение, которое вы сохранили, используя
```GetAsync``` и передача ключа. Стоит отметить, что если ключ
не существует, метод вернет null.
Чтобы получить значение в безопасном хранилище с помощью ключа apiToken, вы можете
напишите следующее:  
  
```Csharp
string apiToken = await SecureStorage.Default.
GetAsync("apiToken");
if (apiToken is not null)
{
}
```

# Удаление безопасного значения  
  
Как и в случае с настройками, вы можете удалять и удалять все безопасные значения.
Чтобы удалить конкретное значение, удалите ключ:
  
```Csharp
bool Success = SecureStorage.Default.Remove("apiToken");  
```  
Чтобы удалить все значения, используйте метод RemoveAll:  
  
```Csharp
SecureStorage.Default.RemoveAll();
```

# Особенности платформы  
  
Как уже упоминалось, API-интерфейс ```SecureStorage``` использует каждый из API-интерфейсов конкретной платформы для обработки фактического хранения данных, которые вы передаете.
отметив, что реализации для каждой отдельной платформы различны
и могут меняться в операционных системах, но SecureStorage будет использовать
что бы ни было в операционной системе и поэтому всегда будет самым
безопасный вариант. В этом разделе объясняется, как.  
  
# Андроид  
  
Данные, которые вы передаете, зашифрованы с помощью ```Android```
Класс ```EncryptedSharedPreferences``` из библиотеки ```Android Security```,
который автоматически шифрует ключи и значения, используя двойную схему
подход:
1. Ключи детерминистически зашифрованы, так что ключ
могут быть зашифрованы и правильно просмотрены.
2. Значения недетерминировано зашифрованы с использованием
АЭС-256 ГКМ.
Библиотека ```Android Security``` предоставляет реализацию
рекомендации по безопасности, связанные с чтением и записью данных в состоянии покоя, а также
создание и проверка ключей.
Поскольку Google представила Android 6.0 (уровень API 23), операционная
система предлагает возможность резервного копирования данных пользователя. Это включает в себя
Preferences, а также ```SecureStorage```, который предлагает .NET MAUI. Это
вполне возможно, и на самом деле я рекомендую вам отключить эту резервную копию
функциональность при использовании ```SecureStorage```.
Чтобы отключить функцию автоматического резервного копирования, необходимо установить
```android:allowBackup``` в false в файле ```AndroidManifest.xml``` под
Папка Платформы/Андроид. Результирующее изменение должно выглядеть как-то
как следующее  
  
```xml
<manifest ... >
 ...
 <application android:allowBackup="false" ... >
 ...
 </application>
</manifest>
```

# iOS и macOS

Данные, передаваемые в ```SecureStorage``` на iOS и macOS, шифруются с помощью
API связки ключей. Цитируя Apple,
Связка ключей — лучшее место для хранения небольших секретов, таких как пароли и криптографические ключи. Вы пользуетесь функциями
API службы связки ключей для добавления, извлечения, удаления или изменения
элементы брелка.
Для дальнейшего чтения обратитесь к документации Apple по адресу https://
developer.apple.com/documentation/security/certificate_key_and_
trust_services/keys/storing_keys_in_the_keychain.
  
**Замечание:**
В некоторых случаях данные связки ключей синхронизируются с iCloud, а
удаление приложения может не удалить безопасные значения из
пользовательские устройства. Я определенно наблюдал это в некоторых приложениях, которые я
построили, поэтому лучше спланировать эту возможность.
---
  
# Windows  
  
```SecureStorage``` в Windows использует класс ```DataProtectionProvider``` для безопасно шифровать значения. Реализация .NET MAUI позволяет
данные, которые необходимо защитить от локального пользователя или учетной записи компьютера.

Для дальнейшего чтения обратитесь к документации Microsoft по адресу
  
  https://docs.microsoft.com/uwp/api/windows.security.cryptography.dataprotection.dataprotectionprovider?view=winrt-22621
  
# Просмотр результата
  
Теперь при запуске вашего приложения вы увидите, что не только последний
доска, которую вы создаете, загружается обратно, но она также показывает виджеты, которые вы
добавлено ранее. На рис. 9-2 показан пример результатов.
  
![изображение](https://user-images.githubusercontent.com/26972859/231465061-eb1feeb6-21be-4190-bd77-7f49ff7fa6c1.png)

Рисунок 9-2. Приложение загружается обратно и показывает ранее
добавлены виджеты
  
# Краткое содержание
  
В этой главе вы

   • Узнали о различных типах локальных данных.

   • Обнаружил, что предлагает .NET MAUI с точки зрения локального файла.
места хранения и когда использовать каждое из них

   • Получил понимание технологий баз данных и
применил два разных варианта

   • Изменено ваше приложение для сохранения и загрузки досок
ваши пользователи создают

   • Получили представление о вариантах хранения
небольшие биты данных или предпочтения

   • Добавлена возможность записи последней открытой доски

   • Получили представление о вариантах хранения
небольшие биты данных надежно или ```SecureStorage```

   В следующей главе вы будете

   • Узнайте об удаленных данных.

   • Узнайте, как вы можете взаимодействовать с ним.

   • Расскажите об общих соображениях.

   • Посмотрите конкретный пример с ```Open Weather API```.

   • Создайте собственную реализацию для использования ```Open Weather API```.

   • Объясните, как использовать возвращенные данные.

   • Обсудите сценарии, в которых что-то может пойти не так.

   • Обеспечить реализации для обработки этих сценариев.

   • Посмотрите, как можно упростить реализацию с помощью ```Refit```.

   • Добавьте в свой виджет погоды.
  
# Исходный код

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introducing-MAUI/tree/
main/ch09.
  
# Дополнительное задание

Вы предоставили пользователям возможность добавлять виджеты на свои доски.
и автоматически сохраняйте их, чтобы при следующей загрузке доски она была
запомнился им. Я хотел бы посмотреть, можете ли вы добавить возможность
удалить виджеты с доски и базы данных.
  
  
  
  
  
  
  
  
  
  

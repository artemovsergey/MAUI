# ГЛАВА 10

# Удаленные данные

В этой главе вы будете изучать тему удаленных данных, изучая
что это такое, виды, как с ним взаимодействовать и что учитывать
при этом. Затем вы будете основываться на этом обучении, создавая новую
widget: виджет погоды для отображения текущей погоды. Это будет
можно сделать, взаимодействуя непосредственно с Open Weather API. Ты получишь
знакомство с обработкой HTTP-запросов и ответов с помощью API, как
для обработки ответа в формате JSON и различных уровней
гибкость при сопоставлении с данными JSON. Вы закончите, упростив
реализация с фантастическим пакетом NuGet, который генерирует исходный код
код для вас, просто из интерфейса, который вы определяете для представления сети
услуга.

# Что такое удаленные данные?

Удаленные данные — это любые данные, полученные извне устройства, на котором вы
приложение запущено. Это может варьироваться от запроса веб-API для
для получения данных, используя поставщика облачных баз данных, изображения, размещенные
онлайн, потоковое видео или аудио данные и многое другое.
Подавляющее большинство приложений будет взаимодействовать с той или иной формой
удаленная конечная точка для извлечения данных. В этом постоянно меняющемся мире
данных, это становится неотъемлемой частью практически любого приложения.

# Что следует учитывать при обработке удаленных данных

При взаимодействии с
удаленные данные. Вы будете явно обращаться к ним, когда будете создавать новый
виджет, но я хочу обратить ваше внимание на них, прежде чем вы начнете.

# Время загрузки

Один из худших опытов для пользователя — нажать на кнопку или открыть новый
страница/приложение и просто увидите, как приложение блокируется во время загрузки данных.
Пользователь будет думать, что приложение зависло и на самом деле платформы
как Android и Windows, скорее всего, укажет, что приложение
разбился / заблокировался, если загрузка занимает слишком много времени. К счастью, .NET предлагает вам
ключевые слова async и await. Они не являются необходимыми, но они действительно делают
ваша жизнь проще. На эту тему может быть целая глава или даже книга;
тем не менее, мой хороший друг Брэндон Минник уже осветил многое из этого.
в своем репозитории AsyncAwaitBestPractices на GitHub. Если вы не проверили
это раньше, я настоятельно рекомендую вам сделать это, если вы хотите копнуть глубже;
https://github.com/brminnick/AsyncAwaitBestPractices.
Обычный вариант использования — показать пользователю, что приложение занято.
загрузка. Это может быть с помощью простого ActivityIndicator, который загружает
Спиннер/значок загрузки для конкретной платформы, с которым пользователи должны быть знакомы, или вы
можно использовать функции анимации, которые я рассмотрел, чтобы показать что-то большее
вовлеченный. С помощью этого экрана загрузки вы затем инициируете вызов веб-службы. Если
вы получаете ответ, вы отображаете результат этого ответа в своем приложении
(например, элементы в списке покупок или, в вашем сценарии, текущая погода пользователя).

# Сбои

Во время создания недавнего приложения некоторые из наиболее ценных
тестирование, которое я провел, заключалось в том, чтобы установить приложение, а затем прокатиться по Лондону.
Под землей и посмотрите, насколько ненадежны данные мобильного телефона
связь действительно может быть.

Есть два ключевых вопроса, которые следует учитывать при работе с сетью.
проблемы с подключением:
1. Что нужно знать пользователю?
2. Как приложение должно восстанавливаться?

# Безопасность

Как разработчику приложений важно, чтобы вы поддерживали доверие
которые ваши пользователи вкладывают в вас в отношении обеспечения безопасности своих данных. С
Имея это в виду, вы всегда должны выбирать HTTPS вместо HTTP. На самом деле, большинство
платформы по умолчанию не разрешают HTTP-трафик, чтобы избежать его случайного
использовал. Есть способы отключить предотвращение HTTP-трафика; Однако я
настоятельно не советую этого делать, поэтому в этой книге я не буду описывать, как это сделать.
Я настоятельно рекомендую, чтобы при создании приложений вы учитывали
безопасность как главный приоритет. Открытый проект безопасности веб-приложений
(OWASP) — некоммерческий фонд, работающий над повышением безопасности
программного обеспечения, и оно предоставляет некоторые действительно отличные ресурсы и рекомендации
о том, что вы действительно должны учитывать при создании веб-сайтов и мобильных
Приложения. В качестве хорошей отправной точки посмотрите на их мобильное приложение.
Репозиторий руководства по тестированию безопасности на GitHub по адресу https://github.com/
OWASP/owasp-mastg/.
Довольно часто API требуют уровней аутентификации, которые усложняют
поток для извлечения данных из них. Обычно это происходит, когда ваш
приложение должно потреблять данные, специфичные для пользователя, а не только API
сам. Я не буду рассматривать этот сценарий в этой книге, но я рекомендую
почитайте об OAuth2.0 с хорошим начальным ресурсом на www.oauth.com/
oauth2-серверы/мобильные и собственные приложения/. Кроме того, специальные API
такие как GitHub API, скорее всего, предоставят хорошую документацию о том, как
использовать свой особый механизм аутентификации. Итак, имея это в виду, я
рекомендуем обратиться к документации по API, который вы хотите
интегрироваться с.

# Веб-сервисы

Веб-сервисы действуют как механизм запроса или получения данных из удаленного
сервер. Как правило, они предлагают множество преимуществ разработчикам, которые их создают.
поскольку они обеспечивают возможность зарядки в зависимости от использования, защищают
интеллектуальная собственность разработчика и другие причины.

# Открытый API погоды

Вы будете вызывать Open Weather API и, в частности, версию 2.5
API OneCall. API можно использовать бесплатно с некоторыми ограничениями использования. Ты можешь
звоните на него до 60 раз в минуту и ​​1 000 000 звонков в месяц, что позволит
конечно, будет хорошо для этого сценария.
Для первоначальной работы вы будете использовать фиксированные широту и долготу
20,7984 и -156,3319 соответственно, что, если вы посмотрите, представляет собой
Мауи, Гавайи. Вы разрешите приложению использовать текущую
информацию о местоположении в следующей главе.

# Создание открытой учетной записи погоды

Вам будет необходимо создать учетную запись. Для этого перейдите на сайт
на https://home.openweathermap.org/users/sign_up и создайте
счет. Обратите внимание, что вам не нужно вводить никаких платежных данных. Ты можешь
используйте его совершенно бесплатно. Если вы нарушите ограничения вызовов, API просто выйдет из строя
вместо случайных зарядов.

# Создание ключа Open Weather API

Далее вам необходимо создать ключ API, что можно сделать на следующем
страницу по адресу https://home.openweathermap.org/api_keys. Сохраните копию этого
Ключ API готов, когда вы в конечном итоге будете использовать его позже в этой главе. Не
пока слишком беспокойтесь, так как вы можете вернуться на указанную выше веб-страницу и
получить доступ к ключу.

# Изучение данных

Прежде чем погрузиться в написание кода, вы должны взглянуть на API
и данные, которые он возвращает. На самом деле API предлагает гораздо больше деталей, чем
вам действительно нужно. Вы можете потреблять детали, если хотите их использовать
в будущем; однако это приводит к некоторым возможным недостаткам. Это
увеличивает сложность чтения данных, если вам нужно отладить
вещей, а также увеличивает объем данных, которые необходимо получить
по вашему приложению. В мобильном мире это может быть дорого!
Учитывая вышеизложенное, вы можете сделать следующий вызов веб-службы, который
включает следующие детали:
• Звонки версии 2.5 API OneCall.
• Обеспечивает широту 20,7984
• Поставляет долготу -156,3319
• Предоставляет метрические единицы, что означает, что вы получите
градусов Цельсия
• Поставки исключают поминутные, ежечасные, ежедневные, оповещения,
это означает, что вы будете получать только текущие данные о погоде
• Предоставляет ключ API, созданный в предыдущем разделе.
Полный URL-адрес, который вам нужно вызвать, выглядит следующим образом:
https://api.openweathermap.org/data/2.5/onecall?lat=20.7984&
lon=-156.3319&units=metric&exclude=поминутно,почасово,ежедневно,оповещения
&appid=APIKEY
Вы можете открыть это в любом веб-браузере, чтобы просмотреть следующий ответ
назад. Вы можете увидеть ключевые детали, которые вам понадобятся для вашего приложения
выделены жирным шрифтом.

```json
{
 «широта»: 20,7984,
 "лон": -156.3319,
"часовой пояс": "Тихий океан/Гонолулу",
 "смещение часового пояса": -36000,
 "текущий": {
 "дт": 1663101650,
 "восход": 1663085531,
 "закат": 1663129825,
 "темп": 20,77,
 "по ощущениям": 21.15,
 "давление": 1017,
 «влажность»: 86,
 "точка_росы": 18.34,
 "уви": 7,89,
 «облаков»: 75,
 "видимость": 10000,
 "скорость ветра": 5,66,
 "ветер_град": 70,
 "погода": [
 {
 "идентификатор": 501,
 "основной": "Дождь",
 "description": "умеренный дождь",
 "значок": "10d"
 }
 ],
 "дождь": {
 «1ч»: 1,78
 }
 }
}
```
# Использование System.Text.Json

Чтобы использовать и десериализовать содержимое JSON, возвращенного в
вам, вам нужно использовать один из следующих двух вариантов:
• Newtonsoft.Json (требуется пакет NuGet)
• Система.Текст.Json
Newtonsoft существует уже много лет и является отличным выбором для
много разработчиков. System.Text.Json стал его преемником и является моим
рекомендацию для этого сценария, тем более, что она поддерживается корпорацией Майкрософт
а Джеймс Ньютон-Кинг, автор Newtonsoft, работает в Microsoft.
Давайте продолжим и будем использовать System.Text.Json, так как это рекомендуемый способ.
для продолжения и поставляется с .NET MAUI из коробки.
Теперь, когда вы увидели, как выглядят данные, вы можете начать строить
классы модели, которые позволят вам десериализовать ответ, приходящий
вернулся из API.

# Создание ваших моделей

Я подчеркнул, что вам действительно не нужна вся информация, которая
возвращается из API. К счастью, вам нужно только построить свою модель, чтобы
покрыть детали, которые вам нужны, и позволить игнорировать остальные во время
процесс десериализации.
Давайте создадим необходимые вам классы моделей. Вы делаете это в обратном порядке
порядок их появления в JSON из-за того, что внешние элементы
необходимо обратиться к внутренним элементам.
Сначала добавьте новую папку, чтобы все было организовано, и назовите ее
Коммуникации.
Теперь добавьте новый файл класса и назовите его Weather.cs.
пространство имен WidgetBoard.Communications;

```Csharp
пространство имен WidgetBoard.Communications;
открытый класс Погода
{
 общедоступная строка Main { получить; набор; }
 значок публичной строки { получить; набор; }
 публичная строка IconUrl => $"https://openweathermap.org/img/
wn/{Icon}@2x.png";
}
```
Ваш класс Weather сопоставляется с элементом погоды в возвращаемом JSON.
из API. Вы можете видеть, что вы сопоставляете с основным и значком
элементов, и вы добавили вычисляемое свойство, которое возвращает URL
указывая на значок, предоставленный Open Weather API. Последнее свойство
вы сопоставляете, IconUrl, является еще одним прекрасным примером удаленных данных.
API предоставляет вам значок, который может отображаться внутри вашего
приложение, представляющее текущую погоду местоположения. На основе
пример в исходном JSON вы видите значение значка 10d. Этот
представляет дождь.

---
Вы заметите, что регистр имен ваших свойств не
соответствуют именам элементов в JSON. Это фактически приведет к
процесс десериализации для отображения по мере необходимости. Когда вы доберетесь до
часть десериализации, вы увидите, как справиться с этим сценарием.
---

Ваш следующий класс модели, который нужно добавить, должен называться Current и, аналогично
к классу Weather он будет отображаться на элемент, который соответствует его имени:
текущий. Ваш текущий файл класса должен иметь следующее содержимое:

```Csharp
используя System.Text.Json.Serialization;
пространство имен WidgetBoard.Communications;
открытый класс Текущий
{
 [JsonPropertyName("temp")]
 общественная двойная температура {получить; набор; }
 публичный восход солнца { получить; набор; }
 публичный закат {получить; набор; }
 общественная погода [] Погода { получить; набор; }
}
```
Этот класс будет содержать массив погоды, заката и восхода солнца.
раз и текущая температура. Со свойством Температура
сопоставление, вы можете увидеть, как можно сопоставить свойство в вашем
модели в элемент в JSON с другим именем. Эта функциональность
чрезвычайно ценно при построении собственных моделей, поскольку позволяет
вы должны назвать свойства, чтобы обеспечить лучший контекст. лично я предпочитаю
избегайте аббревиатур и придерживайтесь явных названий, чтобы сделать намерения
код четкий.
Последний добавляемый класс модели должен называться Forecast.cs и будет
иметь следующее содержание:

```Csharp
пространство имен WidgetBoard.Communications;
Прогноз публичного класса
{
 общественная строка Часовой пояс { получить; набор; }
 общественный Текущий Текущий {получить; набор; }
}
```

Этот класс сопоставляется с элементом верхнего уровня в возвращенном JSON. Ты
сопоставление с элементом Timezone, а также с Current, который будет содержать
ваши ранее сопоставленные значения.

Теперь, когда вы создали классы моделей, которые можно сопоставить с
JSON, возвращенный из Open Weather API, вы можете перейти к вызову
API, чтобы получить этот JSON.

# Подключение к Open Weather API

Прежде чем вы начнете создавать реализацию для доступа к API, вы
собираются создать интерфейс, чтобы определить, что он должен делать. Это имеет
дополнительное преимущество: когда вы хотите протестировать любой класс, который зависит от
IWeatherForecastService, вы можете предоставить фиктивную реализацию
вместо того, чтобы требовать, чтобы модульные тесты обращались к реальному API. я покрою
почему это плохая идея в главе 14, но здесь простой ответ заключается в том, что вы
иметь ограниченное количество звонков, которые вам разрешено делать бесплатно, и вы
не хочу, чтобы модульные тесты поглощали это пособие.

```Csharp
пространство имен WidgetBoard.Communications;
открытый интерфейс IWeatherForecastService
{
 Task<Forecast> GetForecast(двойная широта, двойная
долгота);
}
```

Общий подход к именованию классов, которые взаимодействуют с API, таков:
чтобы добавить суффикс Service, чтобы показать, что он предоставляет услугу пользователю.
Поэтому давайте создадим вашу службу, добавив новый файл класса и вызвав его
WeatherForecastService.cs. Добавьте следующее содержимое:

```Csharp
используя System.Text.Json;
пространство имен WidgetBoard.Communications;
открытый класс WeatherForecastService : IWeatherForecastService
{
 частный HttpClient только для чтения httpClient;
частная константная строка ApiKey = "ВВЕДИТЕ СВОЙ КЛЮЧ";
 частная константная строка ServerUrl = "https://api.open
Weathermap.org/data/2.5/onecall?";
 общественный WeatherForecastService (HttpClient httpClient)
 {
 этот.httpClient = httpClient;
 }
 public async Task<Forecast> GetForecast(двойная широта,
двойная долгота)
 {
 ответ var = ожидание httpClient
 .GetAsync($"{ServerUrl}широта={широта}&lon={долгота}
&units=metric&exclude=ежеминутно, ежечасно, ежедневно, оповещения&
appid={ApiKey}")
 .ConfigureAwait (ложь);
 ответ.EnsureSuccessStatusCode();
 var stringContent = ждать ответа.Содержимое
 .ReadAsStringAsync()
 .ConfigureAwait (ложь);
 var options = новые JsonSerializerOptions
 {
 PropertyNameCaseInsensitive = истина
 };
 вернуть JsonSerializer.Deserialize<Forecast>(строка
Контент, опции);
 }
}
```
Вы добавили изрядную сумму в этот файл класса, поэтому давайте пройдемся по нему шаг за шагом.
шаг за шагом и охватывать то, что он делает.
Во-первых, это поле поддержки HttpClient, которое устанавливается в
конструктор и предоставляется слоем внедрения зависимостей. У вас также есть
константы, представляющие URL-адрес API, а также ваш ключ API, который вы
созданные в предыдущих разделах.
Далее идет основная функциональность метода GetForecast. 
первая строка в этом методе обрабатывает подключение к Open Weather API и
передавая значения широты, долготы и ключа API. Вы также убедитесь,
установить ConfigureAwait(false), потому что вам не нужно перезванивать
в начальном вызывающем потоке. Это помогает немного повысить производительность, так как
позволяет избежать ожидания освобождения вызывающего потока.

```Csharp
ответ var = ожидание httpClient
 .GetAsync($"{ServerUrl}широта={широта}&lon={долгота}
&units=metric&exclude=ежеминутно,ежечасно,ежедневно,оповещения&appid=
{АпиКлюч}")
 .ConfigureAwait (ложь);
```
Затем вы убедитесь, что запрос был успешно обработан
позвонив

```Csharp
ответ.EnsureSuccessStatusCode();
```
---
Обратите внимание, что вышеприведенное вызовет исключение, если код состояния
получено не 200 (успех в порядке).
---

Затем вы извлекаете содержимое строки из ответа.

```Csharp
var stringContent = ждать ответа.Содержимое
 .ReadAsStringAsync()
 .ConfigureAwait (ложь);
```
Наконец, вы используете NuGet-пакет System.Text.Json, который вы
установлен ранее, чтобы десериализовать содержимое строки в модель
классы, которые вы создали.

```Csharp
var options = новые JsonSerializerOptions
{
 PropertyNameCaseInsensitive = истина
};

вернуть JsonSerializer.Deserialize<Forecast>(stringContent,
параметры);
```

Я упоминал ранее, что вы должны были явно согласиться на сопоставление
имена ваших свойств в элементы JSON без учета регистра.
Вы можете видеть из приведенного выше кода, что вы можете сделать это через
использование класса JsonSerializerOptions и, в частности,
Свойство PropertyNameCaseInsensitive.
Теперь, когда вы создали сервис, вы должны добавить свою погоду
виджет и пользоваться услугой.

# Создание WeatherWidgetView

Чтобы создать виджет, вам нужно добавить новое представление. Добавить
новый .NET MAUI ContentView (XAML) в папку Views и
назовите его WeatherWidgetView. В результате создаются два файла:
WeatherWidgetView.xaml и WeatherWidgetView.xaml.cs. Вам нужно
обновите оба файла.

**WeatherWidgetView.xaml**
```xml
<?xml версия="1.0" кодировка="utf-8" ?>
<КонтентВью
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.Views.WeatherWidgetView"
 x: DataType = "вьюмоделс: WeatherWidgetViewModel">
 <вертикальный стекмакет>
 <Ярлык
 Текст = "Сегодня"
 Размер шрифта = "20"
 Вертикальные опции = "Центр"
 Горизонтальные опции = "Пуск"
 TextTransform="Верхний регистр" />
 <Ярлык
 Вертикальные опции = "Центр"
 HorizontalOptions="Центр">
 <Ярлык.FormattedText>
 <форматированная строка>
 <Диапазон
 Text="{Температура связывания,
StringFormat='{0:F1}'}"
 Размер шрифта = "60"/>
 <Диапазон
 Текст="°С" />
 </форматированная строка>
 </Ярлык.FormattedText>
 </метка>
 <Ярлык
 Text="{Привязка погоды}"
 Размер шрифта = "20"
 Вертикальные опции = "Центр"
HorizontalOptions="По центру" />
 <Изображение
 Source="{Привязка IconUrl}"
 Запрос ширины = "100"
 ВысотаЗапрос="100"/>
 </вертикальный стекмакет>
</ContentView>
```
Некоторые из приведенных выше XAML должны показаться знакомыми на основе предыдущего
код, который вы написали. Некоторые биты являются новыми, поэтому давайте рассмотрим их.
Label.FormattedText позволяет вам определять текст различных форматов.
внутри одного элемента управления Label. Это может быть полезно, особенно когда части
текст динамически изменяется по длине и, следовательно, приводит к содержанию
передвигаться. В вашем примере вы добавляете Span с текстовой привязкой
к вашему свойству Temperature в модели представления и второй Span с
символ градусов Цельсия.
Второй новой концепцией является использование элемента управления Image. Привязка
на свойстве Source выглядит относительно просто; однако это
стоит отметить, что .NET MAUI здесь творит чудеса. Ты
привязка строки к свойству. Под капотом .NET MAUI преобразует
строку во что-то, что может напоминать источник изображения. Фактически,
базовый тип называется ImageSource. Кроме того, он проверит ваш
строка, и если она содержит допустимый URL-адрес (например, начинается с https://), то она будет
стремитесь загрузить его как удаленное изображение, а не искать в наборе приложений
скомпилированных ресурсов. .NET MAUI также может обрабатывать кэширование
изображения для вас, чтобы помочь уменьшить количество запросов, отправляемых для загрузки
изображения из удаленного источника. Чтобы использовать эту функцию,
вам нужно предоставить свойство UriImageSource в вашей модели представления, а не
чем строковое свойство.
Процесс преобразования одного вида в другой называется
Преобразователи типов и могут быть довольно распространены в .NET MAUI. я не буду вдаваться
подробно о том, как они работают, поэтому перейдите на сайт документации Microsoft
по адресу https://learn.microsoft.com/dotnet/api/system.componentmodel.
конвертер типов.

**ПогодаВиджетвиев.xaml.cs**

Также необходимо внести следующие коррективы в
Файл WeatherWidgetView.xaml.cs. Эта часть необходима, потому что вы
не создали общий базовый класс для представлений виджетов. Иногда там
может быть веской причиной для их создания; однако, поскольку вы хотите сохранить
максимально простое визуальное дерево, нет общей визуальной базы
класс для использования.

```Csharp
используя WidgetBoard.ViewModels;
пространство имен WidgetBoard.Views;
общедоступный частичный класс WeatherWidgetView : ContentView,
IWidgetView
{
 публичный WeatherWidgetView()
 {
 ИнициализироватьКомпонент();
 }
 публичный IWidgetViewModel WidgetViewModel
 {
 получить => BindingContext as IWidgetViewModel;
 установить => BindingContext = значение;
 }
}
```

Теперь, когда вы создали виджет, вам нужно создать
просмотреть модель, которая будет с ним работать в паре.

# Создание модели WeatherWidgetViewModel

Модель представления, которую необходимо создать для представления связанных с погодой данных, которые могут быть привязаны к пользовательскому интерфейсу, требует некоторой работы, которую вы должны выполнить.
с которыми вы знакомы, и некоторые, с которыми вы не так знакомы. Давайте
переходите к добавлению знакомых элементов, а затем переходите к более новым
концепции. Сначала добавьте новый файл класса в папку ViewModels и назовите его
WeatherWidgetViewModel.cs. Исходное содержимое должно быть изменено на
выглядеть следующим образом:

```Csharp
с помощью WidgetBoard.Communications;
пространство имен WidgetBoard.ViewModels;
открытый класс WeatherWidgetViewModel: BaseViewModel,
IWidgetViewModel
{
 общедоступная константная строка DisplayName = "Погода";
 публичная позиция {получить; набор; }
 общедоступная строка Type => DisplayName;
}
```
Вышеупомянутое должно выглядеть знакомым, так как оно очень похоже на
ClockWidgetViewModel, который вы создали ранее в этой книге. Теперь вам нужно
чтобы добавить информацию о погоде.
Сначала добавьте зависимость от созданного вами IWeatherForecastService.
недавно.

```Csharp
частный только для чтения IWeatherForecastService
служба прогноза погоды;
общедоступная модель WeatherWidgetViewModel (IWeatherForecastService
служба прогноза погоды)
{
 this.weatherForecastService = WeatherForecastService;
 Task.Run(async() => await LoadWeatherForecast());
}
частная асинхронная задача LoadWeatherForecast()
{
 var прогноз = ожидание WeatherForecastService.
Получить прогноз (20.798363, -156.331924);
 Температура = прогноз.Текущая.Температура;
 Погода = прогноз.Текущая.Погода.Первый().Основной;
 IconUrl = прогноз.Текущая.Погода.Первый().IconUrl;
}
```
Внутри вашего конструктора вы храните копию службы, а также
запустить фоновую задачу для получения информации о прогнозе. Довольно часто вы
не стал бы запускать что-то подобное из конструктора; однако,
учитывая, что вы знаете, что ваша модель представления будет создана только тогда, когда она создается
добавленный в пользовательский интерфейс, это вполне приемлемо.
Наконец, вам нужно добавить свойства, к которым ваше представление хочет привязаться.

```Csharp
приватная строка iconUrl;
частная двойная температура;
приватная строка погоды;
общедоступная строка IconUrl
{
 получить => iconUrl;
 set => SetProperty (ссылка iconUrl, значение);
}
общественная двойная температура
{
 получить => температура;
 set => SetProperty (ссылка температура, значение);
}
общедоступная строка Погода
{
 получить => погода;
 set => SetProperty (ссылка на погоду, значение);
}
Это все, что вам нужно в модели представления на данный момент. Теперь вы можете зарегистрировать
виджет и подготовьте его к первому тестовому запуску.
```
# Регистрация вашего виджета

Сначала вам нужно использовать пакет NuGet, чтобы следовать некоторым
рекомендуемые методы регистрации и использования HttpClient
сорт. Идите вперед и добавьте пакет Microsoft.Extensions.Http NuGet и
затем посмотрите, как его использовать.

Щелкните правой кнопкой мыши решение WidgetBoard.

• Выберите «Управление пакетами NuGet».

• Найдите Microsoft.Extensions.Http.

• Выберите правильный пакет.

• Щелкните Добавить пакет.

Внутри вашего файла MauiProgram.cs вам нужно добавить следующие строки
в метод CreateMauiApp:

```Csharp
builder.Services.AddHttpClient<WeatherForecastService>();
builder.Services.AddSingleton<IWeatherForecastService,
Служба прогнозов погоды>();
WidgetFactory.RegisterWidget<WeatherWidgetView, WeatherWidgetVi
ewModel>(WeatherWidgetViewModel.DisplayName);
builder.Services.AddTransient<WeatherWidgetView>();
builder.Services.AddTransient<WeatherWidgetViewModel>();
```
Приведенный выше код регистрирует представление вашего виджета и модели представления с помощью
слой внедрения зависимостей, а также регистрирует его в вашей WidgetFactory,
это означает, что его можно создать из вашего наложения виджета добавления.

# Проверка вашего виджета

Если вы запустите свое приложение и добавите виджет погоды, вы увидите
результат на рис. 10-1.

![изображение](https://user-images.githubusercontent.com/26972859/231479651-c8fff206-c623-4c9d-997e-374a20d832c9.png)
Рисунок 10-1. Приложение работает и показывает ваш виджет погоды
рендеринг правильно

Это прекрасно работает, если у вас хорошее сетевое соединение. 
момент, когда у вас медленное соединение или даже нет соединения, вы
обратите внимание, что вещи загружаются не совсем так, как ожидалось. На самом деле, вы, вероятно,
наблюдать аварию. Вы знали, что это может произойти, основываясь на ваших предыдущих
изучение вещей, которые необходимо учитывать при работе с удаленными
данные. Давайте теперь применим некоторые методы для обработки этих сценариев.

# Добавление некоторого состояния

Первое, что вы хотите сделать, это рассмотреть различные возможные состояния
в котором может находиться ваш процесс. Есть три ключевых сценария, которые вам необходимо
обрабатывать и обеспечивать визуальную обратную связь с вашими пользователями по следующим вопросам:

1. Виджет загружает данные.

2. Виджет имеет данные.

3. Виджет столкнулся с проблемой загрузки данных.

Давайте рассмотрим эти три сценария.
Сначала создайте перечисление, которое будет представлять приведенные выше сценарии.

```Csharp
общественное перечисление
{
 Нет = 0,
 Загрузка = 1,
 Загружено = 2,
 Ошибка = 3
}
```
Вы также хотите изменить код загрузки в модели представления, чтобы сделать
использование этого нового состояния.

```Csharp
частная асинхронная задача LoadWeatherForecast()
{
пытаться
 {
 Состояние = Состояние.Загрузка;
 var прогноз = ожидание погодыForecastService.GetForecast
(20.798363, -156.331924);
 Температура = прогноз.Текущая.Температура;
 Погода = прогноз.Текущая.Погода.Первый().Основной;
 IconUrl = прогноз.Текущая.Погода.Первый().IconUrl;
 Состояние = Состояние.Загружено;
 }
 поймать (исключение ex)
 {
 Состояние = Состояние.Ошибка;
 }
}
```
И вам также нужно добавить свойство State и резервное поле.

```Csharp
частное государство государство;
общественное государство государство
{
 получить => состояние;
 set => SetProperty (состояние ссылки, значение);
}
```
# Преобразование состояния в пользовательский интерфейс

Этот раздел вполне заслуживает более заметного оформления; однако, чтобы позволить
содержание этой книги, я решил показывать только те части, которые основаны на
в контексте тем, которые вы изучаете при создании своего приложения.
Довольно часто в .NET MAUI встречаются сценарии, в которых вы хотите привязать
часть данных в пользовательский интерфейс, но этот тип данных не соответствует желаемому типу в
пользовательский интерфейс. Чтобы не добавлять дополнительные свойства и потенциально добавлять
информацию, связанную с представлением, в свои модели представлений, вы можете использовать
понятие, называемое конвертерами. Преобразователь позволяет определить, как конкретный
тип данных может быть преобразован из своего типа в другой тип. я всегда нахожу
лучший способ рассказать о чем-то подобном — увидеть его в действии, поэтому давайте создадим
конвертер для преобразования из вашего нового перечисления состояний выше в логическое значение
готов к привязке к свойству IsVisible в вашем представлении.
Добавьте новую папку и назовите ее Converters, а затем добавьте новый класс.
файл и назовите его IsEqualToStateConverter.cs, а затем вы можете добавить
следующее содержание:

```Csharp
с помощью System.Globalization;
используя WidgetBoard.ViewModels;
пространство имен WidgetBoard.Converters;
открытый класс IsEqualToStateConverter: IValueConverter
{
 общественное состояние государство { получить; набор; }
 общедоступный объект Convert (значение объекта, тип targetType, объект
параметр, культура CultureInfo)
 {
 если (значение - состояние состояния)
 {
 состояние возврата == состояние;
 }
 возвращаемое значение;
 }
 общедоступный объект ConvertBack (значение объекта, тип targetType,
параметр объекта, культура CultureInfo)
{
 бросить новое исключение NotImplementedException();
 }
}
```
Интерфейс IValueConverter позволяет определить, как значение
переданный может быть преобразован. Реализации этого интерфейса предназначены для использования
в привязке с использованием свойства Converter.

# Отображение состояния загрузки

Стоит отметить, что временами данные могут загружаться очень быстро, и действие
показ спиннера может вызвать негативные эмоции, если он мигает слишком часто.
быстро. Конечно, невозможно знать, какие звонки будут длиться дольше.
чем другие, поскольку существует так много факторов, которые могут повлиять на сеть. В
В такие моменты мне нравится следить за тем, чтобы всегда была минимальная сумма
времени, когда вы показываете счетчик, чтобы не было этой странной вспышки
Пользователь.

```xml
<?xml версия="1.0" кодировка="utf-8" ?>
<КонтентВью
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 xmlns:converters="clr-namespace:WidgetBoard.Converters"
 x:Class="WidgetBoard.Views.WeatherWidgetView"
 x: DataType = "вьюмоделс: WeatherWidgetViewModel">
 <ContentView.Resources>
 <converters:IsEqualToStateConverter
 x:Key="IsLoadingConverter"
 Состояние="Загрузка" />
 </ContentView.Resources>
  <вертикальный стекмакет>
 <Ярлык
 Текст = "Сегодня"
 Размер шрифта = "20"
 Вертикальные опции = "Центр"
 Горизонтальные опции = "Пуск"
 TextTransform="Верхний регистр" />
 <!-- Загрузка -->
 <вертикальный стекмакет
 IsVisible="{Состояние привязки, Converter={StaticResource
Ислоадингконвертер}}">
 <индикатор активности
 IsRunning="{Состояние привязки, Converter={Static
Ресурс IsLoadingConverter}}" />
 <Ярлык
 Text="Загрузка данных о погоде" />
 </вертикальный стекмакет>
 </вертикальный стекмакет>
</ContentView>
```

# Отображение загруженного состояния

Чтобы обработать состояние ошибки, вам нужно добавить еще один экземпляр
ваш IsEqualToStateConverter, на этот раз с установленным свойством State
в Загружено.

```xml
<converters:IsEqualToStateConverter
 x:Key="HasLoadedConverter"
 Состояние = «Загружено» />
```
Затем вы можете использовать этот конвертер в привязке, чтобы показать/скрыть
следующий пользовательский интерфейс:

```xml
<!-- Загружено -->
<вертикальный стекмакет
 IsVisible="{Состояние привязки, Converter={StaticResource
Хаслоадедконвертер}}">
 <Ярлык
 Вертикальные опции = "Центр"
 HorizontalOptions="Центр">
 <Ярлык.FormattedText>
 <форматированная строка>
 <Диапазон
 Text="{Температура привязки, строка
Формат='{0:F1}'}"
 Размер шрифта = "60"/>
 <Диапазон
 Текст="°С" />
 </форматированная строка>
 </Ярлык.FormattedText>
 </метка>
 <Ярлык
 Text="{Привязка погоды}"
 Размер шрифта = "20"
 Вертикальные опции = "Центр"
 HorizontalOptions="По центру" />
 <Изображение
 Source="{Привязка IconUrl}"
 Запрос ширины = "100"
 ВысотаЗапрос="100"/>
</вертикальный стекмакет>
```

# Отображение состояния ошибки

Чтобы обработать состояние ошибки, вам нужно добавить еще один экземпляр вашего
IsEqualToStateConverter, на этот раз со свойством State, установленным на Error.

```xml
<converters:IsEqualToStateConverter
 x:Key="HasErrorConverter"
 Состояние = "Ошибка" />
```
Затем вы можете использовать этот конвертер в привязке, чтобы показать/скрыть
следующий пользовательский интерфейс:

```xml
<!-- Ошибка -->
<вертикальный стекмакет
 IsVisible="{Состояние привязки, Converter={StaticResource
HasErrorConverter}}">
 <Ярлык
 Text="Не удалось загрузить данные о погоде" />
 <Кнопка
 Текст = "Повторить попытку"
 Command="{Привязка LoadWeatherCommand}" />
</вертикальный стекмакет>
```
Возможно, вы заметили, что добавили кнопку и привязали ее
команда для модели представления. Вам нужно добавить это в свою модель представления, если
вы хотите скомпилировать и запустить приложение. Цель кнопки состоит в том, чтобы
разрешить пользователю запросить повторную попытку загрузки информации о погоде, если
Отображается состояние ошибки.
Внутри вашего файла WeatherWidgetViewModel.cs вам нужно сделать
следующее изменение:

```Csharp
публичный ICommand LoadWeatherCommand { получить; }
```
Затем вам нужно обновить конструктор с изменениями, выделенными жирным шрифтом:

```Csharp
public WeatherWidgetViewModel (WeatherForecastService WeatherForecastService)
{
 this.weatherForecastService = WeatherForecastService;
 LoadWeatherCommand = новая команда (асинхронная () => ожидание
Загрузить прогноз погоды());
 Task.Run(async() => await LoadWeatherForecast());
}
```
Это означает, что в случае сбоя загрузки по какой-либо причине пользователь
есть возможность нажать кнопку повтора, и виджет попытается
снова загрузите информацию о погоде. Он будет проходить через добавленные вами состояния, поэтому
пользовательский интерфейс покажет пользователю различные параметры пользовательского интерфейса, когда это произойдет.
Этот тип обработки сбоев считается ручным. Есть способы
автоматически обрабатывать повторные попытки через пакет Polly.

# Упрощение доступа к веб-сервису

В предыдущих разделах было описано, как вы можете напрямую взаимодействовать с веб-сайтом.
обслуживание на самом базовом уровне. Это требует небольшой настройки, но, к счастью, в
ваш сценарий это не было слишком сложно. Некоторые веб-сервисы могут потребовать
гораздо больше настроек или даже вернуть гораздо больше данных.
При создании приложений цель состоит в том, чтобы написать как можно меньше кода.
насколько это возможно, так как это уменьшает объем кода, который вам нужно поддерживать. Этот
заявление не выступает за написание сокращенного кода, который может быть трудным
чтобы человек понял, но вместо этого заявив, что вы хотите сосредоточиться на
детали, которые являются ключевыми для приложения, которое вы создаете, а не
такие вещи, как использование веб-сервиса. Конечно, вы хотите знать, что вы
но необходимость записи базовых битов с помощью HttpClient может
стать громоздким. К счастью, есть пакеты, которые могут
помочь тебе!

# Готовые библиотеки

Сначала я рекомендую вам выяснить, не является ли поставщик веб-услуг
также предоставляет клиентскую библиотеку, облегчающую использование. Довольно
часто поставщики предоставляют библиотеку, особенно когда есть слой
необходима аутентификация. Официальных клиентских библиотек для Open нет.
API погоды; однако существует ряд пакетов NuGet, которые предоставляют
некоторая поддержка использования API.

# Библиотеки генерации кода

Если клиентская библиотека недоступна, вы можете использовать автоматическое создание
package, чтобы уменьшить количество кода, который вам нужно написать. ремонт это фантастика
пакет для этой цели. Он позволяет определить интерфейс, представляющий
вызов веб-службы, а затем Refit сделает все остальное.
Так почему я просто не начал здесь? В новом проекте вы, вероятно,
сделать это, но я всегда твердо чувствую, что вам нужно получить понимание
что делают такие пакеты, как Refit, до того, как вы действительно начнете их использовать. Этот
может быть бесценным, когда что-то идет не так, и вам нужно точно отладить
что и почему идет не так!

# Добавление пакета Refit NuGet

Давайте добавим NuGet-пакет Refit.HttpClientFactory и
затем посмотрите, как его использовать.

• Щелкните правой кнопкой мыши решение WidgetBoard.

• Выберите «Управление пакетами NuGet».

• Найдите Refit.HttpClientFactory.

• Выберите правильный пакет.

• Щелкните Добавить пакет.

Теперь, когда у вас установлен пакет NuGet, вы можете его использовать.
Откройте файл IWeatherForecastService.cs и сделайте следующее:
модификации выделены жирным шрифтом:

```Csharp
с помощью Рефита;
пространство имен WidgetBoard.Communications;
открытый интерфейс IWeatherForecastService
{
 [Get("/onecall?lat={широта}&lon={долгота}&units=metric&
exclude=ежеминутно,ежечасно,ежедневно,alerts&appid=APIKEY")]
 Task<Forecast> GetForecast(двойная широта, двойная
долгота);
}
```
Фантастическая часть приведенного выше кода заключается в том, что вам не нужно писать
реализация. Refit использует генераторы исходного кода, чтобы сделать это за вас! В
на самом деле это означает, что вы можете удалить свой класс WeatherForecastService, поскольку он не
требуется дольше.
Последнее изменение, которое вам необходимо сделать, это изменить то, как вы
зарегистрируйте IWeatherForecastService с вашим MauiAppBuilder в
Файл MauiProgram.cs. Откройте его и внесите следующие изменения.
Сначала добавьте оператор using.

```Csharp
с помощью Рефита;
```
Затем замените

```Csharp
builder.Services.AddSingleton<IWeatherForecastService,WeatherForecastService>();
```
с

```Csharp
строитель.Услуги
 .AddRefitClient<IWeatherForecastService>()
 .ConfigureHttpClient(c => c.BaseAddress = новый Uri("https://
api.openweathermap.org/data/2.5"));
```
Эта новая строка кода использует методы расширения Refit, которые
позволяют использовать реализацию IWeatherForecastService
всякий раз, когда вы регистрируете зависимость от этого интерфейса. Это стоит
повторяя, что реализация IWeatherForecastService
автоматически генерируется для вас через пакет Refit. Для дальнейшего
читая об этом пакете, я полностью рекомендую их веб-сайт по адресу
https://reactiveui.github.io/refit/.

# Дальнейшее чтение

Вы добавили некоторые сложности в ваше приложение, чтобы
обрабатывать сценарий, когда доступ к веб-сервису не загружается должным образом.
Есть две действительно замечательные библиотеки, которые действительно могут помочь уменьшить
количество кода, которое вам нужно написать вокруг этих частей.

# Полли

Чтобы процитировать раздел about в репозитории GitHub,
Polly — это библиотека устойчивости .NET и обработки временных сбоев.
что позволяет разработчикам выражать политики, такие как повторная попытка, схема
Breaker, Timeout, Bulkhead Isolation и Fallback плавно и потокобезопасно.
Polly действительно может помочь сократить объем написания сложного кода, связанного с ошибкой.
сценарии доступа к веб-сервису. Я настоятельно рекомендую ознакомиться с
Репозиторий GitHub по адресу https://github.com/App-vNext/Polly.

# StateContainer из CommunityToolkit.Maui

Вам пришлось встроить преобразователи и применить привязки IsVisible для управления
какое представление отображается, когда ваш виджет находится в определенном состоянии. 
StateContainer уменьшает эти накладные расходы, поэтому вам «просто» нужно определить
состояния и представления для этих состояний.
Если вы любите писать меньше кода, я рекомендую ознакомиться с
Документация Microsoft на https://learn.microsoft.com/dotnet/
набор инструментов сообщества/maui/layouts/statecontainer.

# Краткое содержание

В этой главе вы

• Узнал об удаленных данных

• Узнал, как вы можете взаимодействовать с ним

• Рассмотрены общие соображения

• Посмотрел конкретный пример с Open Weather API

• Создал собственную реализацию для использования Open
API погоды

• Рассмотрено, как использовать возвращенные данные

• Обсудили сценарии, в которых что-то может пойти не так

• Предоставленные реализации для обработки этих сценариев

• Посмотрели, как можно упростить
реализация с переоснащением

• Добавлено в ваш виджет погоды

В следующей главе вы будете

• Узнайте о разрешениях на различных платформах и
как их запросить.

• Узнайте, как использовать API геолокации.

• Узнайте, как написать свой собственный
взаимодействие при необходимости.

• Узнайте, как настроить пользовательский интерфейс в зависимости от платформы на
котором запущено ваше приложение.

• Научитесь настраивать пользовательский интерфейс с помощью обработчика.
архитектура.

# Исходный код

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introduction-MAUI/tree/
главная/ch10.

# Дополнительное задание

Есть так много возможностей для доступа к удаленным данным в вашем
приложение! Вот несколько дополнительных виджетов, которые я хотел бы, чтобы вы рассмотрели
создание

# Виджет TODO

Пример приложения для создания руководств — это приложение TODO.
Я хотел бы, чтобы вы расширили эту идею и добавили TodoWidget в свой
приложение. Для этого можно использовать несколько API TODO.
У вас есть любимый сервис TODO, которым вы пользуетесь? лично мне нравится
Вариант Microsoft TODO. Есть неплохая документация по
Страницы Microsoft, которые помогут вам начать работу: https://learn.microsoft.com/
график/todo-концепция-обзор

# Виджет Цитата дня

Я знаю, что мне определенно нравится вдохновляться цитатой, которая приносит хорошее самочувствие. Почему бы и нет
вы планируете создать виджет, который будет обновляться ежедневно и показывать цитату из
день?
API They Said So Quotes предлагает хороший API для выполнения именно этой задачи.
с документацией, размещенной по адресу https://quotes.rest/.
Другая концепция, которую вам нужно будет рассмотреть, — это то, как вызвать
Класс планировщика для запуска обновления в полночь.

# NASA Space Image of the Day Widget

Мне нравятся некоторые изображения, полученные от НАСА. Это так здорово иметь возможность
заглянуть в просторы космоса! Довольно удобно, у них есть приличный набор
API, которые позволяют создавать виджеты и демонстрировать эти изображения! 
документация на веб-сайте НАСА действительно великолепна и должна быть в состоянии
проведет вас через процесс доступа к нужным вам данным. НАСА
Документацию по API можно найти по адресу https://api.nasa.gov/.
Мне действительно не терпится увидеть эти виджеты в действии!


































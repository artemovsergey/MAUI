# ГЛАВА 11

# Получение конкретики

В этой главе вы узнаете о .NET MAUI Essentials и о том, как
он позволяет вам получать доступ к API-интерфейсам для конкретных платформ, не беспокоясь
о любых сложностях, связанных с платформой. Два конкретных примера
запрашивают разрешения на каждой платформе и получают доступ к
информация о геолокации устройства. Вы узнаете, что требуется, если вы
действительно нужно взаимодействовать с API для конкретных платформ, которые не были
абстрагировано для вас. Наконец, вы познакомитесь с несколькими методами, концепциями,
и архитектуры, которые позволяют вам настроить пользовательский интерфейс и поведение вашего
приложений в зависимости от платформ, на которых они работают.

# Основы .NET MAUI

В предыдущей главе вы создали виджет погоды. ты не закончил
работа, тем не менее, поскольку в настоящее время она загружает только погоду для Мауи, Гавайи.
Не знаю, как вам, а мне не посчастливилось там жить! В этом
раздел, вы узнаете, каково текущее местоположение устройства с точки зрения
долготу и широту, и вы затем отправите эту информацию на
Open Weather API для гораздо более точной сводки погоды
текущее местоположение пользователя.
Для этого необходимо понимание двух ключевых
понятия: система разрешений каждой операционной системы и как
получить доступ к API, специфичным для GPS-координат. К счастью, в .NET MAUI есть
вы рассмотрели оба сценария, но вам нужно знать, как они
работа и любые различия, зависящие от платформы. Давайте посмотрим на каждый, чтобы получить
лучшее понимание.

# Разрешения

Общая тема, которую я обсуждаю в этой книге, — это то, как .NET MAUI
делает много тяжелой работы, когда дело доходит до работы с каждым поддерживаемым
Платформа. Это продолжается с разрешениями, потому что .NET MAUI абстрагирует
большое количество разрешений.

---
Стоит отметить, что каждая операционная система отличается. Не все
требуют разрешений для определенных функций. Обратитесь в Microsoft
документация о том, что поддерживает .NET MAUI и что требуется
для каждой платформы на https://learn.microsoft.com/dotnet/
maui/платформа-интеграция/модель приложения/доступные-разрешения-разрешения.
---

Существует два ключевых метода, позволяющих взаимодействовать с
система разрешений в .NET MAUI.

# Проверка статуса разрешения

Чтобы проверить, дал ли пользователь уже разрешение на
вашего приложения, вы можете использовать метод CheckStatusAsync в классе.
Для виджета «Погода» вам необходим доступ к геолокации устройства.
информация. У вас есть два варианта разрешения на использование:
• LocationWhenInUse: позволяет приложению
для доступа к информации о геолокации, когда приложение
открытые на переднем плане.

LocationAlways: Это позволяет приложению также
получить доступ к информации о геолокации, даже если приложение
является фоновым. Это может быть особенно полезно для
приложения для отслеживания упражнений, которые должны отслеживать
движение пользователя.
Вам нужна только опция LocationWhenInUse для вашего приложения.

```Csharp
Статус PermissionStatus = ожидание разрешений.
CheckStatusAsync<Permissions.LocationWhenInUse>();
```

Рекомендуется проверить статус разрешения
прежде чем запрашивать его, чтобы получить представление о том, имеет ли пользователь
спрашивали раньше. В iOS вам разрешено спрашивать только один раз, а затем
вам необходимо предложить пользователю перейти в приложение «Настройки» и включить
разрешения, если они захотят изменить свое мнение. К сожалению, Android предоставляет
другой подход и вернет статус Denied, даже если пользователь
не было предложено ранее. В этом случае вам рекомендуется
вызвать ShouldShowRationale, чтобы проверить, действительно ли пользователь
подсказал.
Возможные значения для PermissionStatus следующие:
• Неизвестно: разрешение находится в неизвестном состоянии или включено.
iOS пользователю ни разу не было предложено.
• Отклонено: пользователь отклонил запрос на разрешение.
• Отключено: функция отключена на устройстве.
• Предоставлено: Пользователь предоставил разрешение или
автоматически предоставляется.
• Ограничено: в состоянии с ограничениями.

# Запрос разрешения

Как только вы подтвердите, что пользователю не было предложено
запрос разрешения, вы можете перейти к их запросу с помощью
Метод Permissions.RequestAsync вместе с конкретным разрешением на
запрос. В вашем примере это будет разрешение LocationWhenInUse.
Статус PermissionStatus = ожидание разрешений.
RequestAsync<Permissions.LocationWhenInUse>();
Стоит отметить, что метод RequestAsync нужно запускать на
основной поток или поток пользовательского интерфейса. Это необходимо, потому что это может привести к представлению
встроенный системный пользовательский интерфейс, чтобы спросить пользователя, хотят ли они дать
разрешение. Поэтому всякий раз, когда вы вызываете Permissions.RequestAsync, вы
должен убедиться, что ваш код уже запущен в основном потоке с
MainThread.IsMainThread, или вы можете отправить в основной
поток с помощью метода MainThread.InvokeOnMainThreadAsync.

---
Лучшей практикой считается только запрашивать разрешение у пользователя.
использовать определенную функцию при первой попытке использовать эту функцию. Этот
помогает предоставить пользователю контекст относительно того, почему разрешение
запрашивается. Вы также можете обнаружить, что другая платформа
провайдеры (например, Apple, Google и Microsoft) имеют разные правила, которые они
применять при рассмотрении и утверждении заявок, которые вы отправляете
их магазины. Для этого я рекомендую работать с самыми строгими
правила, чтобы избавить себя от боли и усилий.
---

# Обработка разрешений в вашем приложении

Следующий раздел кода рекомендован Microsoft
сайт документации по адресу https://learn.microsoft.com/dotnet/maui/
платформа-интеграция/модель приложения/разрешения?#пример. Это было
включено и оставлено без изменений, так как это помогает действительно подчеркнуть различия
между платформами.
Сначала создайте новую папку и класс для этого нового фрагмента.
функциональность. Вызовите папку Службы. Добавьте новый файл интерфейса и назовите его
ILocationService.cs в папке Services. Содержание этого нового
интерфейс должен быть обновлен до следующего

```Csharp
пространство имен WidgetBoard.Services;
общедоступный интерфейс ILocationService
{
 Task<Location> GetLocationAsync();
}
```
Это дает определение того, что такое реализация службы определения местоположения.
предоставит: асинхронный метод, который в конечном итоге вернет
Объект местоположения.
Далее создайте реализацию. Добавьте новый файл класса под
Папка Services и назовите ее LocationService.cs. Изменить начальный
содержание к следующему:

```Csharp
пространство имен WidgetBoard.Services;
открытый класс LocationService : ILocationService
{
}
```
Теперь, когда у вас есть пустой класс, вы можете добавить метод для обработки
запросы разрешений готовы к использованию.

```Csharp
частная асинхронная задача<PermissionStatus>
CheckAndRequestLocationPermission()
{
 Статус PermissionStatus = ожидание разрешений.
CheckStatusAsync<Permissions.LocationWhenInUse>();
 если (статус == PermissionStatus.Granted)
 {
 статус возврата;
 }
 if (status == PermissionStatus.Denied && DeviceInfo.
Платформа == DevicePlatform.iOS)
 {
 // Предлагать пользователю включить в настройках
 // В iOS, если разрешение было отклонено, оно не может
запросить повторно из приложения
 статус возврата;
 }
 если (Permissions.ShouldShowRationale<Permissions.
РасположениеПриИспользовании>())
 {
 // Запросить у пользователя дополнительную информацию о
зачем нужно разрешение
 }
 status = await Permissions.RequestAsync<Permissions.
РасположениеПриИспользовании>();
 статус возврата;
}
```
Теперь, когда вы добавили возможность запрашивать разрешение пользователя на
использовать API геолокации на устройстве, вы можете приступить к его использованию.

# Использование API геолокации

.NET MAUI предоставляет возможность доступа к API геолокации каждой платформы.
чтобы получить долготу и широту, представляющие, где в
world, где в данный момент находится устройство, на котором запущено приложение. Полная информация
о том, что предоставляет API, можно узнать по адресу https://learn.microsoft.com/
dotnet/maui/платформа-интеграция/устройство/геолокация.

# Регистрация службы геолокации

Откройте файл MauiProgram.cs и пропишите геолокацию
реализацию, чтобы вы могли использовать ее через уровень внедрения зависимостей.
Вам нужно добавить следующую строку в метод CreateMauiApp:

```Csharp
builder.Services.AddSingleton(Geolocation.Default);
```

# Использование службы геолокации

Теперь это означает, что вы можете добавить зависимость от IGeolocation.
интерфейс и везде, где .NET MAUI предоставляет вам экземпляр. Давайте
используйте реализацию IGeolocation в файле LocationService.cs.
Есть несколько модификаций, которые вам нужно сделать, поэтому я пройдусь по ним.
каждый.
Добавьте поле для реализации IGeolocation в корень
класс.

```Csharp
частная геолокация IGeolocation только для чтения;
Назначьте реализацию IGeolocation в конструкторе.
public LocationService (геолокация IGeolocation)
{
 this.geolocation = геолокация;
}
Предоставьте метод для возврата объекта Location.
общедоступная асинхронная задача<Location> GetLocationAsync()
{
 return await MainThread.InvokeOnMainThreadAsync (асинхронный () =>
 {
 var status = await CheckAndRequestLocationPermission();
 если (статус != PermissionStatus.Granted)
 {
 вернуть ноль;
 }
 return await this.geolocation.GetLocationAsync();
 });
}
```
Эта реализация сначала гарантирует, что вы работаете на основном
поток, необходимый для доступа на основе местоположения. Затем он вызывает ваш
метод обработки разрешений и, если у приложения есть разрешение, оно вызывает метод
IGeolocation и возвращает результирующий объект Location.
Теперь вы готовы использовать LocationService.

# Регистрация службы определения местоположения

Откройте файл MauiProgram.cs и зарегистрируйте LocationService.
реализацию, чтобы вы могли использовать ее через уровень внедрения зависимостей.
Вам нужно добавить следующую строку в метод CreateMauiApp:

```Csharp
builder.Services.AddSingleton<ILocationService,
Служба определения местоположения>();
```

# Использование ILocationService

Давайте воспользуемся реализацией ILocationService в вашем
Файл WeatherWidgetViewModel.cs. Есть несколько модификаций, которые вам нужны
сделать, поэтому я пройдусь по каждому
Добавьте поле для реализации ILocationService в корень
класс.

```Csharp
частный только для чтения ILocationService locationService;
```
Назначьте реализацию ILocationService в конструкторе;
изменения выделены жирным шрифтом.

```Csharp
общедоступная модель WeatherWidgetViewModel (
 IWeatherForecastServiceпогодаForecastService,
 ILocationService (локационная служба)
{
 this.weatherForecastService = WeatherForecastService;
 this.locationService = LocationService;
 LoadWeatherCommand = новая команда (асинхронная () => ожидание
Загрузить прогноз погоды());
}
```
Измените перечисление State, включив в него новое значение, чтобы вы могли
справиться, когда что-то пойдет не так с доступом к разрешению. Добавить
Значение PermissionError, как показано ниже жирным шрифтом.

```Csharp
общественное перечисление
{
 Нет = 0,
 Загрузка = 1,
 Загружено = 2,
 Ошибка = 3,
 Ошибка разрешения = 4
}
```
Измените метод LoadWeatherForecast, чтобы он вызывал новый
Реализация ILocationService для определения местоположения устройства.
местоположение, а затем использовать его для вызова Open Weather API, чтобы узнать
погода в месте нахождения устройства.

```Csharp
частная асинхронная задача LoadWeatherForecast()
{
 Состояние = Состояние.Загрузка;
 пытаться
 {
 var location = await this.locationService.
GetLocationAsync();
 если (местоположение равно нулю)
 {
 Состояние = Состояние.PermissionError;
 возвращаться;
 }
 var прогноз = ожидание WeatherForecastService.
GetForecast(местоположение.Широта, местоположение.Долгота);
 Температура = прогноз.Текущая.Температура;
 Погода = прогноз.Текущая.Погода.Первый().Основной;
 IconUrl = прогноз.Текущая.Погода.Первый().IconUrl;
 Состояние = Состояние.Загружено;
 }
 поймать (исключение ex)
 {
 Состояние = Состояние.Ошибка;
 }
}
```
Вы внесли здесь несколько изменений, так что давайте разберем их.
Во-первых, вы вызываете locationService, чтобы получить местоположение устройства.
Если он возвращает null, это означает, что приложение не имеет разрешения и
вы устанавливаете состояние в PermissionError.
Если у вас есть разрешение, вы передаете текущее местоположение устройства в
Метод WeatherForecastService.GetForecast.

# Отображение ошибок прав доступа для вашего пользователя

Вы добавили новое значение состояния, а также присвоили его в своем представлении.
модель, когда вы либо не можете получить параметр разрешения, либо пользователь
запретил доступ к функции LocationWhenInUse. Теперь вы можете
добавьте поддержку в свой пользовательский интерфейс, чтобы ответить на это значение и показать что-то
соответствующий пользователю. Откройте файл WeatherWidgetView.xaml и сделайте
следующие модификации.
Добавьте экземпляр конвертера в тег <ContentView.Resources>

```xml
<converters:IsEqualToStateConverter
 x:Key="HasPermissionErrorConverter"
 Состояние = "Ошибка Разрешения" />
```
Затем вы можете добавить раздел, который будет отображаться, когда состояние
свойство равно PermissionError. Вы должны добавить это в
Файл WeatherWidgetView.xaml после следующего раздела:

```xml
<!-- Ошибка -->
<вертикальный стекмакет
 IsVisible="{Состояние привязки,
Converter={StaticResource HasErrorConverter}}">
 ...
</вертикальный стекмакет>
```
Раздел, который вы хотите добавить, выглядит следующим образом:

```xml
<!-- Ошибка разрешения -->
<вертикальный стекмакет
 IsVisible="{Состояние привязки, Converter={StaticResource
HasPermissionErrorConverter}}">
 <Ярлык
 Text="Невозможно получить данные о местоположении" />
 <Кнопка
 Текст = "Повторить попытку"
 Command="{Привязка LoadWeatherCommand}" />
</вертикальный стекмакет>
```
Теперь, когда вы добавили все необходимые фрагменты кода для вызова
API разрешений и геолокации вам необходимо настроить каждый из ваших
поддерживаемые платформы, чтобы включить разрешение местоположения.

# Настройка компонентов для конкретной платформы

Именно здесь .NET MAUI перестает держать вас за руку и требует от вас
выполнить некоторую работу в папках для конкретной платформы. Многие API, которые
предоставляется .NET MAUI, как подробно описано в этом разделе документации
сайте https://learn.microsoft.com/dotnet/maui/platformintegration/, может потребоваться определенный уровень настройки для конкретной платформы. Это зависит от платформы. Например, для тактильной поддержки,
только Android требует некоторой настройки, тогда как для Geolocation API все
платформы требуют некоторой настройки.
К счастью, .NET MAUI предоставляет полезные исключения и сообщения об ошибках.
если вы пропустите какие-либо настройки для конкретной платформы, и они обычно указывают
действие, необходимое для устранения проблемы. Такие темы делают обязательным
что вы действительно тестируете свое приложение на каждой из платформ, которые вы хотите
поддержки, чтобы убедиться, что он ведет себя так, как ожидалось. Давайте настроим каждую платформу, чтобы ваше приложение могло полностью поддерживать доступ
текущее местоположение устройств.

# Андроид

Android требует настройки нескольких разрешений и функций в
чтобы ваше приложение использовало разрешение LocationWhenInUse. Ты
можно настроить их внутри Platforms/Android/MainApplication.cs
файл, поэтому откройте его и сделайте следующие добавления жирным шрифтом:

```Csharp
с помощью Android.App;
с помощью Android.Runtime;
[сборка: UsesPermission(Android.Manifest.Permission.
AccessCoarseLocation)]
[сборка: UsesPermission(Android.Manifest.Permission.
AccessFineLocation)]
[сборка: UsesFeature ("android.hardware.location",
Требуется = ложь)]
[сборка: UsesFeature("android.hardware.location.gps",
Требуется = ложь)]
[сборка: UsesFeature ("android.hardware.location.network",
Требуется = ложь)]
пространство имен WidgetBoard;
```
Обратите внимание, что использование ключевого слова сборки требует, чтобы атрибуты
применяются на уровне сборки, а не на уровне класса, как текущий
Использование атрибута [Приложение]. Для получения дополнительной информации о том, как начать работу
с геолокацией см. документацию Microsoft по адресу https://
Learn.Microsoft.com/dotnet/maui/платформа-интеграция/устройство/
геолокация?tabs=android-начало работы.

Если вы сейчас запустите приложение на Android, то увидите, что первое
когда вы добавляете виджет погоды на доску, система представит
следующее всплывающее окно для пользователя с просьбой разрешить разрешение для вашего
приложение для использования функции определения местоположения. На рис. 11-1 показан результат
запуск вашего приложения на Android.

![изображение](https://user-images.githubusercontent.com/26972859/231486435-b082c9f9-79af-4c58-bc42-eb815a1cb535.png)
Рисунок 11-1. Приложение, работающее на Android, показывает
запрос разрешения при первом добавлении виджета погоды на доску

# iOS/Мак

Apple требует, чтобы вы указали причину, по которой ваше приложение хочет использовать
функцию геолокации в процессе определения того, что ваше приложение
использует функцию. Вы можете настроить это, изменив Platforms/iOS/
Файлы Info.plist и Platforms/MacCatalyst/Info.plist для iOS и
Mac Catalyst соответственно. Оба файла требуют одинаковых изменений, так что давайте откроем
их и добавьте следующие строки. Обратите внимание, что я предпочитаю редактировать файлы
внутри кода Visual Studio, поскольку я считаю, что это обеспечивает лучший опыт редактирования.
В Visual Studio есть встроенный редактор, но лично я предпочитаю редактировать
XML напрямую. Добавьте следующие строки внутрь элемента <dict>:

```xml
<key>NSLocationWhenInUseUsageDescription</key>
<string>Для предоставления точной информации о погоде
информация.</string>  
```
Для получения дополнительной информации о том, как начать работу с геолокацией, см.
в документации Microsoft по адресу https://learn.microsoft.com/
dotnet/maui/platform-integration/device/geolocation?tabs=ios —
начать
Если вы сейчас запустите приложение на iOS и macOS, то увидите, что
при первом добавлении виджета погоды на доску система представит
следующее всплывающее окно для пользователя с просьбой предоставить разрешение для вашего
приложение для использования функции определения местоположения. На рис. 11-2 показан результат
запуск приложения на iOS.

![изображение](https://user-images.githubusercontent.com/26972859/231486775-9169a4ff-9726-4bd8-bd2b-0a3065aff5c9.png)
Рисунок 11-2. Приложение, работающее на iOS (слева) и macOS (справа)
отображение запроса на разрешение при первом добавлении виджета погоды
к доске

# Окна

Приложения Windows имеют концепцию возможностей, и
разработчики объявляют, какие возможности требуются в их приложениях.
Чтобы сделать это для вашего приложения, вам необходимо изменить файл Platforms/Windows/Package.appxmanifest. Обратите внимание, что я выбираю
редактировать файлы внутри кода Visual Studio, так как я считаю, что это обеспечивает лучшее редактирование
опыт. Добавьте следующую строку внутрь элемента <Capabilities>:

```xml
<DeviceCapability Name="location"/>
```
Для получения дополнительной информации о том, как начать работу с геолокацией, см.
документацию Microsoft по адресу https://learn.microsoft.com/dotnet/
maui/platform-integration/device/geolocation?tabs=windowsget-started.
Если вы сейчас запустите приложение в Windows, вы не увидите разрешение
всплывающее окно запроса. На рис. 11-3 показан результат запуска приложения на
Окна.

![изображение](https://user-images.githubusercontent.com/26972859/231487071-a404f50a-2c09-45be-bfce-7e71c026bfd8.png)
Рисунок 11-3. Приложение, работающее в Windows, показывает
запрос разрешения при первом добавлении виджета погоды на доску
  
# Доступ к API для конкретной платформы  
  
Несмотря на то, что .NET MAUI предоставляет вам множество функциональных возможностей,
box, могут быть случаи, когда вам нужно написать собственное взаимодействие с
уровень, специфичный для платформы, для достижения ваших целей. Любая функциональность
может быть достигнуто на конкретной платформе также может быть достигнуто в рамках .NET
Приложение МАУИ. Вам просто, возможно, придется сделать тяжелую работу самостоятельно. Если
ваша реализация считается достаточно полезной для других разработчиков, вы
следует предложить изменения команде .NET MAUI.
Есть две основные концепции, которые вы можете использовать при создании кода для конкретной платформы в .NET MAUI. Давайте рассмотрим каждый из них через
простой пример создания LocationService, который возвращает долготу
и широта штаб-квартиры для каждого поставщика платформы (например, Google,
Apple и Microsoft).  
  
# Платформо-зависимый код с директивами компилятора
  
Скорее всего, вы столкнетесь с использованием директивы компилятора #if.
при работе с приложением .NET MAUI. Я не большой их поклонник, но я
признайте, что в некоторых сценариях они действительно приносят пользу.  
  
```Csharp
пространство имен WidgetBoard.Services;
открытый класс PlatformLocationService : ILocationService
{
 общедоступная задача<Location> GetLocationAsync()
 {
 Расположение;
#если АНДРОИД
 местоположение = новое местоположение (37.419857, -122.078827);
#элиф ОКНА
 местоположение = новое местоположение (47.639722, -122.128333);
#еще
 местоположение = новое местоположение (37.334722, -122.008889);
#endif
 вернуть Task.FromResult(местоположение);
 }
}
```
Приведенный выше код будет скомпилирован различными способами в зависимости от цели.
Платформа. Полученный скомпилированный код для платформы Android выглядит так:
следует:
  
```Csharp
пространство имен WidgetBoard.Services;
открытый класс PlatformLocationService : ILocationService
{
 общедоступная задача<Location> GetLocationAsync()
 {
 Расположение;
 местоположение = новое местоположение (37.419857, -122.078827);
 вернуть Task.FromResult(местоположение);
 }
}  
```

Это означает, что будет скомпилирован только код, специфичный для платформы.
и отправлены на эту платформу.
Этот подход может хорошо работать в этом сценарии, но как только вам понадобится
использовать несколько классов или других платформо-зависимых библиотек, код будет
очень быстро становятся сложными. В более сложных случаях можно использовать
папки для конкретной платформы, созданные в вашем проекте для вас.  
  
# Платформо-зависимый код в папках платформы  
  
Я кратко рассмотрел эти папки в главе 2. На каждой платформе есть папка и
файлы внутри каждой папки (например, /Platforms/Android/) будут скомпилированы только
для этой платформы, когда вы ориентируетесь на нее. Для создания такого же
PlatformLocationService из предыдущего раздела, вам сначала нужно
создайте разделяемый класс в папке Services со следующим содержимым:  
  
```Csharp
пространство имен WidgetBoard.Services;
общедоступный частичный класс MultiPlatformLocationService:
ILocationService
{
}  
```

Приведенный выше код не будет компилироваться, потому что вы не реализовали
ILocationService. Это ожидается до тех пор, пока вы не добавите свой специфичный для платформы
реализации, так что не волнуйтесь. Вы добавляете частичное ключевое слово, потому что
это только частичная реализация. Файлы и классы для конкретных платформ
вы добавите в ближайшее время, завершит эту частичную реализацию.
Затем вам нужно создать свою платформу Android
выполнение. Для этого вы добавляете новый файл класса в
/Platforms/Android/ и назовите ее PlatformLocationService.cs,
так же, как тот, что выше. Вы хотите изменить его содержимое на следующее:  
  
```Csharp
пространство имен WidgetBoard.Services;
общедоступный частичный класс MultiPlatformLocationService
{
 общедоступная задача<Location> GetLocationAsync()
 {
 вернуть Task.FromResult (новое местоположение (37.419857,
-122.078827));
 }
}
```
Этот класс будет скомпилирован только тогда, когда платформа Android
target, и поэтому вы получаете скомпилированный вывод, очень похожий на тот,
в разделе «Код для конкретной платформы с директивами компилятора». 
ключевое отличие в том, что вам не нужно добавлять какие-либо из этих неприятных #if
директивы.  
  
```Csharp
При построении специфичных для платформы реализаций таким образом
пространство имен ваших разделяемых классов должно совпадать! В противном случае
компилятор не сможет построить один класс.  
```
  
# Переопределение пользовательского интерфейса для конкретной платформы
 
Одна фундаментальная часть .NET MAUI заключается в том, что он использует
базовые элементы управления платформой для обработки рендеринга наших приложений.
Это приведет к тому, что наши приложения будут выглядеть по-разному на каждом из
платформы. В большинстве сценариев это считается хорошей вещью
потому что приложение соответствует внешнему виду платформы.
Однако иногда вам потребуется переопределить некоторые специфичные для платформы
рендеринга или даже просто для настройки рендеринга элементов управления в вашем приложении на
конкретная платформа.  
  
# На платформе  
  
Типичным примером необходимости изменения свойств элемента управления является
размер текста или расстояние вокруг элементов управления (поля или отступы). я всегда
обнаружите, что последние штрихи делают приложение действительно гладким
и полировка может привести к необходимости настройки таких деталей для каждой платформы.
Есть два основных способа добиться этого, и они зависят от того,
вы являетесь разработчиком пользовательского интерфейса, ориентированным на XAML или C#. Давайте рассмотрим оба с
пример.  
  
# Расширение разметки OnPlatform  
  
XAML, как уже упоминалось, не так многофункционален с точки зрения того, что можно написать.
и достигнуто. Поэтому дополнительный функционал предоставляется .NET
MAUI для преодоления этих ограничений. Одним из таких примеров является OnPlatform.
расширение разметки. Расширения разметки XAML помогают повысить мощность и
гибкость XAML, позволяя устанавливать атрибуты элементов из множества
источников.
Вы можете решить, что в вашем файле ClockWidgetView.xaml FontSize
свойство слишком велико для iOS и Android и решили изменить его только для
эти платформы. Давайте посмотрим на код и посмотрим, как вы можете изменить
свойство, основанное на платформе, на которой работает приложение.
  
```xml
<?xml версия="1.0" кодировка="utf-8" ?>
<Ярлык
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.Views.ClockWidgetView"
 Размер шрифта = "60"
 Вертикальные опции = "Центр"
 HorizontalOptions="Центр"
 x: DataType = "вьюмоделс: ClockWidgetViewModel"
 Text="{Время привязки}">
 <Label.BindingContext>
 <viewmodels: ClockWidgetViewModel />
 </Label.BindingContext>
</метка>  
```
Приведенный выше код показывает, что для свойства FontSize в настоящее время установлено значение
значение 60. С помощью расширения разметки OnPlatform вы можете изменить это
значение в зависимости от платформы, на которой работает приложение. Следующее
пример кода показывает, как вы можете сохранить значение по умолчанию 60, а затем
переопределить для платформ, которые вы хотите:  

```xml
FontSize="{По умолчанию на платформе = 60, Android = 25, iOS = 30}"  
```
В приведенном выше примере кода указано, что все платформы по умолчанию будут использовать
FontSize 60, если приложение не работает на Android, и значение
будет использоваться 25 или если приложение работает на iOS и значение 30 будет
использоваться.
  
# Условные операторы  
  
Если вы создали свой пользовательский интерфейс на C# или хотели хотя бы изменить FontSize
свойства элемента управления Label аналогичным образом вы можете написать следующее
условный оператор С#:  
  
```Csharp
публичный ClockWidgetView()
{
 если (DeviceInfo.Platform == DevicePlatform.Android)
 {
 Размер шрифта = 25;
 }
 иначе если (DeviceInfo.Platform == DevicePlatform.iOS)
 {
 Размер шрифта = 30;
 }
 еще
 {
 Размер шрифта = 60;
 }
}  
```
Для получения дополнительной информации об использовании расширения разметки OnPlatform
и другие возможные расширения разметки, которые позволяют настраивать
вашего приложения, обратитесь к документации Microsoft по адресу
https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/
потребление#на платформе-разметки-расширения.
Будут времена, когда просто переопределить значения, подобные этому, недостаточно.
Для более сложных сценариев необходимо рассмотреть архитектуру, которая
совершенно новый для .NET MAUI, и это архитектура обработчика.  
  
# Обработчики

Обработчики — это область, в которой .NET MAUI действительно сияет! Если у вас есть
исходить из фона Xamarin.Forms, вы оцените боль
которые принесли пользовательские рендереры. Если у вас нет Xamarin.Forms
опыт, вам очень повезло! Я не буду слишком углубляться в детали
старого подхода, так как это книга о .NET MAUI, а не о прошлом;
однако я чувствую, что стоит поговорить о старых проблемах и о том, как они
были преодолены новой архитектурой обработчика.
Как в Xamarin.Forms, так и в .NET MAUI мы преимущественно создаем
пользовательские интерфейсы с абстрактными элементами управления: элементы управления, определенные в Microsoft
пространство имен, а не конкретно какие-либо элементы управления платформой. Эти элементы управления
в конечном итоге должны быть сопоставлены с уровнем, специфичным для платформы. в
В дни Xamarin.Forms у вас будет собственный модуль визуализации. Рендерер
будет нести ответственность за знание абстрактного управления, а также
специфичные для платформы элементы управления и сопоставления значений свойств и обработчиков событий
и такое между ними двумя. Это считается сильно связанной конструкцией,
это означает, что становится действительно довольно сложно улучшить элементы управления и
их рендеринг. Если вы хотите переопределить небольшое количество поведения,
вам придется реализовать полный рендерер, отвечающий за сопоставление всех
свойства/события. Это было очень больно!  
В .NET MAUI эта концепция рендереров полностью заменена.
с обработчиками. Эта новая архитектура обеспечивает несколько дополнительных уровней между
абстрактные элементы управления в пространстве имен .NET MAUI и базовые
специфические для платформы элементы управления, отображаемые в наших приложениях. Это
считается гораздо более слабо связанным, в основном из-за того, что каждый
будет реализовывать ряд интерфейсов, и это функция обработчика.
ответственность за взаимодействие с интерфейсом, а не за конкретный элемент управления.
Это имеет много преимуществ, в том числе тот факт, что несколько элементов управления могут
реализовать один и тот же интерфейс и в конечном итоге полагаться на один и тот же единый
обработчик. Он также предоставляет возможность определять меньшие фрагменты общих
функциональность и, как вы все знаете, меньшие классы и файлы намного
легче читать, следовать и, в конечном счете, поддерживать. Рисунок 11-4 показывает, как
абстрактный класс Button в .NET MAUI сопоставляется с конкретными элементами управления на
каждой платформы.  
  
![изображение](https://user-images.githubusercontent.com/26972859/231488966-8cfc6c41-57cb-4671-96cd-82085ebe13d1.png)
Рисунок 11-4. Архитектура обработчика в .NET MAUI  
  
Если вы хотите создать новый элемент управления, который должен сопоставляться с реализациями для конкретных платформ, вам следует следовать шаблону, показанному на рис.
Рисунок 11-4. Например, если вы сделали свой FixedWidgetBoard элементом управления
таким образом вы также создадите интерфейс IFixedWidgetBoard.
а затем FixedWidgetBoardHandler, а затем карту из виртуального представления
через вид на платформу. Вы не использовали этот подход в своем сценарии
потому что пользы не было. На самом деле, это привело бы к большему количеству кода, потому что  
вам нужно будет сопоставить каждую платформу по отдельности. Эта концепция может
звучит так, как будто это всегда будет вызывать больше усилий; однако в ситуации
Кнопка, это имеет смысл, потому что каждая платформа уже имеет определение
что такое кнопка и как она себя ведет.
Довольно часто как разработчики приложений вы будете использовать существующие
элементы управления, а не создавать свои собственные элементы управления, поэтому вместо необходимости
чтобы построить все, что вы видите на рис. 11-4, вы можете настроить элементы управления
с помощью обработчиков.
  
# Настройка элементов управления с помощью картографов  
  
Картографы являются ключом к архитектуре обработчика. Они определяют действия, которые
будет выполняться при изменении свойства или при отправке команды
между кросс-платформенными элементами управления и специфичными для платформы представлениями. Этот кусок
информации сама по себе может быть не очень полезной, но как только вы получите
понимание того, как изменить эти действия или предоставить новые, вы
может начать понимать, насколько мощным это может быть. Большинство
Обработчики .NET MAUI находятся в пространстве имен Microsoft.Maui.Handlers,
что делает их относительно легкими для обнаружения. Есть несколько исключений
к этому правилу, которое определено в их документации по адресу https://learn.
microsoft.com/dotnet/maui/user-interface/handlers/#handlerbased-views.

---
Важно отметить, что, изменяя преобразователи для обработчиков,
вы будете переопределять поведение для всех реализаций
управлять им можно. Вы можете преодолеть это, создав класс (например,
MyButton), который наследуется от элемента управления, который вы хотите улучшить.
(например, Button), а затем ваш обработчик нацелен на новый класс
(Моя кнопка).
---
  
# Область настройки картографа
  
Все элементы управления в .NET MAUI, использующие архитектуру обработчика, также предоставляют
События HandlerChanging и HandlerChanged или OnHandlerChanging
и OnHandlerChanged, что означает, что вы можете подписаться на них и
настроить внешний вид конкретного экземпляра элемента управления.
  
# Дальнейшее чтение

Одним из замечательных примеров переопределения элементов управления таким образом является выступление Питера
Марчев, разработчик Telerik, показывает, как можно настроить отдельные
компоненты в своих диаграммах контролируются очень ограниченным количеством кода.
Выступление можно посмотреть на www.youtube.com/watch?v=s7WfTT-MVSg.
  
# Краткое содержание  
  
В этой главе вы

  • Узнал о разрешениях на различных платформах
и как их запросить

  • Узнали, как использовать API геолокации.

  • Написал собственное взаимодействие для конкретной платформы, когда
необходимый

  • Обнаружено, как настроить пользовательский интерфейс в зависимости от платформы.
на котором работает ваше приложение

  • Дальнейшая настройка пользовательского интерфейса с помощью обработчика
архитектура

  В следующей главе вы будете

  • Узнайте, что такое тестирование и почему оно важно.
  
Расскажите, что такое модульное тестирование и как вы можете применить его к
Приложение .NET MAUI.
  
• Узнайте, что такое тестирование моментальных снимков и как вы можете
реализовать это.

  • Получите представление о тестировании устройств и о том, как вы можете
применить их к своим приложениям.

  • Загляните в будущее, чтобы еще раз испытать добро.  
  
# Исходный код  

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introduction-MAUI/tree/
главная/ch11.  
  
# Дополнительное задание  
  
Вы только поверхностно коснулись API-интерфейсов интеграции с платформой, которые
.NET MAUI предлагает вам. Я хотел бы, чтобы вы просмотрели другие возможные
API и создавать свои собственные виджеты, которые выиграют от них. 
документацию по API интеграции платформы можно найти по адресу https://
Learn.microsoft.com/dotnet/maui/platform-integration/.  
  
# Виджет барометра
  
Вы можете использовать API барометра, чтобы сообщать об окружающей среде.
давление воздуха возвращается к пользователю. На самом деле, это может быть хорошим дополнением к
Виджет погоды, а не совершенно новый виджет. Документация для
этот API можно найти по адресу https://learn.microsoft.com/dotnet/maui/
платформа-интеграция/устройство/сенсоры?#барометр.
  
# Поиск геокодирования
  
Я не хочу включать разрешения, такие как доступ к местоположению, для приложений, которые мне не нужны.
поверьте, они действительно нужны. Возможно, вы можете улучшить свой виджет погоды
чтобы пользователь мог указать свой ближайший город, поселок или почтовый индекс и
затем используйте API геокодирования для обратного поиска долготы и широты
информация, необходимая для Open Weather API. Документация
API геокодирования можно найти по адресу https://learn.microsoft.com/.
dotnet/maui/платформа-интеграция/устройство/геокодирование.  
  
  

# ГЛАВА 12

# Тестирование

Тестирование — очень важная часть процесса разработки программного обеспечения;
это позволяет вам убедиться, что вы доставили именно то, что требовалось
а также проверить правильность работы программного обеспечения. Он также обеспечивает
подстраховка от обнаружения регрессий в продуктах, которые вы создаете.
Существует множество различных подходов к разработке и написанию тестов.
и где они вписываются в процесс разработки программного обеспечения. Эта глава
не предназначено для полного понимания этих подходов, но
познакомить вас с различными методами тестирования приложения .NET MAUI, почему
они могут быть полезными и пробудить в вас интерес к обучению их использованию в
больше глубины

# Модульное тестирование

Юнит-тестирование — это процесс проверки того, что небольшие модули, обычно метод
или класса приложения соответствуют их дизайну и ведут себя так, как предполагалось. Один
Большим преимуществом тестирования такой небольшой единицы кода является то, что это упрощает
для вас, чтобы определить, где проблемы могут лежать или закрадываться как часть регрессии.
За свою карьеру я работал со многими устаревшими системами, где
команды пренебрегали применением модульного тестирования и опыта при попытке
выявить причину ошибки в большой системе действительно может быть дорого с точки зрения
время и деньги.
Несмотря на то, что юнит-тестирование рассматривается ближе к концу этой книги, это концепция.
которые должны быть приняты на ранней стадии процесса разработки. Модульное тестирование может
помощь в разработке и создании кода, который легче читать и поддерживать
потому что это заставляет вас раскрывать эти маленькие единицы функциональности и
в конечном итоге следовать принципам SOLID.
Модульное тестирование само по себе не выявит всех ошибок в системе и не должно
можно полагаться как на единственное средство тестирования ваших приложений. При использовании в
в сочетании с другими формами тестирования, такими как интеграционное, функциональное или
сквозное тестирование, вы можете быть уверены, что ваше приложение
стабилен и дает то, что требуется.
Давайте посмотрим, как реализовать модульное тестирование с помощью .NET MAUI.

# Модульное тестирование в .NET MAUI

Приложения .NET MAUI — это, как следует из названия, проекты на основе .NET,
это означает, что любая из существующих платформ модульного тестирования на основе .NET может
использоваться.

```xml
В настоящее время проект .NET MAUI по умолчанию несовместим.
с проектом модульного тестирования. Я расскажу, как решить эту проблему, в разделе «Добавление
Проект модульного тестирования для вашего решения».
```

Есть три известных фреймворка, которые поставляются с шаблоном.
поддержки в Visual Studio, что означает, что вы можете создавать их с помощью «Файл» ➤ «Добавить».
Новый вариант проекта. Три фреймворка перечислены ниже.

# xUnit

xUnit, по-видимому, является выбором команды .NET MAUI. Одна основная причина
поскольку это, вероятно, поддержка возможности запуска модульных тестов на основе xUnit.
на реальных устройствах, что означает, что вы можете тестировать реализации для конкретных устройств.
https://xunit.net

# НУнит

NUnit — мой старый фаворит. Я использовал его во многих проектах в
прошлое! У него есть несколько замечательных функций, таких как возможность запускать один и тот же тестовый пример.
с несколькими наборами данных, чтобы уменьшить объем тестового кода, необходимого для
писать и в конечном итоге поддерживать.
https://nunit.org

# МСТест

MSTest — это среда тестирования, созданная и поставляемая корпорацией Майкрософт. Это
не выглядит таким многофункциональным, как NUnit или xUnit, но все же отлично справляется со своей задачей.
https://learn.microsoft.com/dotnet/core/testing/unittesting-with-mstest

# Выбранная вами среда тестирования

В этой книге мы будем использовать xUnit главным образом из-за преимуществ, которые он дает.
с возможностью также запускать модульные тесты на устройствах.
Тесты в xUnit украшаются атрибутом [Факт] со значением
ожидание, что как автор тестовых методов вы назовете их в
способ, который определяет факт, который тест подтвердит.
Большинство тестовых фреймворков очень похожи и, как правило, различаются по срокам.
ключевых слов при идентификации тестов. Используйте любую среду тестирования
вам наиболее комфортно. Если у вас нет большого опыта
с любым, возможно, поэкспериментируйте с каждым, чтобы увидеть, что дает вам лучшее
опыт. В конце концов, вы будете строить и поддерживать
эти тесты, поэтому они должны приносить пользу вам и вашей команде.

# Добавление собственных модульных тестов

Есть несколько шагов, которые вам нужно выполнить, чтобы убедиться, что вы
может выполнить модульное тестирование вашего приложения .NET MAUI. Добавим тестовый проект в
решение, а затем внесите необходимые изменения.

# Добавление проекта модульного тестирования в ваше решение

1. Щелкните меню «Файл».
2. Нажмите Добавить.
3. Щелкните Новый проект.
4. Введите Тест в поле Поиск шаблонов.
На рис. 12-1 показано диалоговое окно «Добавить новый проект».
Визуальная студия.

![изображение](https://user-images.githubusercontent.com/26972859/231493948-80015487-83e8-4bea-bbd9-735952115fd2.png)
Рисунок 12-1. Добавить диалоговое окно нового проекта в Visual Studio

5. Выберите тестовый проект xUnit.
6. Щелкните Далее.
7. Введите имя проекта. я выбрал
WidgetBoard.Tests и найдите добавление .Tests или
.UnitTests предоставляет общий способ отличить
между приложением и тестовыми проектами. Это тоже
общее соглашение об именах, которое упрощает
поиск всех проектов модульных тестов при запуске
в конвейере CI. Я расскажу об этом более подробно в
Глава 14.
8. Щелкните Далее.
9. Выберите фреймворк. Значение по умолчанию должно подойти;
просто убедитесь, что он соответствует целевой версии
Проект приложения .NET MAUI.
10. Щелкните Создать.

# Измените проект вашего приложения на целевой net7.0

К сожалению, текущий шаблон проекта .NET MAUI не включает
целевая платформа net7.0, что означает, что она изначально несовместима с
стандартный модульный тестовый проект. Чтобы исправить это, вы можете вручную
добавьте целевую структуру net7.0. Откройте WidgetBoard/WidgetBoard.
csproj в Visual Studio Code или вашем любимом текстовом редакторе и сделайте
следующие изменения.
Измените первый элемент TargetFrameworks, включив в него net7.0; изменения
выделены жирным шрифтом:

```xml
<TargetFrameworks>net7.0;net7.0-android;net7.0-ios;net7.0-maccatalyst</TargetFrameworks>
```
Добавьте атрибут Condition к элементу OutputType; изменения
жирным шрифтом:

```xml
<OutputType Condition="'$(TargetFramework)' != 'net7.0'">Exe
</OutputType>
```
Без этого второго изменения вы увидите сообщение об ошибке компиляции
эта ошибка CS5001: программа не содержит статического основного метода
подходит для точки входа. Это связано с тем, что вы строите
приложение и приложения .NET ожидают наличия статического метода Main
в качестве точки входа в приложение. OutputType для .NET MAUI
приложения должны быть в формате Exe, что может показаться немного запутанным, поскольку вы редко
в итоге получите исполняемый файл, который будет доставлен.

---
Если вы используете более новую версию .NET MAUI, вы можете
замените net7.0 версией, которую вы используете, например, net8.0.
---

# Добавление ссылки на проект для тестирования

Теперь вам нужно добавить ссылку из вашего тестового проекта на основной
прикладной проект.
1. Щелкните правой кнопкой мыши WidgetBoard.Tests.
2. Нажмите Добавить.
3. Щелкните Справочник по проекту.
4. Выберите WidgetBoard из списка. Рисунок 12-2 показывает
диалоговое окно «Диспетчер ссылок» в Visual Studio.

![изображение](https://user-images.githubusercontent.com/26972859/231494592-12c69608-6b15-4e68-a8f0-3c484d8b5179.png)
Рисунок 12-2. Диспетчер ссылок в Visual Studio

5. Нажмите ОК.

# Измените свой тестовый проект, чтобы использовать зависимости MAUI

Последний шаг — заставить ваш тестовый проект использовать .NET MAUI.
зависимости так же, как основной проект приложения. Откройте
Файл WidgetBoard.Tests/WidgetBoard.Tests.csproj в Visual Studio
Код или ваш любимый текстовый редактор и внесите следующие изменения
Добавьте <UseMaui>true</UseMaui> в группу свойств верхнего уровня.
элемент, который теперь должен выглядеть так; изменения выделены жирным шрифтом:

```xml
<Группа свойств>
 <TargetFramework>net7.0</TargetFramework>
 <ImplicitUsings>включить</ImplicitUsings>
 <Nullable>включить</Nullable>
 <UseMaui>true</UseMaui>
  <IsPackable>false</IsPackable>
</PropertyGroup>
```
Теперь вы настроили все, чтобы приступить к написанию и запуску.
ваши модульные тесты.

# Тестирование ваших моделей представления

Архитектура MVVM очень хорошо подходит для модульного тестирования каждого
индивидуальный компонент.
Во-первых, вам нужно создать папку ViewModels в вашем
Проект WidgetBoard.Tests, а затем добавьте новый файл класса с именем
BoardDetailsPageViewModelTests.cs. Хорошей практикой является хранение папок
и тесты, названные аналогично коду, который они тестируют, чтобы упростить его
организовать и разместить.
Теперь вы можете добавить свой первый набор тестов.

# Тестирование BoardDetailsPageViewModel

Внутри только что созданного файла класса добавьте следующее:

```Csharp
[Факт]
public void SaveCommandCannotExecuteWithoutBoardName()
{
 var viewModel = новая модель BoardDetailsPageViewModel (null, null);
 Assert.Null(viewModel.BoardName);
 Assert.False(viewModel.SaveCommand.CanExecute(null));
}
[Факт]
public void SaveCommandCanExecuteWithBoardName()
{
 var viewModel = новая модель BoardDetailsPageViewModel (null, null);
 viewModel.BoardName = "Работа";
 Assert.True(viewModel.SaveCommand.CanExecute(null));
}
```

# Тестирование INotifyPropertyChanged

В главе 4 я рассказал, что INotifyPropertyChanged служит
механизм для синхронизации ваших представлений и моделей представлений; следовательно, он может
быть действительно полезным, чтобы убедиться, что ваши модели представления правильно реализуются
INotifyPropertyChanged, гарантируя, что он вызывает свойство PropertyChanged.
событие, когда оно должно.
Следующий тест показывает, как создать экземпляр
BoardDetailsPageViewModel, подпишитесь на событие PropertyChanged,
изменить свойство, которое, как вы ожидаете, вызовет событие PropertyChanged, и
затем подтвердите, что событие было вызвано:

```Csharp
[Факт]
public void SettingBoardNameShouldRaisePropertyChanged()
{
 вар вызывается = ложь;
 var viewModel = новая модель BoardDetailsPageViewModel (null, null);
 viewModel.PropertyChanged += (отправитель, e) =>
 {
 if (e.PropertyName.Equals(nameof(BoardDetailsPageView
Модель.Название Платы)))
 {
 вызван = истина;
 }
 };
 viewModel.BoardName = "Работа";
 Assert.True (вызвано);
}
```
Это дает вам уверенность в том, что если BoardName
не отображается в вашем пользовательском интерфейсе, это, вероятно, не будет проблемой внутри
модель представления.

# Тестирование асинхронных операций

Многие современные приложения включают определенный уровень асинхронной работы.
и прекрасным примером является использование вами Open Weather API для загрузки
погода в текущем местоположении. WeatherWidgetViewModel опирается на
реализация созданного вами интерфейса IWeatherForecastService
в главе 10. Модульные тесты для конкретных реализаций, подобных этой, могут
считать шелушащимся. Ненадежный тест — это тест, дающий противоречивые результаты.
Доступ к веб-службе может демонстрировать такое поведение при модульном тестировании.
учитывая ограничения доступа к API или другие потенциальные проблемы, которые могут повлиять на
надежный тестовый запуск.
Для того, чтобы убрать хлипкость теста, можно создать mock
реализация, которая обеспечит набор согласованного поведения

# Создание макета ILocationService

Создайте новую папку в своем проекте WidgetBoard.Tests и назовите ее Mocks. я
рассматривал это раньше, но организация кода таким образом действительно может сделать
его гораздо легче поддерживать. С этой новой папкой вы можете создать новый класс
файл внутри и назовите его MockLocationService.cs. Измените содержимое на
следующий:

```Csharp
с помощью WidgetBoard.Services;
пространство имен WidgetBoard.Tests.Mocks;
внутренний класс MockLocationService: ILocationService
{
 частное только для чтения Местоположение? расположение;
 частная задержка TimeSpan только для чтения;
 частный MockLocationService (местоположение? mockLocation,
Задержка TimeSpan)
 {
 местоположение = фиктивное местоположение;
 this.delay = задержка;
 }
 внутренний статический ILocationService ThatReturns(Location?
местоположение, TimeSpan после) =>
 новый MockLocationService (местоположение, после);
 внутренний статический ILocationService
ThatReturnsNoLocation(TimeSpan после) =>
 новый MockLocationService (нулевой, после);
 общедоступная асинхронная задача<Location?> GetLocationAsync()
 {
 ожидайте Task.Delay(this.delay);
 вернуть это.местоположение;
 }
}
```
Реализация, которую вы предоставили для GetLocationAsync
метод вызывает задержку на основе предоставленного параметра TimeSpan в
конструктор для имитации сетевой задержки, а затем возвращает местоположение
предоставляется в конструкторе.

Одна ключевая деталь, которую мне очень нравится использовать при создании макетов, — это
их использование в моих тестах настолько легко читается, насколько это возможно. Вы можете видеть, что
MockLocationService не может быть создан, поскольку он имеет частный
конструктор. Это означает, что для его использования вы должны использовать ThatReturns или
Методы ThatReturnsNoLocation. Посмотри на это и увидишь, сколько еще
читаемо это:

```Csharp
MockLocationService.ThatReturns (новое местоположение (0,0, 0,0), после:
TimeSpan.FromSeconds(2));
```
Приведенное выше гораздо читабельнее, чем следующее, потому что оно
включает намерение:

```Csharp
новый MockLocationService (новое местоположение (0,0, 0,0), TimeSpan.FromSeconds (2));
```

# Создание макета WeatherForecastService

Вы можете добавить второй файл в папку Mocks и вызвать этот файл класса
MockWeatherForecastService.cs. Измените содержимое на следующее:

```Csharp
с помощью WidgetBoard.Communications;
пространство имен WidgetBoard.Tests.Mocks;
внутренний класс MockWeatherForecastService:
IWeatherForecastService
{
 частный прогноз только для чтения? прогноз;
 частная задержка TimeSpan только для чтения;
 частный MockWeatherForecastService (прогноз? прогноз,
Задержка TimeSpan)
 {
 this.forecast = прогноз;
 this.delay = задержка;
 }
 внутренний статический IWeatherForecastService
ThatReturns(Прогноз? прогноз, TimeSpan после) =>
 новый MockWeatherForecastService (прогноз, после);
 внутренний статический IWeatherForecastService
ThatReturnsNoForecast (TimeSpan после) =>
 новый MockWeatherForecastService (ноль, после);
 public async Task<Forecast?> GetForecast(двойная широта,
двойная долгота)
 {
 ожидайте Task.Delay(this.delay);
 прогноз возврата;
 }
}
```
Реализация, предоставленная вами для метода GetForecast, заставляет
задержка на основе предоставленного параметра TimeSpan в конструкторе
чтобы имитировать задержку в сети, а затем вернуть прогноз, предоставленный в
конструктор.

# Создание асинхронных тестов

Имея макеты на месте, вы можете написать тесты, которые будут проверять
поведение вашего приложения при вызове асинхронного и потенциально
длительные операции. Вам нужно добавить новый файл класса в ваш
Папка ViewModels в проекте WidgetBoard.Tests и вызов
WeatherWidgetViewModelTests.cs, а затем измените содержимое на
следующий:

```Csharp
используя WidgetBoard.Tests.Mocks;
используя WidgetBoard.ViewModels;
пространство имен WidgetBoard.Tests.ViewModels;
открытый класс WeatherWidgetViewModelTests
{
}
```

Теперь вы можете приступить к добавлению трех тестов, чтобы охватить различные
разные сценарии.

```Csharp
[Факт]
общедоступная асинхронная задача NullLocationResultsInPermissionErrorState()
{
 var viewModel = новая модель WeatherWidgetViewModel(
 MockWeatherForecastService.ThatReturnsNoForecast (после:
TimeSpan.FromSeconds(5)),
 MockLocationService.ThatReturnsNoLocation (после:
TimeSpan.FromSeconds(2)));
 ожидайте viewModel.InitializeAsync();
 Assert.Equal(State.PermissionError, viewModel.State);
 Assert.Null(viewModel.Weather);
}
```
Этот первый тест, как следует из названия, проверяет, что если нулевое местоположение
возвращаемая из реализации ILocationService, модель представления
Состояние будет установлено на PermissionError, и погода не будет установлена.

```Csharp
[Факт]
общедоступная асинхронная задача NullForecastResultsInErrorState()
{
 var viewModel = новая модель WeatherWidgetViewModel(
 MockWeatherForecastService.ThatReturnsNoForecast (после:
TimeSpan.FromSeconds(5)),
MockLocationService.ThatReturns (новое местоположение (0,0, 0,0),
после: TimeSpan.FromSeconds(2)));
 ожидайте viewModel.InitializeAsync();
 Assert.Equal(State.Error, viewModel.State);
 Assert.Null(viewModel.Weather);
}
```
Этот второй тест, как следует из названия, проверяет, что если нулевой прогноз
возвращаемый из реализации IWeatherForecastService, представление
Состояние модели будет установлено на Ошибка, и погода не будет установлена.

```Csharp
[Факт]
общедоступная асинхронная задача ValidForecastResultsInSuccessfulLoad()
{
 var WeatherForecastService =
 MockWeatherForecastService.ThatReturns(
 новые Коммуникации.Прогноз
 {
 Текущий = новый Communications.Current
 {
 Температура = 18,0,
 Погода = новые сообщения. Погода []
 {
 новые сообщения.Погода
 {
 Значок = "abc.png",
Главное = "Солнечный свет"
 }
 }
 }
 },
 после: TimeSpan.FromSeconds(5));
 var locationService = MockLocationService.ThatReturns(
 новое местоположение (0,0, 0,0),
 после: TimeSpan.FromSeconds(2));
 var viewModel = новая модель WeatherWidgetViewModel(
 погодаПрогнозСервис,
 Служба определения местоположения);
 ожидайте viewModel.InitializeAsync();
 Assert.Equal(State.Loaded, viewModel.State);
 Assert.Equal("Солнечный свет", viewModel.Weather);
}
```
Этот последний тест, как следует из названия, проверяет,
возвращаемый из реализации IWeatherForecastService, представление
Состояние модели будет установлено на «Загружено», а погода будет установлена ​​правильно.

# Проверка ваших представлений

Можно написать модульные тесты, которые будут проверять поведение ваших представлений.

# Создание макета ClockWidgetViewModel

Чтобы проверить ваш ClockWidgetView, вам нужно предоставить ему представление
модель. Ваша ClockWidgetViewModel в настоящее время имеет некоторые сложности.
это затруднит его использование в тесте. Он отображает текущую дату/время.
Давайте создадим макет, чтобы устранить эту потенциальную трудность. Внутри ваших моков
папку, добавьте новый файл класса с именем MockClockWidgetViewModel.cs и
изменить содержимое, чтобы оно соответствовало следующему:

```Csharp
используя WidgetBoard.ViewModels;
пространство имен WidgetBoard.Tests.Mocks;
открытый класс MockClockWidgetViewModel: IWidgetViewModel
{
 публичная позиция {получить; набор; }
 общедоступная строка Тип => "Мока";
 публичный MockClockWidgetViewModel (время DateTime)
 {
 Время = время;
 }
 публичное время DateTime {получить; }
 public Task InitializeAsync() => Task.CompletedTask;
}
```
Теперь вы можете использовать это в своих модульных тестах, чтобы убедиться, что ваш
ClockWidgetView правильно привязывается к своей модели представления.

# Создание тестов представления

Сначала создайте папку Views в своем проекте WidgetBoard.Tests, а затем добавьте
новый файл класса с именем ClockWidgetView.cs.

```Csharp
используя WidgetBoard.Tests.Mocks;
с помощью WidgetBoard.Views;
пространство имен WidgetBoard.Tests.Views;
открытый класс ClockWidgetViewTests
{
 [Факт]
 общественное недействительное TextIsUpdatedByTimeProperty ()
 {
 var time = новый DateTime (2022, 01, 01);
 var clockWidget = новый ClockWidgetView();
 Assert.Null (часыWidget.Text);
 clockWidget.WidgetViewModel = новый MockClockWidgetView
Модель(время);
 Assert.Equal(time.ToString(), clockWidget.Text);
 }
}
```
Тест TextIsUpdatedByTimeProperty создает новый
ClockWidgetView назначает новую модель MockClockWidgetViewModel и
затем проверяет правильность обновления свойства Text виджета
чтобы отразить значение свойства Time в вашей модели представления через его
привязка.

# Тестирование устройств

Тестирование устройств на самом деле является формой модульного тестирования; тем не менее, он обеспечивает некоторые
уникальные способности, поэтому он заслуживает отдельного раздела верхнего уровня. Это по существу
позволяет вам писать модульные тесты, которые можно запускать на устройстве и, следовательно,
по-настоящему тестировать любые функциональные возможности платформы. Прекрасный пример
из этого, чтобы протестировать PlatformLocationService, который вы реализовали в
предыдущую главу, чтобы вернуть координаты долготы и широты каждого
штаб-квартира поставщика платформы.

# Создание проекта тестирования устройства

Вам нужно создать другой проект, чтобы справиться с запуском
тесты устройства. Документация в репозитории GitHub охватывает все это.
необходим, поэтому перейдите на https://github.com/shinyorg/xunit-maui. Регистрироваться
репозиторий кода под названием WidgetBoard.DeviceTests, если вы застряли; там
это уже созданный проект для использования в качестве шаблона.

# Добавление теста для конкретного устройства

```Csharp
с помощью WidgetBoard.Services;
с помощью Xunit;
пространство имен WidgetBoard.DeviceTests.Services;
открытый класс PlatformLocationServiceTests
{
 [Факт]
 общедоступная асинхронная задача GetLocationAsyncWillReturnPlatform
Конкретное место()
 {
 var locationService = new PlatformLocationService();
 var location = ожидание locationService.
GetLocationAsync();
#если АНДРОИД
Assert.Equal(37.419857, location.Latitude);
Assert.Equal(-122.078827, location.Longitude);
#элиф ОКНА
Assert.Equal(47.639722, location.Latitude);
Assert.Equal(-122.128333, location.Longitude);
#еще
Assert.Equal(37.334722, location.Latitude);
Assert.Equal(-122.008889, location.Longitude);
#endif
 }
}
```
Теперь, когда вы написали свои тесты, вы можете запустить их на своем
устройства.

# Запуск тестов для конкретных устройств

Чтобы запустить тесты на устройстве, вам сначала нужно установить
Проект WidgetBoard.DeviceTests в качестве запускаемого проекта. Вы можете сделать это как
следует:
• Щелкните правой кнопкой мыши проект WidgetBoard.DeviceTests в
Обозреватель решений.
• Выберите Установить в качестве запускаемого проекта.
Теперь запустите приложение из Visual Studio. Рисунок 12-3 показывает
экран запуска теста устройства, работающий в Windows.

![изображение](https://user-images.githubusercontent.com/26972859/231498799-d25896cb-cb5c-4b3e-8022-059e0a5ef0fd.png)
Рисунок 12-3. Средство запуска тестов устройств на платформе Windows

Вы можете щелкнуть конкретный тест и выбрать его запуск, или вы можете просто
Выполнить все тесты. Эта часть полностью выполняется вручную, поэтому потребуется, чтобы человек
выполнять эти задачи, но его можно оставить работать столько времени, сколько потребуется тестам.
Наконец, вы увидите результаты тестовых прогонов, и вы можете нажать на них.
чтобы увидеть больше информации. На рис. 12-4 показаны средство запуска тестов устройства и
набор результатов испытаний.

![изображение](https://user-images.githubusercontent.com/26972859/231498917-7edeb287-4761-4f24-a496-808f885be965.png)
Рисунок 12-4. Результат тестового запуска для GetLocationAsyncWillReturn
Тест устройства PlatformSpecificLocation

Вы можете запустить эти тесты на всех платформах, которые вы поддерживаете, чтобы сделать
уверен, что код делает то, что ожидается.

# Тестирование снимков

Тестирование моментальных снимков похоже на модульное тестирование, но позволяет избежать необходимости писать
Операторы Assert для ручного определения каждого ожидания в тесте. Вместо
результат теста сравнивается с золотым мастером. Золотой мастер – это
моментальный снимок предыдущего запуска теста, который вы, как автор теста, принимаете в качестве
ожидаемый результат для последующих тестовых прогонов. Снимок может быть любым
от снимка экрана приложения до сериализации объекта
в памяти. Если вы посмотрите на WeatherWidgetViewModel, вы
проверено в предыдущем разделе, вы можете видеть, что сериализация состояния
теста ValidForecastResultsInSuccessfulLoad приведет к
создается следующий золотой мастер:

```Csharp
{
 LoadWeatherCommand: {},
 IconUrl: https://openweathermap.org/img/wn/abc.png@2x.png,
 Состояние: загружено,
 Температура: 18,0,
 Погода: Солнечная,
 Тип: Погода
}
```
Когда этот тест запускается, каждый раз, когда сериализованный вывод
WeatherWidgetViewModel будет сравниваться с указанным выше золотым мастером.
Если какие-либо значения отличаются от значений в золотом мастере, тест
не удастся.

# Моментальный снимок тестирования вашего приложения

Для моментального тестирования вашего приложения вы будете использовать
отличная библиотека под названием VerifyTests. В VerifyTests есть действительно отличные
документацию и примеры, которые помогут вам начать все сначала, на https://github.
com/VerifyTests/Verify.
Вам также потребуется использовать Verify.Xunit NuGet.
упаковка. Я решил создать отдельный проект, чтобы сохранить вещи
четко разделены для целей этого примера. Вы можете повторить шаги
в разделах «Добавление проекта модульного тестирования в ваше решение» и «Добавление
Ссылка на проект для тестирования», за исключением того, что вы назовете проект
WidgetBoard.SnapshotTests.
Используя VerifyTests, вы можете сделать копию своего
Класс WeatherWidgetViewModelTests в проекте WidgetBoard.Tests
и измените его на следующее. Ограниченные изменения выделены жирным шрифтом.
выделить отличия от оригинала.

```Csharp
[Используетпроверку]
открытый класс WeatherWidgetViewModelTests
{
 [Факт]
 общедоступная асинхронная задача
NullLocationResultsInPermissionErrorState()
 {
 var viewModel = новая модель WeatherWidgetViewModel(
 новый MockWeatherForecastService (нулевой),
 новый MockLocationService(null));
 ожидайте viewModel.InitializeAsync();
 ожидание проверки (модель представления);
 }
 [Факт]
 общедоступная асинхронная задача NullForecastResultsInErrorState()
 {
 var viewModel = новая модель WeatherWidgetViewModel(
 новый MockWeatherForecastService (нулевой),
 новый MockLocationService (новое местоположение (0,0, 0,0)));
 ожидайте viewModel.InitializeAsync();
 ожидание проверки (модель представления);
 }
 [Факт]
 общедоступная асинхронная задача ValidForecastResultsInSuccessfulLoad()
 {
 var viewModel = новая модель WeatherWidgetViewModel(
 новый MockWeatherForecastService (новые сообщения.
Прогноз
{
 Текущий = новый Communications.Current
 {
 Температура = 18,0,
 Погода = новые сообщения. Погода []
 {
 новые сообщения.Погода
 {
 Значок = "abc.png",
Главное = "Солнечный свет"
 }
 }
 }
 }),
 новый MockLocationService (новое местоположение (0,0, 0,0)));
 ожидайте viewModel.InitializeAsync();
 ожидание проверки (модель представления);
 }
}
```
Вы удаляете операторы Assert и заменяете их вызовом
Метод проверки. В вашем исходном сценарии вы только утверждали небольшую
количество вещей, но вы можете себе представить, что если количество Assert
операторы должны были расти, то этот единственный вызов метода Verify действительно
уменьшить сложность ваших тестов.
Совершенно новые испытания всегда будут провалены, пока вы не примете золотого мастера.
Существует инструмент, который может упростить эту задачу, который снова предоставляется
разработчики VerifyTests.

# Проходящие мысли

Я заканчиваю этот раздел тестирования моментальных снимков заявлением, что он не предназначен для
каждый. Некоторым людям действительно нравится уменьшение размера тестового примера, в то время как
он проверяет больше, чем большинство типичных модульных тестов, просто потому, что он
проверяет весь тестируемый объект. В качестве контраргумента некоторые люди
не нравится, что ожидаемое состояние или золотой мастер находятся в файле, отдельном от
тесты. Я лично считаю, что они представляют большую ценность, и я надеюсь, что это
введение в тестирование моментальных снимков даст вам достаточно контекста, чтобы решить
подойдет ли он вам и вашей команде или, по крайней мере, даст
вы желание поэкспериментировать с концепцией.

# Взгляд в будущее

Мне очень хотелось, чтобы в этой главе было рассказано, как писать и создавать тесты, которые
может протестировать ваш пользовательский интерфейс с помощью тестов автоматизации. К сожалению, это еще не совсем готово. Это
конечно то что просматривается, но ничего конкретного нет
или готовы.
Если у вас есть опыт работы с Xamarin.Forms, вы можете
хорошо знать о Xamarin.UITesting. Это оказалось немного сложно
работать, и это было непоследовательно время от времени, но это действительно обеспечило
основы для написания тестов автоматизации для приложения Xamarin.Forms.
В настоящее время команда .NET MAUI оценивает несколько вариантов включения
вам протестировать ваши приложения.
В настоящее время есть возможность тестирования с помощью Appium
(https://appium.io); однако иногда он может быть неуклюжим и ненадежным.
Меня больше всего вдохновляет работа, которую Джонатан Дик (разработчик .NET MAUI
лид) занимается с Maui.UITesting. Это очень в зачаточном состоянии в
время написания, но я ожидаю, что из этого выйдет что-то хорошее. Вам следует
ознакомьтесь с подробностями в репозитории GitHub по адресу https://github.
com/Redth/Maui.UITesting.

# Краткое содержание

Теперь у вас есть обзор различных методов тестирования и их преимуществ.
они приносят. Вы можете предпочесть моментальный снимок написанию собственных утверждений. Я не
в любом случае, пока вы тестируете свой код.

В этой главе вы

• Узнали, что такое тестирование и почему оно важно

• Изучили модульное тестирование и то, как его можно применить к
Приложение .NET MAUI

• Узнали о тестировании моментальных снимков и о том, как вы можете
реализовать это

• Изучили, что такое тесты устройств и как их можно применять.
их в ваши приложения

• Заглядывали в будущее, чтобы еще больше испытать доброту
В следующей главе вы будете

• Узнайте, что такое .NET MAUI Graphics.

• Получите представление о некоторых возможностях, предоставляемых
Графика .NET MAUI

• Создайте свой собственный виджет эскиза с помощью .NET MAUI.
Элемент управления GraphicsView

# Исходный код

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introduction-MAUI/tree/
основной/ch12.


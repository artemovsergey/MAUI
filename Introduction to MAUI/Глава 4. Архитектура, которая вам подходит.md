# ГЛАВА 4

# Архитектура, которая вам подходит

В этой главе вы познакомитесь с некоторыми возможными архитектурными шаблонами.
которые можно использовать для создания приложений .NET MAUI. Цель состоит в том, чтобы
предоставить вам достаточно подробностей, чтобы помочь вам найти архитектуру, которая лучше всего
подходит тебе. Я хочу отметить, что нет правильных ответов относительно
какую архитектуру выбрать. Лучший вариант - пойти с тем, что вы
чувствую, что это принесет пользу вам и вашей команде.
Я стремлюсь разрушить следующие мифы в ходе этого
глава:
«Вы вынуждены использовать XAML».
«Вы вынуждены использовать MVVM».
Кажется, существует распространенное заблуждение, что Xamarin.Forms и
.NET MAUI в основном построен на использовании только XAML и MVVM. Пока
это наиболее распространенный подход разработчиков, он не навязывается
на нас.

## Мерная линейка

Вы создадите один и тот же элемент управления с каждым из вариантов, чтобы обеспечить способ
сравните отличия. Элемент управления, который вы будете создавать, представляет собой ClockWidget.
Целью этого контроля является выполнение следующих действий:

- Отображение текущего времени в вашем приложении.
- Обновление времени каждую минуту.

На рис. 4-1 показана очень грубая схема управления с током.
Дата и время. Вы уберете это позже с возможностью форматирования даты
и информацию о времени в Главе 5, но сейчас давайте просто сосредоточимся на ограниченном
например, чтобы выделить различия в параметрах. Рисунок 4-1 показывает, как
ClockWidget будет отображаться в вашем приложении, когда вы закончите с
эта глава.

![изображение](https://user-images.githubusercontent.com/26972859/231101118-c96f6a35-9a87-4899-9c95-3c9ec04a662c.png)
Рисунок 4-1. Схема того, как будет отображаться элемент управления ClockWidget

## Предпосылки

Прежде чем приступить к работе с каждой из архитектур, которые вы будете рассматривать
в этой главе вам нужно немного подготовиться к фоновой настройке.
Вам нужно добавить один новый класс. Эта реализация позволит
ваши виджеты, чтобы запланировать действие работы, которое будет выполнено после определенного
период времени. В вашем сценарии ClockWidget вы можете запланировать
обновление пользовательского интерфейса. Давайте добавим этот класс планировщика в ваш проект.

- Щелкните правой кнопкой мыши проект WidgetBoard.
- Выберите «Добавить» ➤ «Класс».
- Дайте ему имя Scheduler.
- Нажмите Добавить.

Вы хотите изменить содержимое файла, чтобы оно выглядело следующим образом:

```Csharp
использование System.Threading.Tasks;
Планировщик общедоступных классов
{
 public void ScheduleAction (TimeSpan timeSpan,
Действие действие)
 {
 Task.Run(асинхронный () =>
 {
 ожидайте Task.Delay(timeSpan);
 действие.Вызвать();
 });
 }
}
```

В следующих разделах вы будете рассматривать примеры кода, а не
чем реализовать их напрямую. Это направлено на обеспечение некоторых
сравнений, чтобы вы могли узнать, что будет хорошо подходить для вас, поскольку вы
создавайте свои приложения и развивайтесь как кроссплатформенный разработчик. В конце
главы, вы возьмете выбранный вами подход и добавите его в свой
приложение, чтобы вы могли видеть окончательный результат вашего ClockWidget.

# Представление модели ViewModel (MVVM)

Model View ViewModel — это шаблон проектирования программного обеспечения, ориентированный на
отделение пользовательского интерфейса (представления) от бизнес-логики (модели). Это
достигается это с использованием промежуточного слоя (ViewModel). МВВМ
позволяет четко разделить представление и бизнес-логику. Рисунок 4-2
показывает четкое разделение между компонентами MVVM
архитектура.

![изображение](https://user-images.githubusercontent.com/26972859/231101565-52e3465a-79fc-4f29-ae59-6c08bccd94fb.png)
Рисунок 4-2. Обзор шаблона MVVM

Результат создания этого разделения между пользовательским интерфейсом и бизнес-логикой
приносит ряд преимуществ:

- Облегчает модульное тестирование
- Позволяет заменять представления или даже перезаписывать их.
не затрагивая другие части
- Поощряет повторное использование кода
- Предоставляет возможность отделить разработку пользовательского интерфейса от
разработка бизнес-логики

Ключевой частью любого шаблона проектирования является знание того, где найти части
ваш код, чтобы он подходил и соблюдал правила. Давайте более подробно рассмотрим
каждой из трех ключевых частей этого шаблона.

# Модель

Модель — это место, где вы храните свою бизнес-логику. Обычно он загружается
из базы данных/веб-сервиса среди многих других вещей.
Для вашей бизнес-логики вы будете полагаться на класс Scheduler.
который вы создали ранее в разделе «Предварительные требования» этой главы.

# Вид

Представление определяет макет и внешний вид приложения. Это то, что
пользователь будет видеть и взаимодействовать. В .NET MAUI представление обычно
написаны на XAML, где это возможно, но будут случаи, когда логика
в code-behind нужно будет написать. Вы узнаете об этом позже в этом
глава; вам вообще не нужно использовать XAML, поэтому, если вы не чувствуете, что XAML
прямо для вас, не бойтесь.
Представление в .NET MAUI обычно представляет собой ContentPage или реализацию.
который будет наследоваться от ContentPage или ContentView. Вы используете ContentPage, если
вы хотите отобразить полную страницу в своем приложении (в основном представление, которое заполнит
приложение). Вы используете ContentView для чего-то меньшего (например, для виджета!).
Для вашей реализации вы будете наследоваться от ContentView.
В главе 2 я говорил, что большинство XAML-файлов имеют
связанный файл C#. Представление на основе XAML не является исключением из этого правила. С этим
Имея в виду, давайте посмотрим на содержимое, которое вам нужно поместить в каждый из файлов.

# XAML

```xml
<?xml версия="1.0" кодировка="utf-8" ?>
<ContentView xmlns="http://schemas.microsoft.com/
точка/2021/мауи"
 xmlns:x="http://schemas.microsoft.com/
winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.
ViewModels"
 x:Class="WidgetBoard.ClockWidget">
 <ContentView.BindingContext>
 <viewmodels: ClockWidgetViewModel />
 </ContentView.BindingContext>
 <Label Text="{Время привязки}"
Размер шрифта = "80"
 Вертикальные опции = "Центр"
 HorizontalOptions="По центру" />
</ContentView>
```

## C# (код программной части)

Следующий код уже создан для вас .NET.
Шаблон Мауи. Он включен для справки.

```Csharp
пространство имен WidgetBoard;
общедоступный частичный класс ClockWidget : ContentView
{
 публичный ClockWidget ()
 {
 ИнициализироватьКомпонент();
 }
}
```
Приведенный выше вызов метода InitializeComponent необходим, когда
создание представлений на основе XAML. Это приводит к загрузке XAML и
анализируется в экземпляр элементов управления, которые были определены в
XAML-файл.

#ВьюМодель

ViewModel действует как мост между представлением и моделью. Ты
раскрывать свойства и команды в ViewModel, которые View будет
связываются с. Для сравнения с созданием приложений только с программным обеспечением мы могли бы сказать, что свойства в основном сопоставляются со ссылками на
элементы управления и команды являются событиями. Связывание обеспечивает механизм для
как View, так и ViewModel для отправки и получения обновлений.

Чтобы ваша ViewModel уведомляла View об изменении свойства
и поэтому представление обновит значение, отображаемое на экране, вы
необходимо использовать интерфейс INotifyPropertyChanged. Это предлагает
одно событие PropertyChanged, которое вы должны реализовать и в конечном итоге
поднять, когда значение, связанное с данными, изменилось. Всем этим занимается
Механизм привязки XAML, который вы более подробно рассмотрите в
Следующая глава. Давайте создадим ваш класс ViewModel, а затем разберем, что
продолжается.

```Csharp
открытый класс ClockWidgetViewModel: INotifyPropertyChanged
{
 открытое событие PropertyChangedEventHandler PropertyChanged;
 частный планировщик только для чтения scheduler = new();
 личное время DateTime;
 публичное время DateTime
 {
 получать
 {
 время возврата;
 }
 набор
 {
 если (время != значение)
 {
 время = стоимость;
 PropertyChanged?.Invoke(это, новый PropertyChange
edEventArgs(имя(Время)));
 }
 }
 
 }
 публичный ClockWigetViewModel()
 {
 УстановитьВремя(ДатаВремя.Сейчас);
 }
 public void SetTime (DateTime dateTime)
 {
 Время = ДатаВремя;
 планировщик.ScheduleAction(
 TimeSpan.FromSeconds(1),
 () => УстановитьВремя(ДатаВремя.Сейчас));
 }
}
```

У вас есть
• Создан класс ClockWidgetViewModel.
• Реализован интерфейс INotifyPropertyChanged.
• Добавлено свойство, которое при установке будет проверять,
его значение действительно изменилось, и если да, поднимите
Событие PropertyChanged с именем свойства
что изменилось
• Добавлен метод установки свойства Time и повтора.
каждую секунду, чтобы виджет выглядел как часы
считая

# Обновление представления модели (MVU)

Model View Update — это шаблон проектирования программного обеспечения для создания интерактивных
Приложения. Концепция исходит из языка программирования Elm.
Как следует из названия, MVU состоит из трех ключевых частей:
• Модель: это состояние вашего приложения.
• Просмотр: это визуальное представление вашего состояния.
• Обновление: это механизм обновления вашего состояния.
На рис. 4-3 показано, как каждый из этих компонентов соотносится и взаимодействует.
друг с другом.  

![изображение](https://user-images.githubusercontent.com/26972859/231108112-c6062936-3975-4593-919e-f7a61de4c338.png)
Рисунок 4-3. Обзор шаблона MVU

Этот шаблон предлагает несколько преимуществ:
• Четко определенные правила относительно того, где государству разрешено
быть обновленным
• Простота тестирования
Ключевой частью любого шаблона проектирования является знание того, где найти части
ваш код, чтобы он подходил и соблюдал правила. Давайте более подробно рассмотрим
каждой из трех ключевых частей этого шаблона.

# Начало работы с кометой

Во-первых, вы должны установить шаблоны проекта Comet. Для этого откройте
окно терминала и выполните следующую команду:

```dotnet new – установите Clancey.Comet.Templates.Multiplatform```

Это установит шаблон, чтобы вы могли создать новый проект.
К сожалению, это достаточно отличается от проекта WidgetBoard, который у вас есть.
работал с до сих пор.
Далее необходимо создать проект. Это снова делается через терминал
на данный момент:

```новая комета dotnet -- имя WidgetBoard.Mvu```

Это создаст новый проект, который вы можете начать изменять.

## Добавление вашей реализации MVU

Идите вперед и откройте проект, который вы только что создали.
Первое, что вам нужно сделать, это использовать тот же планировщик
класс, который вы создали в примере модели MVVM для вашего MVU
выполнение. Вот еще раз для облегчения жизни:

```Csharp
Планировщик общедоступных классов
{
 public void ScheduleAction (TimeSpan timeSpan,
Действие действие)
 {
 Task.Run(асинхронный () =>
 {
 ожидайте Task.Delay(timeSpan);
 действие.Вызвать();
 }
 }
}
```
Наконец, продолжайте и создайте свой класс ClockWidget:

```Csharp
открытый класс ClockWidget: вид
{
 [Состояние]
 часы только для чтения часы = новые();
 [Тело]
 Просмотр тела()
 => новый текст (() => $"{clock.Time}")
 .Размер шрифта (80)
 .HorizontalLayoutAlignment(LayoutAlignment.Center)
 .VerticalLayoutAlignment(LayoutAlignment.Center);
 часы открытого класса: BindingObject
 {
 Планировщик только для чтения scheduler = new();
 публичное время DateTime
 {
 получить => GetProperty<DateTime>();
 установить => SetProperty (значение);
 }
 общественные часы ()
 {
 УстановитьВремя(ДатаВремя.Сейчас);
 }
 недействительным SetTime (DateTime dateTime)
 {
 Время = ДатаВремя;
 планировщик.ScheduleAction(
 TimeSpan.FromSeconds(1),
 () =>
 {
 УстановитьВремя(ДатаВремя.Сейчас);
 });
 }
 }
}
 
```

Теперь, когда вы добавили массу кода, давайте обобщим то, что вы
сделал.
• Вы создали новый класс ClockWidget.
• Вы определили свой тип состояния как Часы.
• Вы инициализировали (известный как init в MVU
узор) ваша модель полевых часов.
• Вы определили свое представление с помощью функции body().
• Вы определили свою функцию обновления в виде
метод SetTime.
Обратите внимание, что существует два распространенных сценария вызова обновления:
когда есть взаимодействие с пользователем (например, щелчок/нажатие кнопки) и вокруг
асинхронная фоновая работа. Ваш пример здесь относится ко второму
сценарий.

# Разметка XAML и C#

XAML зарекомендовал себя как важная часть создания пользовательских интерфейсов приложений в Xamarin.
Forms, и это, вероятно, продолжится в .NET MAUI, но я хочу прояснить ситуацию.
что вам не нужно его использовать. Так что, как некоторые друзья и коллеги,
от многословия XAML тошнит, решение есть!

Все, что вы можете создать в XAML, в конечном итоге может быть создано в
С#. Кроме того, существуют способы улучшить читабельность кода C#.
требуется для создания интерфейсов.
Некоторые преимущества создания пользовательских интерфейсов исключительно с помощью C#:
• Один файл для просмотра. Нет сопряжения .xaml.cs и
.xaml-файлы.
• Улучшенные параметры рефакторинга: переименование свойств или
команды в XAML не будут обновлять C#.
Давайте рассмотрим, как вы можете создать свой ClockWidget на C# во всех его проявлениях.
многословие, а затем я покажу, как можно упростить его с помощью разметки C#. (Я
должен добавить, что это пакет с открытым исходным кодом, который вам нужно принести). Также,
эти примеры по-прежнему создаются с использованием MVVM.

# Обычный С#

Как уже упоминалось, все, что вы можете построить на XAML, можно также построить на C#.
В следующем коде показано, как точно такое же определение XAML вашего
ClockWidget можно построить, используя только C#:

```Csharp
используя WidgetBoard.ViewModels;
пространство имен WidgetBoard.Views;
открытый класс ClockWidget : ContentView
{
 публичный ClockWidget ()
 {
 BindingContext = new ClockWidgetViewModel();
 переменная метка = новая метка
 {
 Размер шрифта = 80,
 HorizontalOptions = LayoutOptions.Center,
 VerticalOptions = LayoutOptions.Центр
 };
 метка.SetBinding(
 Метка.ТекстПроперти,
 nameof(ClockWidgetViewModel.Time));
 Содержимое = метка;
 }
}
```

Приведенный выше код выполняет следующие действия:
• Создает один файл, представляющий виджет ClockWidget.
• Направляет BindingContext вашего виджета на
ЧасыВиджетВидМодель
• Создает метку и привязывает ее свойство Text к
свойство модели представления Time
• Присваивает метку содержимому представления

# Разметка C#

Недавно я начал ценить возможность бегло
создавать пользовательские интерфейсы. Я не склонен делать это часто, потому что лично я чувствую себя комфортно
построение с помощью XAML или, возможно, это стокгольмский синдром ☺
(Я работаю с XAML уже более 10 лет). Когда я это делаю, это
должно быть как можно проще для чтения и создания, учитывая, что это не то, что я
делать часто.

Являясь специалистом по сопровождению .NET MAUI Community Toolkit, одним из
Пакеты, которые мы предоставляем, это CommunityToolkit.Maui.Markup. Он предоставляет набор
методов расширения и помощников для быстрого создания пользовательских интерфейсов.

```Csharp
использование CommunityToolkit.Maui.Markup;
используя WidgetBoard.ViewModels;
пространство имен WidgetBoard.Views;
открытый класс ClockWidget : ContentView
{
 публичный ClockWidget ()
 {
 BindingContext = new ClockWidgetViewModel();
 Контент = новая метка()
 .Шрифт(размер: 80)
 .ЦентрГоризонтальный()
 .ЦентрВертикаль()
 .Bind(Label.TextProperty,
nameof(ClockWidgetViewModel.Time));
 }
}
```

Этот код выполняет те же шаги, что и простой пример C#; однако,
код намного легче читать. Я уверен, вы можете себе представить, что когда
увеличивается сложность пользовательского интерфейса, такой беглый подход действительно может начать
принести вам пользу.

# Архитектура, выбранная для этой книги

В этой книге мы будем использовать архитектуру на основе MVVM.
при создании пользовательского интерфейса через XAML.

Причины, по которым я выбрал MVVM, следующие:
• Я провел последние 10 с лишним лет, используя эту архитектуру, поэтому
это, безусловно, кажется мне естественным.
• Это был очень распространенный способ создания приложений.
за последнее десятилетие, поэтому существует обилие
ресурсы в Интернете, чтобы помочь в преодолении проблем
вокруг него.
• Это общий шаблон для всех продуктов Microsoft и
имеет проверенный послужной список.
Теперь, когда я рассмотрел различные варианты архитектуры и
решили использовать MVVM, давайте перейдем к добавлению конкретных представлений
и ViewModels, чтобы его можно было использовать внутри приложения. Тогда я
показать, как начать упрощать реализацию, чтобы код действительно
нужно только включить основную логику, избегая необходимости добавлять много
шаблонный код.

# Добавление ViewModels

Сначала добавьте новую папку в свой проект.
• Щелкните правой кнопкой мыши проект WidgetBoard.
• Выберите «Добавить» ➤ «Новая папка».
• Введите имя ViewModels.
• Щелкните Добавить.
В этой папке будут храниться модели представления вашего приложения. Давайте приступим к
добавление первого.

# Добавляем IWidgetViewModel

Первый элемент, который вам нужно добавить, — это интерфейс. Он будет представлять все виджеты
просматривать модели, которые вы создаете в своем приложении.
• Щелкните правой кнопкой мыши папку ViewModels.
• Выберите «Добавить» ➤ «Новый элемент».
• Выберите тип интерфейса.
• Введите имя IWidgetViewModel.
• Щелкните Добавить.
Измените этот файл на следующее:

```Csharp
пространство имен WidgetBoard.ViewModels;
открытый интерфейс IWidgetViewModel
{
 int Позиция { получить; набор; }
 строка Тип {получить; }
}
```

# Добавление BaseViewModel

Он будет служить базовым классом для всех ваших моделей представления, так что вы можете
нужно написать какой-то шаблонный код один раз. Не волнуйся; вы увидите, как
оптимизировать это еще больше!
• Щелкните правой кнопкой мыши папку ViewModels.
• Выберите «Добавить» ➤ «Класс».
• Введите имя BaseViewModel.
• Щелкните Добавить.

Вы можете заменить содержимое файла класса следующим кодом:

```Csharp
используя System.ComponentModel;
с помощью System.Runtime.CompilerServices;
пространство имен WidgetBoard.ViewModels;
общедоступный абстрактный класс BaseViewModel: INotifyPropertyChanged
{
 открытое событие PropertyChangedEventHandler PropertyChanged;
 protected void OnPropertyChanged (строка [CallerMemberName]
имя_свойства = "")
 {
 PropertyChanged?.Invoke(это, новый PropertyChangedEventA
rgs(имя_свойства));
 }
 protected bool SetProperty<TValue>(ref TValue backingField,
Значение TValue, строка [CallerMemberName] propertyName = "")
 {
 if (Comparer<TValue>.Default.Compare(backingField,
значение) == 0)
 {
 вернуть ложь;
 }
 поле поддержки = значение;
 OnPropertyChanged(имя_свойства);
 вернуть истину;
 }
}
```
Вы должны быть знакомы с первой строкой внутри класса:

```общественное событие PropertyChangedEventHandler PropertyChanged;```

Это определение события, которое вы должны добавить как часть реализации
интерфейс INotifyPropertyChanged и служит механизмом
ваша модель представления для обновления представления.
Следующий метод обеспечивает механизм легкого повышения
Событие PropertyChanged:

```Csharp
protected void OnPropertyChanged (строка [CallerMemberName]
имя_свойства = "")
{
 PropertyChanged?.Invoke(это, новый PropertyChangedEventArgs(
Имя свойства));
}
```
Метод OnPropertyChanged можно вызывать с передачей или без нее.
в значении для propertyName. Передавая значение, вы указываете
какое имя свойства в вашей модели представления изменилось. Если нет, то
атрибут [CallerMemberName] указывает, что имя вызывающего абонента будет
использовал. Не беспокойтесь, если сейчас это немного неясно; это станет много
яснее, когда вы добавляете свою собственность в свой ClockWidgetViewModel, поэтому
просто терпите меня.
Последний метод добавляет много ценности:

```Csharp
защищенное логическое значение SetProperty<TValue>(
 ссылка TValue backingField,
 Значение TValue,
 [CallerMemberName] строка propertyName = "")
{
 if (Comparer<TValue>.Default.Compare(backingField,
значение) == 0)
 {
 
 вернуть ложь;
 }
 поле поддержки = значение;
 OnPropertyChanged(имя_свойства);
 вернуть истину;
}
 
```

Метод SetProperty делает следующее:
• Позволяет вызывать его из установщика свойств, передавая
поле и устанавливаемое значение
• Проверяет, отличается ли значение от резервного
поле, в основном определяющее, имеет ли свойство
действительно изменился
• Если он изменился, он запускает событие PropertyChanged.
используя ваш новый метод OnPropertyChanged
• Возвращает логическое значение, указывающее, было ли значение
действительно измениться. Это может быть очень полезно, когда нужно
для обновления других свойств или команд!
На этом реализация базовой модели представления завершена. Давайте приступим к
используя его в качестве основы для ClockWidgetViewModel, чтобы действительно оценить
ценность, которую он обеспечивает.

# Добавляем ClockWidgetViewModel

Давайте добавим новый файл класса в вашу папку ViewModels, как вы сделали для
Файл BaseViewModel.cs. Назовите этот файл ClockWidgetViewModel и измените
содержание к следующему:

```
с помощью системы;

используя System.ComponentModel;
пространство имен WidgetBoard.ViewModels;
открытый класс ClockWidgetViewModel: BaseViewModel,
IWidgetViewModel
{
 частный планировщик только для чтения scheduler = new();
 личное время DateTime;
 публичное время DateTime
 {
 получить => время;
 set => SetProperty (время ссылки, значение);
 }
 публичная позиция {получить; набор; }
 общедоступная строка Тип => "Часы";
 публичный ClockWidgetViewModel()
 {
 УстановитьВремя(ДатаВремя.Сейчас);
 }
 public void SetTime (DateTime dateTime)
 {
 Время = ДатаВремя;
 планировщик.ScheduleAction(
 TimeSpan.FromSeconds(1),
 () => УстановитьВремя(ДатаВремя.Сейчас));
 }
}

```
Приведенный выше код должен быть вам знаком. Вы видели это при просмотре
МВВМ. Сделанная здесь оптимизация заключается в уменьшении размера окна Time.
свойство сократилось до 5 строк, тогда как в исходном примере было 16 строк.
кода.

# Добавление представлений

Сначала добавьте новую папку в свой проект.
• Щелкните правой кнопкой мыши проект WidgetBoard.
• Выберите «Добавить» ➤ «Новая папка».
• Введите имя Представления.
• Щелкните Добавить.
В этой папке будут храниться представления вашего приложения. Приступим к добавлению
твой первый.

# Добавление IWidgetView
Первый элемент, который вам нужно добавить, — это интерфейс для представления всех представлений виджета.
модели, которые вы создаете в своем приложении.
• Щелкните правой кнопкой мыши папку Представления.
• Выберите «Добавить» ➤ «Новый элемент».
• Выберите тип интерфейса.
• Введите имя IWidgetView.
• Щелкните Добавить.

Измените содержимое этого файла на следующее

```Csharp
используя WidgetBoard.ViewModels;
пространство имен WidgetBoard.Views;
публичный интерфейс IWidgetView
{
 int Position { get => WidgetViewModel.Position; установить =>
WidgetViewModel.Position = значение; }
 IWidgetViewModel WidgetViewModel { получить; набор; }
}
```

# Добавляем ClockWidgetView

Следующим элементом, который вам нужно добавить, является ContentView. Это первый раз, когда ты
делают это, поэтому выполните следующие действия:
• Щелкните правой кнопкой мыши папку Представления.
• Выберите «Добавить» ➤ «Новый элемент».
• Выберите вкладку .NET MAUI.
• Выберите параметр .NET MAUI ContentView (XAML).
• Введите имя ClockWidgetView.
• Щелкните Добавить.
Обратите внимание, что в ваш проект добавлены два новых файла:
ClockWidgetView.xaml и ClockWidgetView.xaml.cs. Вы можете
обратите внимание, что файл ClockWidgetView.xaml.cs скрыт в решении
панели проводника и что вам нужно развернуть стрелку слева от
Файл ClockWidgetView.xaml.
Давайте обновим оба файла, чтобы они соответствовали тому, что было в исходных примерах.

Откройте файл ClockWidgetView.xaml и измените содержимое на
следующий:

```xml
<?xml версия="1.0" кодировка="utf-8" ?>
<Ярлык
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.Views.ClockWidgetView"
 Размер шрифта = "60"
 Вертикальные опции = "Центр"
 HorizontalOptions="Центр"
 x: DataType = "вьюмоделс: ClockWidgetViewModel"
 Text="{Время привязки}">
</метка>
```
Откройте файл ClockWidgetView.xaml.cs и измените содержимое на
следующее:

```Csharp
используя WidgetBoard.ViewModels;
пространство имен WidgetBoard.Views;
общедоступный частичный класс ClockWidgetView: Label, IWidgetView
{
 публичный ClockWidgetView()
 {
 ИнициализироватьКомпонент();
 WidgetViewModel = новая ClockWidgetViewModel();
 BindingContext = WidgetViewModel;
 }
 общественность IWidgetViewModel WidgetViewModel { получить; набор; }
}
```

На этом работа по добавлению ClockWidget в вашу кодовую базу завершена.
Теперь вам нужно изменить свое приложение, чтобы вы могли видеть этот виджет
В бою!

# Просмотр вашего виджета

Для того, чтобы просмотреть ваш виджет в вашем приложении, вам нужно сделать некоторые
изменения в файлах MainPage.xaml и MainPage.xaml.cs, которые были
генерируется при первом создании проекта.

## Изменение MainPage.xaml
Просто замените содержимое файла следующим.

```xml
<?xml версия="1.0" кодировка="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/
точка/2021/мауи"
 xmlns:x="http://schemas.microsoft.com/
winfx/2009/xaml"
 xmlns:views="clr-namespace:WidgetBoard.Views"
 x:Class="WidgetBoard.MainPage">
 <представления: ClockWidgetView />
</ContentPage>
```
В исходном файле был базовый пример, который поставляется с .NET MAUI.
шаблон, но в этом приложении от него мало толку.

## Изменение MainPage.xaml.cs

Вам нужно изменить содержимое этого файла, потому что вы удалили некоторые
элементы управления из файла MainPage.xaml. Если вы не обновите этот файл, Visual
Студия сообщит об ошибках компиляции. Вы можете заменить все содержимое

файла MainPage.xaml.cs со следующим, чтобы удалить ссылки на
элементы управления, которые вы удалили из файла XAML:

```Csharp
пространство имен WidgetBoard;
общедоступный частичный класс MainPage : ContentPage
{
 общедоступная главная страница ()
 {
 ИнициализироватьКомпонент();
 }
}
```

На этом изменения, которые необходимо внести в приложение, завершены.
Давайте посмотрим, как теперь выглядит ваше приложение!

## Прием заявки на спин

Если вы создадите и запустите свое приложение так же, как вы научились в главе 2,
вы можете видеть, что он отображает ClockWidget так же, как я изначально разработал.
На рис. 4-4 показан виджет часов, отображаемый в работающем приложении.
на макОС.

![изображение](https://user-images.githubusercontent.com/26972859/231113621-1d4143c8-c703-431e-8177-4a9651cbb16c.png)
Рисунок 4-4. Виджет часов, отображаемый в работающем приложении
на macOS

Вы рассмотрели способы оптимизации вашей кодовой базы при использовании MVVM.
но я хотел бы предоставить дополнительную информацию о том, как вы можете использовать
силу сообщества, чтобы еще больше улучшить ваш опыт.

## Усовершенствования MVVM

Есть две ключевые части, которые я расскажу о том, как вы можете использовать существующие
пакеты, чтобы уменьшить объем кода, который требуется написать.

# Фреймворки MVVM

Существует несколько сред MVVM, которые могут расширить это, предоставив
реализация базового класса для вас с различными уровнями других дополнительных
функции. Чтобы перечислить несколько,
• СообществоToolkit.Mvvm
• МВВМлайт
• ФрешМВВМ
• Призма
• Refractored.MVVMHelpers
• Реактивный интерфейс

Эти пакеты в конечном итоге предоставят вам базовый класс очень
аналогично классу BaseViewModel, который вы создали ранее. Например,
библиотека Prism предоставляет класс BindableBase, который вы можете использовать. Это
предлагает еще одну оптимизацию с точки зрения меньшего количества кода, который вам нужно написать
и в конечном итоге сохранить.
Можно пойти еще дальше, но нужно верить…

# Магия

Да, верно: магия реальна! Эти подходы включают автоматическую генерацию
требуемый шаблонный код, чтобы нам, как разработчикам, не приходилось это делать.
Есть два основных пакета, предлагающих эту функциональность. Они обеспечивают это
через разные механизмы, но работают они одинаково хорошо.
• Fody: генерация IL, https://github.com/Fody/Home.
• CommunityToolkit.Mvvm: Генераторы исходников (да, это
получает второе упоминание), https://learn.microsoft.
com/dotnet/communitytoolkit/mvvm/
Раньше я скептически относился к использованию таких пакетов. Я чувствовал, что я
теряя контроль над частями, за которые мне нужно было держаться. Теперь я могу оценить
что я был наивен, и это впечатляет.
Давайте посмотрим, как эти пакеты могут помочь еще больше сократить
код. В этом примере используется CommunityToolkit.Mvvm, который предоставляет
Базовый класс ObservableObject и прекрасный способ добавления атрибутов
([ObservableProperty]) в поля, которые вы хотите инициировать PropertyChanged
события при изменении их значения. Затем это создаст свойство с
то же имя, что и у поля, но с заглавной первой буквой, поэтому время
становится Время.

```Csharp
общедоступный частичный класс ClockWidgetViewModel: ObservableObject
{
 [Наблюдаемое свойство]
 личное время DateTime;
 публичный ClockWigetViewModel()
 {
 УстановитьВремя(ДатаВремя.Сейчас);
 }
 public void SetTime (DateTime dateTime)
 {
 Время = ДатаВремя;
 планировщик.ScheduleAction(
 TimeSpan.FromSeconds(1),
 () => УстановитьВремя(ДатаВремя.Сейчас));
 }
}
```

Это на 17 строк меньше 2 по сравнению с исходным примером! Часть, которую я
действительно нравится то, что он уменьшает весь шум шаблонного кода, поэтому есть
больше внимания уделяется коду, который нам нужно писать как разработчикам.
Возможно, вы заметили, что вы все еще ссылаетесь на свойство Time.
в коде, но вы не предоставили определение для этого свойства. Этот
вот где волшебство приходит! Если щелкнуть правой кнопкой мыши свойство Time и выбрать
Перейти к определению… откроется следующий исходный код, чтобы вы могли просмотреть
что инструментарий создал для вас:

```Csharp
// <сгенерировано автоматически/>
# прагма предупреждение отключить
#nullable включить
пространство имен WidgetBoard.ViewModels

{
 частичный класс ClockWidgetViewModel
 {
 /// <inheritdoc cref="time"/>
 [глобальный::System.CodeDom.Compiler.
GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.
ObservablePropertyGenerator", "8.0.0.0")]
 [global::System.Diagnostics.CodeAnalysis.
ExcludeFromCodeCoverage]
 общедоступный глобальный:: System.DateTime Время
 {
 получить => время;
 набор
 {
 если (!global::System.Collections.Generic.
EqualityComparer<global::System.DateTime>.
Default.Equals(время, значение))
 {
 OnTimeChanging (значение);
 OnPropertyChanging(global::CommunityToo
lkit.Mvvm.ComponentModel.__Внутренние компоненты.__
KnownINNotifyPropertyChangingArgs.Time);
 время = стоимость;
 OnTimeChanged (значение);
 OnPropertyChanged(global::CommunityTool
комплект.Mvvm.ComponentModel.__Internals.__
KnownINotifyPropertyChangedArgs.Time);
 }
 }
 }
 
 /// <summary>Выполняет логику, когда <см.
cref="Время"/> меняется.</summary>
 [глобальный::System.CodeDom.Compiler.
GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.
ObservablePropertyGenerator", "8.0.0.0")]
 частичное аннулирование OnTimeChanging(global::System.
значение даты и времени);
 /// <summary>Выполняет логику, когда <см.
cref="Время"/> только что изменено.</summary>
 [глобальный::System.CodeDom.Compiler.
GeneratedCode("CommunityToolkit.Mvvm.SourceGenerators.
ObservablePropertyGenerator", "8.0.0.0")]
 частичное аннулирование OnTimeChanged(global::System.
значение даты и времени);
 }
}
 
```
Вы можете видеть, что сгенерированный исходный код выглядит немного зашумленным, но это
на самом деле генерирует необходимое вам свойство. Посмотреть выделенный раздел
жирным шрифтом выше.
Я только действительно поцарапал поверхность относительно функциональности
которые предлагает CommunityToolkit.Mvvm. Я настоятельно рекомендую вам обратиться
в документации по адресу https://learn.microsoft.com/dotnet/
communitytoolkit/mvvm/, чтобы узнать, как это может помочь вашему приложению.
разработка.

# Краткое содержание

Надеюсь, я ясно дал понять, что не существует единственно правильного способа делать что-то или
создавать приложения. Вы должны выбрать и выбрать, какие подходы будут лучше всего
соответствовать вашей среде. Учитывая это, целью настоящей главы было
чтобы дать вам хороший обзор нескольких различных подходов к архитектуре
ваше приложение. Вокруг всегда много мнений
указать, какие архитектуры люди предпочитают, но я настоятельно призываю вас
оцените, что поможет вам достичь ваших целей лучше всего.
В этой главе у вас есть
• Узнали о различных возможностях, которые у вас есть
спроектируйте свои приложения
• Решили, какую архитектуру использовать
• Прошелся по конкретному примеру, создав
виджет часов
• Узнали, как оптимизировать внедрение
с помощью пакетов NuGet
В следующей главе вы будете
• Создайте и примените значок в своем приложении.
• Добавьте несколько страниц-заполнителей и просмотрите модели.
• Заполните свою первую страницу пользовательским интерфейсом и настройте привязки к
модель представления
• Узнайте о привязке данных и ее многочисленных применениях.
• Получите представление о XAML
• Узнайте о возможных макетах, которые можно использовать для группировки.
другие элементы управления
• Получить представление о «Шелл» и применить его к
построение структуры вашего приложения
• Применить навигацию Shell, чтобы вы могли перемещаться
• Создайте всплывающее меню

# Исходный код

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introduction-MAUI/tree/
основной/ch04.


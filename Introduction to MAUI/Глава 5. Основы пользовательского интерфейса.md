# ГЛАВА 5

# Основы пользовательского интерфейса

В этой главе вы собираетесь исследовать основные части
создание приложения .NET MAUI. Вы собираетесь применить значок и
экран-заставку, добавьте несколько страниц и связанных с ними моделей просмотра, а также
настроить некоторые привязки между вашей страницей и моделью представления. Вы будете
также получить представление о том, что такое XAML и что он может предложить, когда вы
создайте страницы и оболочку вашего приложения. Вы также узнаете, как
Shell позволяет вам перемещаться между страницами вашего приложения.

# Предпосылки

Вам нужно выполнить некоторые настройки, прежде чем вы сможете перейти к использованию Shell. Если Шелл
все еще чувствуя себя неизвестной концепцией, не бойтесь. Я буду освещать это немного
чуть позже в этой главе в разделе «Оболочка».
Давайте продолжим и добавим следующие папки в ваш проект.

# Модели

Здесь будут размещены все ваши классы моделей. Если вы помните из главы 4, эти
где находится часть вашей бизнес-логики. В папке «Модели» вы
нужно создать три класса.

# Базовый макет.cs

Он будет служить базовым классом для параметров макета, которые вы предоставляете. В течение
В этой книге вы будете создавать только платы с фиксированным макетом, но я хотел
заложите основу, чтобы, если вы чувствуете себя авантюрным, вы могли уйти
и создавать альтернативные варианты компоновки без необходимости реструктуризации
приложение. На самом деле, я хотел бы услышать, где вы его берете!

```Csharp
пространство имен WidgetBoard.Models;
общедоступный абстрактный класс BaseLayout
{
}
```

# Фиксированный макет.cs

Это будет представлять фиксированный макет, как я упоминал в предыдущем разделе.
Ваш фиксированный макет предложит пользователю приложения возможность выбрать
количество строк и столбцов, а затем размещать в них свои виджеты.

```Csharp
пространство имен WidgetBoard.Models;
открытый класс FixedLayout : BaseLayout
{
 общественный интервал NumberOfColumns { получить; в этом; }
 публичный интервал NumberOfRows { получить; в этом; }
}
```

# Board.cs

Ваша окончательная модель представляет собой общую плату.

```Csharp
пространство имен WidgetBoard.Models;
Совет общественного класса
{
 общедоступная строка Имя {получить; в этом; }
 общественный макет BaseLayout { получить; в этом; }
}  
```

# Страницы

В нем будут размещены страницы вашего приложения. я различаю между
страницу и представление, потому что они ведут себя по-разному в .NET MAUI. Ты
можно думать о странице как об экране, который вы видите, тогда как представление — это
меньший компонент. Страница может содержать несколько представлений.
Давайте продолжим и создадим следующие файлы в папке Pages.
Следующие шаги показывают, как добавить новые страницы.

Щелкните правой кнопкой мыши папку «Страницы».
• Выберите «Добавить» ➤ «Новый элемент».
• Выберите вкладку .NET MAUI.
• Выберите .NET MAUI ContentPage (XAML).
• Щелкните Добавить.

## BoardDetailsPage

Это страница, которая позволяет вам создавать и редактировать свои доски. На данный момент,
вы не будете трогать содержимое этого файла. Обратите внимание, что вы должны увидеть
Созданы файлы BoardDetailsPage.xaml и BoardDetailsPage.xaml.cs.
Вам также необходимо перейти к файлу MauiProgram.cs и зарегистрировать этот
страница со службами внутри метода CreateMauiApp.

```Csharp
builder.Services.AddTransient<BoardDetailsPage>();
```
# FixedBoardPage

Это страница, на которой будут отображаться доски, созданные вами на предыдущей странице.
Пока вы не будете трогать содержимое этого файла. Обратите внимание, что вы должны
см. созданные файлы FixedBoardPage.xaml и FixedBoardPage.xaml.cs.
Вам также нужно будет перейти к файлу MauiProgram.cs и зарегистрироваться
эта страница со службами внутри метода CreateMauiApp.

```builder.Services.AddTransient<FixedBoardPage>();```

# ViewModels

Здесь находятся ваши ViewModels, которые являются основой как для ваших страниц, так и для
Взгляды. Вы создали эту папку в предыдущей главе, но вам нужно добавить
количество занятий. Следующие шаги показывают, как добавить новые страницы.
• Щелкните правой кнопкой мыши папку ViewModels.
• Выберите «Добавить» ➤ «Новый класс».
• Щелкните Добавить.

# AppShellViewModel

Это служит моделью представления для файла AppShell, созданного для вас.
по оснастке.
пространство имен WidgetBoard.ViewModels;
открытый класс AppShellViewModel: BaseViewModel
{
}

Вам также необходимо перейти к файлу MauiProgram.cs и зарегистрировать этот
страница со службами внутри метода CreateMauiApp.

```Csharp
builder.Services.AddTransient<AppShellViewModel>();
```

# BoardDetailsPageViewModel

Это служит моделью представления для созданного вами файла BoardDetailsPage.

```Csharp
пространство имен WidgetBoard.ViewModels;
открытый класс BoardDetailsPageViewModel: BaseViewModel
{
}
```
Вам также необходимо перейти к файлу MauiProgram.cs и зарегистрировать этот
страница со службами внутри метода CreateMauiApp.

```Csharp
builder.Services.AddTransient<BoardDetailsPageViewModel>();
```

# FixedBoardPageViewModel

Это служит моделью представления для созданного вами файла FixedBoardPage.

```Csharp
пространство имен WidgetBoard.ViewModels;
открытый класс FixedBoardPageViewModel: BaseViewModel
{
}
```

Вам также необходимо перейти к файлу MauiProgram.cs и зарегистрировать этот
страница со службами внутри метода CreateMauiApp.

```builder.Services.AddTransient<FixedBoardPageViewModel>();```

---
Вы должны были заметить общую закономерность при создании этих
файлы и необходимость добавления их в файл MauiProgram.cs. Это
чтобы вы могли в полной мере использовать внедрение зависимостей, предоставляемое
framework, о котором вы узнали в главе 3.
---

# Значки приложений

Каждому приложению нужна иконка, и для многих это будет именно так.
получить их первое впечатление. К счастью, в наши дни экраны устройств позволяют
для больших размеров значков и, следовательно, для включения в них большего количества деталей.
Как и в случае с общими ресурсами изображений, для каждой платформы требуются разные размеры.
и многие другие комбинации, которые будут предоставлены. Например, iOS ожидает
следующее:
• Пять различных размеров значка приложения
• Три разных размера для функции Spotlight
• Три разных размера для уведомлений
• Три разных размера для настроек
Это до 14 различных размеров изображений, необходимых только для вашего приложения.
значок только на iOS. См. https://developer.apple.com/design/humaninterface-guidelines/ios/icons-and-images/app-icon/.
.NET MAUI управляет процессом создания всех необходимых образов
для тебя. Все, что вам нужно сделать, это предоставить файл изображения SVG. Поскольку SVG
векторные, они могут масштабироваться до любого требуемого размера.

## Добавление собственной иконки

На рис. 5-1 показан значок, который вы будете использовать для своего приложения. Ты
можете получить копию файлов, которые вы будете использовать, с https://github.
com/bijington/introduction-dotnet-maui/tree/main/chapter05 и
поместите их в папку Resources/AppIcon. Вы должны заметить, что они
заменить два существующих файла.

![изображение](https://user-images.githubusercontent.com/26972859/231117066-af76bc3f-63d8-4fcd-84cb-0bed1613b9e7.png)
Рисунок 5-1. Значок вашего приложения

Если вы посмотрите содержимое вашего файла проекта, вы увидите
следующая запись:

```<MauiIcon Include="Resources\AppIcon\appicon.svg" />```

Это говорит инструментам использовать файл appicon.svg и преобразовывать его во все
необходимые размеры для каждой платформы при строительстве. Обратите внимание, что вы хотите только
один MauiIcon в вашем файле проекта. Если у вас их несколько, первый будет
использоваться.
Вам не нужно заменять вышеуказанную запись, так как файл, который вы должны
скачанный должен иметь имя appicon.svg. Если имя файла
другой, либо переименуйте его, либо обновите имя в файле проекта.

# Различия платформ

Стоит отметить, что некоторые платформы применяют разные правила к значкам приложений.
а также может давать весьма разные результаты.

## Андроид

Иконки приложений на Android могут принимать разные формы из-за разных
производители устройств и свой вариант операционной системы Android.
система. Чтобы учесть это, Google представила адаптивную иконку. Это позволяет
разработчику определить два слоя в своей иконке:
• Фон: Обычно это однотонный или
последовательный узор.
• Передний план: сюда входят основные детали.
.NET MAUI позволяет поддерживать адаптивный значок с помощью
IncludeFile и свойства ForegroundFile на MauiIcon
элемент. Вы можете видеть, что IncludeFile уже определен в вашем проекте.
Это представляет фон. Вы можете разделить значок приложения на
две части, а затем предоставить детали ForegroundFile. Обратите внимание, что это
может применяться ко всем платформам, и это мой рекомендуемый способ доставки
значок приложения.

## iOS и macOS

Apple не допускает прозрачности значков приложений. Вы также можете
убедитесь, что вы предоставляете изображение без прозрачных пикселей, или вы можете
используйте свойство Color элемента MauiIcon, которое заполнит любой
прозрачные пиксели с этим определенным цветом.

# Заставка

Заставка — это первое, что видит пользователь, когда запускает ваш
приложение. Это дает вам как разработчику способ показать пользователю
что-то во время запуска приложения. Как только все
завершится загрузка, экран-заставка будет скрыт, а ваша главная страница
быть показаны.

Подобно тому, как управляется значок приложения, экран-заставка
также имеет запись в файле проекта и может генерировать экран на основе
SVG-файл. Фактически, вы будете использовать одно и то же изображение, чтобы сэкономить усилия.

```xml
<MauiSplashScreen Include="Ресурсы\Всплеск\всплеск.svg"
Цвет = "# 512BD4" BaseSize = "128 128" />
```
Обратите внимание, что экраны-заставки, построенные таким образом, должны быть статическими. Вы не можете
иметь любую анимацию, чтобы показать прогресс.
Свойство Color позволяет определить цвет фона для
заставка.

# XAML

Как разработчик .NET MAUI, вы много раз услышите упоминание XAML,
XAML означает расширяемый язык разметки приложений. Это язык на основе XML, используемый для определения пользовательских интерфейсов. Он происходит из WPF
и Silverlight, но версия .NET MAUI имеет свои отличия.
Существует два разных типа файлов XAML, с которыми вы столкнетесь.
при создании приложения:
• ResourceDictionary: это один файл, который
содержит ресурсы, которые можно легко использовать во всем
ваше приложение. Ресурсы/Стили/Styles.xaml
является прекрасным примером этого. Файл Styles.xaml представляет собой
набор стилей по умолчанию, который предоставляется при создании
новое приложение .NET MAUI. Если вы хотите изменить
некоторые встроенные стили, это очень хорошее место для этого.
• Файл на основе представления: он содержит как .xaml, так и
Файл .xaml.cs. Они соединяются вместе с помощью
ключевое слово частичного класса.

---
При работе с этим вторым пунктом вы должны убедиться, что
строка InitializeComponent вызывается внутри конструктора;
в противном случае XAML не будет правильно интерпретирован, и вы увидите
выброшено исключение.
---

Стоит отметить, что XAML не предоставляет такого богатого набора функций, как
C# делает, и по этой причине почти всегда есть файл xaml.cs, который
вместе с файлом XAML. Этот файл C# предоставляет возможность использовать богатый набор функций языка C#, когда XAML не позволяет. Например, обработка
событие взаимодействия с кнопкой должно быть выполнено в файле кода C#.

## Анализ файла XAML

В разделе предварительных требований этой главы вы создали
Файл BoardDetailsPage.xaml. Теперь вы собираетесь изменить его и добавить некоторые
содержательный контент, чтобы вы могли начать видеть, как ваше приложение обретает форму.
Код, который вы должны увидеть в этом файле, показан ниже.

```xml
<?xml версия="1.0" кодировка="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/
точка/2021/мауи"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 x:Class="WidgetBoard.Pages.BoardDetailsPage"
 Заголовок = "Страница сведений о доске">
 <вертикальный стекмакет>
 <Ярлык
 Text="Добро пожаловать в .NET MAUI!"
 Вертикальные опции = "Центр"
 HorizontalOptions="По центру" />
 </вертикальный стекмакет>
</ContentPage>
```

Если вы разобьете это на маленькие кусочки, вы сможете начать понимать
не только то, что составляет пользовательский интерфейс вашего приложения, но и некоторые
основы представления XAML.
Корневой элемент — это ContentPage. Как уже упоминалось, типичный вид в
.NET MAUI — это либо ContentPage, либо ContentView. Как следует из названия,
это страница, на которой представлено ее содержимое, и это будет единственное представление, поскольку ее
содержание.
Как уже упоминалось, XAML — это язык, основанный на XML, и существуют
следующие ключевые части для понимания XAML:
1. Свойства задаются атрибутами вашего элемента, поэтому

```<Label Text="Добро пожаловать в .NET MAUI!" />```
фактически то же самое, что писать
```
новый ярлык
{
 Text ="Добро пожаловать в .NET MAUI!"
};
```

2. XAML представляет визуальную иерархию в файле
состав. Вы можете понять, что ContentPage имеет
дочерний элемент VerticalStackLayout, и у него есть дочерний элемент
этикетки. Это может быть особенно полезно. Комплекс
XAML приведет к сложному визуальному дереву и
вы хотите сделать все возможное, чтобы избежать этого.
3. Тег xmlns работает как оператор using в C#. Этот
позволяет ссылаться на другие функции, которые могут не
быть доступным из коробки. Например, вы можете добавить
строка xmlns:views="clr-namespace:WidgetBoard.
Views», и это эквивалентно добавлению с помощью
Виджетборд.представления; в файле С#. Это позволяет вам
обратитесь к представлениям в вашей кодовой базе.

Содержимое вашей ContentPage в вашем XAML представляет собой
Вертикальный стекмакет. Я расскажу о макетах немного позже в этой главе.
но в качестве очень краткого обзора они позволяют вам иметь несколько дочерних представлений как
содержание и, следовательно, открыть возможности для создания ваших пользовательских интерфейсов. Это
стоит отметить, что у ContentPage может быть только один дочерний элемент, что делает
Макеты действительно важные элементы управления для использования при создании пользовательских интерфейсов.
Теперь, когда вы рассмотрели некоторые ключевые концепции XAML,
давайте продолжим и начнем создавать первую страницу вашего приложения.

# Создание первой XAML-страницы

Мне всегда нравится работать с четким определением того, что должно быть достигнуто, чтобы
давайте определим, что ваша страница должна делать. Нужно сделать следующее:
• Разрешить пользователю создавать новую доску.
• Подходит для различных размеров экрана.
• Разрешить пользователю указывать имя доски.
• Разрешить пользователю выбирать тип макета.
• Применить любые допустимые свойства для определенного макета
тип выбран.
Теперь, когда вы знаете, чего нужно достичь, давайте продолжим и сделаем
это. Вам необходимо удалить существующее содержимое страницы и заменить его
с границей. Border похож на ContentView тем, что может иметь только
один ребенок, но он предлагает вам некоторые дополнительные свойства, которые позволяют вам
обеспечить красивый пользовательский интерфейс. В частности, вы заботитесь о StrokeShape
и свойства штриха. Вы можете заметить, что на самом деле вы не устанавливаете
эти свойства в XAML, и вы были бы правы! Есть два
основные причины этого:

У вас есть подходящие значения по умолчанию, определенные в Resources/
Созданный для вас файл Styles/Styles.xaml. Примечание
что если вы хотите переопределить их, это совершенно нормально. я
мы рассмотрим это немного позже в этой главе в
раздел «Стиль».
• Считается хорошей практикой определять только
свойства, которые вам нужно предоставить, что в основном
все, что отличается от значений по умолчанию. В то время
Компилятор XAML неплохо справляется с созданием
Пользовательский интерфейс, который определяется во время компиляции, некоторые биты все еще
потенциально интерпретируется во время выполнения, и это имеет
влияние производительности.

```xml
<?xml версия="1.0" кодировка="utf-8" ?>
<страница содержимого
 xmlns="http://schemas.microsoft.com/
точка/2021/мауи"
 xmlns:x="http://schemas.microsoft.com/
winfx/2009/xaml"
 x:Class="WidgetBoard.Pages.BoardDetailsPage">
 <Граница
 Минимальная ширина запроса = "300"
 HorizontalOptions="Центр"
 Вертикальные опции = "Центр"
 Заполнение = "0">
 </Граница>
</ContentPage>
```

Самая важная часть свойств, которые вы устанавливаете, — это
Горизонтальные параметры и вертикальные параметры. Они позволяют определить, где
в родительском это представление будет отображаться. По умолчанию представление будет заполнять

родители довольны, но вы собираетесь заставить его плавать в центре. Главный
Причина в том, что он останется там независимо от размера экрана, на котором он работает.
Конечно, есть более подробные способы обработки разных размеров экрана.
и вы будете исследовать их в следующих главах.
Хотя у вас есть гораздо больше содержимого, которое можно добавить в этот XAML,
мы собираемся сделать это в контексте следующих тем. Ваш следующий шаг
чтобы добавить несколько дочерних представлений. Для этого вам нужно будет выбрать
подходящий макет.

# Макеты

.NET MAUI предоставляет вам набор готовых классов компоновки, которые позволяют вам
группировать и упорядочивать представления в приложении. Цель этого раздела состоит в том, чтобы
изучите каждый элемент управления макетом и то, как его можно использовать для вашего приложения.
Я настоятельно рекомендую поэкспериментировать с каждым из макетов, чтобы увидеть, что
лучше всего подходит для каждого отдельного случая использования, и всегда помните о сохранении
визуальное дерево максимально простым.

## Абсолютный макет

Как следует из названия, AbsoluteLayout позволяет позиционировать его
детей с абсолютными значениями. X, y, ширина и высота дочернего элемента
управляется через присоединенное свойство LayoutBounds. Это значит, что ты
использовать следующим образом:

```xml
<Абсолютный макет>
 <Ярлык
 AbsoluteLayout.LayoutBounds="0,0,600,200"/>
</Абсолютный макет>
```

На рис. 5-2 показано, как элемент управления расположен внутри
Абсолютный макет.

![изображение](https://user-images.githubusercontent.com/26972859/231118592-0177bb26-72bc-4ac1-a2f1-d0bee584bb69.png)
Рисунок 5-2. Обзор абсолютной компоновки

Существует также возможность определить границы макета,
пропорциональна самому AbsoluteLayout. Вы можете контролировать это с помощью
Присоединенное свойство AbsoluteLayout.LayoutFlags

```Csharp
<Абсолютный макет>
 <Ярлык
 AbsoluteLayout.LayoutBounds="0,0,0,5,0,2"
 AbsoluteLayout.LayoutFlags="Все"/>
</Абсолютный макет>
```

Это приведет к тому, что метка будет расположена на 0,0, но ширина будет
быть 50% от AbsoluteLayout и высота будет 20%. Это обеспечивает
много сил при определении пользовательского интерфейса, который может увеличиваться до размера
устройство также увеличивается.
Опция LayoutFlags дает вам много возможностей. Ты можешь
выберите, какая часть LayoutBounds применяется абсолютно, а какая
применяются пропорционально. Вот возможные значения для LayoutFlags
и на что они влияют:

|Значение|Описание|
|:--|:--|
|Нет|Все значения являются абсолютными.|
|XProportional|Свойство X пропорционально размерам AbsoluteLayout.|
|YProportional|Свойство Y пропорционально размерам AbsoluteLayout|
|WidthProportional|Свойство Width пропорционально размерам AbsoluteLayout.|
|HeightProportional|Свойство Height пропорционально размерам AbsoluteLayout.|
|PositionProportional|Свойства X и Y пропорциональны размерам AbsoluteLayout.|
|SizeProportional|Свойства Width и Height пропорциональны размерам AbsoluteLayout.|
|Все|Все свойства пропорциональны размерам AbsoluteLayout|

AbsoluteLayout может быть невероятно мощным макетом при использовании
в правильном сценарии. Для вашего сценария он предлагает больше сложностей, чем я
действительно думаю, что вам нужно справиться.

# FlexLayout

FlexLayout поставляется с большим количеством свойств для настройки.
как расположены его дети. Если вы хотите, чтобы ваши элементы управления переносились, это
управление для вас! Хорошим примером использования FlexLayout является мультимедийный
галерея.
На рис. 5-3 показано, как можно расположить элементы управления внутри FlexLayout.

![изображение](https://user-images.githubusercontent.com/26972859/231120286-f2d319da-8575-4241-8f2f-7a2f00618c60.png)
Рисунок 5-3. Обзор FlexLayout

Приведенный выше макет может быть реализован с помощью следующего примера кода:

```xml
<FlexLayout
 Выравнивание элементов = "Начать"
 Обернуть = "Обернуть"
 Маржа = "30"
 JustifyContent="Равномерность пространства">
 <Граница
 ФонЦвет="Светло-Серый"
 Запрос ширины = "100"
 Запрос высоты = "100" />
 <Граница
 ФонЦвет="Светло-Серый"
 Запрос ширины = "100"
 Запрос высоты = "100" />
 <Граница
 ФонЦвет="Светло-Серый"
 Запрос ширины = "100"
 Запрос высоты = "100" />
  <Граница
 ФонЦвет="Светло-Серый"
 Запрос ширины = "100"
 Запрос высоты = "100" />
</FlexLayout>

```
Каждое из свойств, которые вы используете, позволяет вам настроить, где
каждый элемент позиционируется в процессе рендеринга и как они будут
перемещаться в приложении, если его размер изменен. Для дополнительной информации
о возможных способах настройки FlexLayout читайте в Microsoft
документацию по адресу https://learn.microsoft.com/dotnet/maui/userinterface/layouts/flexlayout.
На странице BoardDetailsPage нужны только элементы управления, расположенные вертикально, чтобы
FlexLayout кажется слишком сложным макетом для этой цели.

# Сетка

Я люблю Гридс. Обычно они являются моим предпочтительным вариантом макета, в основном потому, что
Я привык думать о том, как они располагают элементы управления и
потому что они, как правило, позволяют вам сохранять глубину вашего визуального дерева неглубокой.
Макет по существу работает, позволяя вам определить набор строк и
столбцы, а затем определить, какой элемент управления должен отображаться в какой строке/
комбинация столбцов.
На рис. 5-4 показано, как можно расположить элементы управления внутри сетки.

![изображение](https://user-images.githubusercontent.com/26972859/231120630-3dfe23e1-5573-4d5f-b3f3-de708c5b260e.png)
Рисунок 5-4. Обзор компоновки сетки

Элементы управления внутри сетки могут накладываться друг на друга, что может
предоставить дополнительный инструмент в наборе инструментов разработчика, когда нужно показать/
скрыть элементы управления. Элементы управления в сетке упорядочиваются, сначала определяя
Определения столбцов и определения строк. Давайте посмотрим, как создать
приведенный выше макет с сеткой.

```xml
<Сетка
 Определения столбцов = "*, 2*, 250, авто"
 Расстояние между столбцами = "20"
 Маржа = "30"
 Определения строк="*,*"
 Расстояние между строками="20">
 <Граница
 ФонЦвет="Светло-Серый"
 Сетка.Столбец = "0"
 Сетка.Строка="0" />
 <Граница
         ФонЦвет="Светло-Серый"
 Сетка.Столбец = "1"
 Сетка.Строка="1" />
 <Граница
 ФонЦвет="Светло-Серый"
 Сетка.Столбец = "2"
 Сетка.Строка="0" />
 <Граница
 ФонЦвет="Светло-Серый"
 Сетка.Столбец = "3"
 Сетка.Строка="1"
 Запрос ширины = "30"
 Запрос высоты = "30" />
</сетка>
```

Вы можете видеть, что вы создали столбцы, используя различные
параметры:
• 250: это фиксированная ширина 250.
• Авто: это означает, что столбец будет увеличиваться в ширину.
исходя из его содержания. Рекомендуется использовать это
параметр экономно, так как это приведет к управлению сеткой
необходимости измерять его дочерние элементы и принудительно перерисовывать
себе и другим детям
• *: Это пропорционально и приведет к остатку
пространство выделяется. В этом примере два
столбцы используют обозначение *. Это приводит к тем двум
столбцы, занимающие 1/3 и 2/3 оставшихся
ширина соответственно. Это потому, что * на самом деле
считается 1*.

В вашем сценарии вам понадобится несколько групп элементов управления.
По этой причине я считаю, что сетки лишь немного усложнят задачу.
для тебя.

# Горизонтальный стекмакет

Название действительно выдает это. Он позиционирует своих дочерних элементов горизонтально.
HorizontalStackLayout не несет ответственности за предоставление размеров
информацию своим детям, поэтому дети несут ответственность за вычисление
их собственный размер.
На рис. 5-5 показано, как можно расположить элементы управления внутри
Горизонтальный стекмакет.

![изображение](https://user-images.githubusercontent.com/26972859/231121064-a7d256a7-0b2b-4c5b-b497-d979ecfe8b33.png)

Рисунок 5-5. Обзор HorizontalStackLayout

Приведенный выше макет может быть реализован с помощью следующего примера кода:

```
<Горизонтальный стекмакет
 Расстояние = "20"
 Маржа="30">
 <Граница
 BackgroundColor="Светло-серый
 Запрос ширины = "100" />
 <Граница
 ФонЦвет="Светло-Серый"
 Запрос ширины = "100" />
 <Граница
 ФонЦвет="Светло-Серый"
 Запрос ширины = "100" />
</Горизонтальный стекмакет>
```
Вы хотите расположить элементы управления вертикально, чтобы вы могли догадаться, где это
собирается, хотя на самом деле вы будете использовать его, чтобы сгруппировать некоторые из ваших внутренних
контролирует.

# Вертикальный стекмакет

Название действительно выдает это. Он позиционирует своих потомков вертикально.
VerticalStackLayout следует тем же правилам размеров, что и
HorizontalStackLayout, поэтому дети несут ответственность за расчет
их собственный размер.
И вот оно: что-то, что размещает своих дочерних элементов по вертикали,
что именно то, что вам нужно!
На рис. 5-6 показано, как можно расположить элементы управления внутри
Вертикальный стекмакет.

![изображение](https://user-images.githubusercontent.com/26972859/231121531-a4a1b9a7-a08f-45dd-a39a-cd66a1952b7c.png)
Рисунок 5-6. Обзор вертикального стека

Приведенный выше макет может быть реализован с помощью следующего примера кода:

```xml
<вертикальный стекмакет
 Расстояние = "20"
 Маржа="30">
 <Граница
 ФонЦвет="Светло-Серый"
 Запрос высоты = "100" />
 <Граница
 ФонЦвет="Светло-Серый"
 Запрос высоты = "100" />
 <Граница
 ФонЦвет="Светло-Серый"
 Запрос высоты = "100" />
</вертикальный стекмакет>
```
Давайте продолжим и создадим его. Внутри границы, которую вы добавили ранее, добавьте
следующее в файл BoardDetailsPage.xaml.

```xml
<вертикальный стекмакет>
 <вертикальный стекмакет
 Заполнение = "20">
 <Ярлык
 Текст = "Имя"
 Атрибуты Шрифта = "Полужирный" />
 <Вход />
 <Ярлык
 Текст = "Макет"
 Атрибуты Шрифта = "Полужирный" />
 <Горизонтальный стекмакет>
 <РадиоКнопка
 x:Name="Фикседрадиобуттон"
 Содержание = "Исправлено" />
 <!--<Радиокнопка
 Content="Свободная форма" /> -->
 </Горизонтальный стекмакет>
 <вертикальный стекмакет>
 <Ярлык
 Текст = "Количество столбцов"
 Атрибуты Шрифта = "Полужирный" />
 <Entry Keyboard="Числовой" />
 <Ярлык
 Текст = "Количество строк"
        Атрибуты Шрифта = "Полужирный" />
 <Entry Keyboard="Числовой" />
 </вертикальный стекмакет>
 </вертикальный стекмакет>
 <Кнопка
 Текст = "Сохранить"
 HorizontalOptions="Конец" />
</вертикальный стекмакет>
```
Да, я знаю! Я говорил о простоте визуального дерева, и здесь
вы вкладываете довольно много макетов. Я нахожу, что обычно существует некоторый уровень
Прагматизм, который необходимо применить. Эта страница по-прежнему относительно проста в
с точки зрения того, что отображается на экране, поэтому я утверждаю, что это нормально. Если
вы должны были повторить этот макет несколько раз, вам нужно было бы немного
более строгим и найти лучший способ выложить все это. Довольно часто вы найдете
что может существовать баланс между определением чего-либо, чтобы дать
лучшая производительность по сравнению с упрощением обслуживания в качестве разработчика.
Итак, вы создали свой пользовательский интерфейс, но заметите, что он не работает.
ничего, кроме как позволить пользователю вводить в поля ввода. Вам нужно связать
представление до вашей модели представления.
Это не является строго частью макетов, но стоит отметить, как вы применяете
свойство Keyboard для ваших элементов управления Entry. Это позволяет информировать
операционная система, какую программную клавиатуру отображать и, следовательно, ограничивать
тип данных, которые пользователь может ввести. Обратите внимание, что это относится только к мобильным
Приложения.


# Привязка данных

Приложения на основе пользовательского интерфейса, как следует из их названия, предполагают представление
интерфейс для пользователей. Этот пользовательский интерфейс редко представляет собой просто статическое представление и
поэтому нуждается в обновлении, вбивайте обновления в приложение или

оба. Этот процесс, как правило, управляется событиями, так как обе стороны этого процесса
синхронизация должна быть уведомлена, когда другая сторона изменяется. .СЕТЬ
MAUI завершает этот процесс для вас с помощью концепции, называемой привязкой данных.
Привязка данных позволяет связать свойства двух объектов, чтобы
что изменения в одном свойстве автоматически обновляются во втором.

# Привязка

Чаще всего создаются привязки между одним
значение в источнике и одно значение в приемнике. Цель - владелец
связываемого свойства. Я использую термины «цель» и «источник», потому что вы
не обязательно связывать только представление и модель представления. Есть
сценарии, в которых вы можете захотеть привязать один элемент управления к другому.
Прежде чем вы приступите к созданию своей первой привязки, вам нужно сначала
создать что-то для привязки. Откройте свою BoardDetailsPageViewModel
class, который является моделью представления для вашего представления, и добавьте следующее:

```Csharp
частная строка boardName;
общедоступная строка BoardName
{
 получить => имя_доски;
 set => SetProperty (ref boardName, значение);
}
```
Стоит отметить, что привязка должна быть создана для свойства
(например, определение BoardName из приведенного выше кода). Привязка к полю
(например, boardName) не будет работать.

# Контекст привязки

И, наконец, решающий шаг — установить BindingContext вашей страницы на это
просмотреть модель. В главе 4 вы сделали это, установив его непосредственно в XAML, но поскольку вы зарегистрировали свою модель представления на уровне DI,
вы можете максимально использовать это и создать модель представления и
любые зависимости, которые он имеет для вас. Откройте страницу BoardDetails.
xaml.cs и измените конструктор на

```Csharp
общедоступная страница BoardDetailsPage (BoardDetailsPageViewModel
boardDetailsPageViewModel)
{
 ИнициализироватьКомпонент();
 BindingContext = boardDetailsPageViewModel;
}
```

Приведенный выше код позволяет вам полагаться на внедрение конструктора.
функциональные возможности, предоставляемые .NET MAUI и Shell.
Действие установки свойства BindingContext означает, что любой
привязки, созданные на странице/представлении, и любые дочерние представления будут по умолчанию
против этого BindingContext.
Теперь, если вы перейдете к файлу BoardDetailsPage.xaml, вы сможете применить
привязка к вашему новому свойству BoardName в вашей модели представления. Вы хотите
чтобы изменить первую запись, которую вы добавили, чтобы она выглядела как

```Csharp
<Запись
 Text="{Binding BoardName}" />
```

Это относительно небольшое изменение, и оно будет выглядеть так же, как привязки, которые вы
созданный еще в главе 4 при изучении шаблона MVVM. Нет
много подробностей об этом, но есть достаточное количество неявного поведения, которое я чувствую
Я должен выделить. Давайте сначала рассмотрим, что он говорит вам, а затем то, что он не говорит.
Вы создаете привязку между свойством BoardName (которое
существует в вашей модели BoardDetailsPageViewModel) и свойство Text в
Входной контроль.

Теперь о том, что этот код не говорит вам.

## Путь

Привязка также может быть записана как

```Text="{Путь привязки=BoardName}"```

Элемент Path привязки подразумевается, если вы явно не
предоставьте его, но только как первую часть определения привязки. Почему я
Я тебе это говорю? Бывают случаи, когда вам нужно будет предоставить
Путь = часть.

# Режим

Я упомянул, что привязки синхронизируют два свойства друг с другом.
Когда вы создаете привязку, вы можете определить, в каком направлении будут обновляться
поток. В вашем примере вы не предоставили его, который затем полагается на
режим по умолчанию для привязываемого свойства, к которому вы привязываетесь. В этом
случае это свойство Text записи, которое имеет привязку по умолчанию
режим TwoWay. Я настоятельно призываю вас убедиться, что вы знаете об обоих
эти значения по умолчанию и ваши ожидания при создании привязки. Выбор
правильный режим также может повысить производительность. Например, OneTime
режим привязки означает, что нет необходимости отслеживать обновления. В вашей
сценария, в настоящее время вам не нужно разрешать модели представления обновлять
Свойство «Текст записи»; однако по мере продвижения эта страница также позволит
для редактирования доски, так что вы оставите его в покое. Если вам не нужно
для редактирования, теоретически вы можете изменить свою привязку на Text="{Binding
Path=BoardName, Mode=OneWay}".
Существует несколько вариантов режимов привязки:
• **По умолчанию**: как следует из названия, используется значение по умолчанию,
которое определено в целевом свойстве.

• **TwoWay**: позволяет обновлениям проходить в обоих направлениях.
между источником и целью. Типичный пример
привязка к свойству Text записи, где вы
хотите как получать ввод от пользователя, так и обновлять
пользовательский интерфейс, такой как ваш сценарий, который вы только что добавили с помощью
Entry и ее свойство Text как Text="{Binding
Путь=ИмяДоски}".

• **OneWay**: позволяет получать обновления из источника.
к цели. Примером этого является ваш ClockWidget
где вы хотите, чтобы обновления поступали только из вашего источника
к вашей цели.

• **OneWayToSource**: позволяет получать обновления из
цель к источнику. Примером этого является обязательное
свойство SelectedItem в ListView в значение
в вашей модели представления.

• **OneTime**: цель обновляется только один раз, когда
меняется контекст привязки.

## Источник

Как уже упоминалось, привязку не нужно создавать против чего-либо.
определенный в вашем коде (например, свойство в модели представления). На самом деле это может быть
создан против другого элемента управления. Если вы оглянетесь на созданный вами XAML
на этой странице вы заметите, что вы дали имя одному из RadioButtons
из FixedRadioButton. Это на самом деле настраивало вас на этот момент:
теперь вы можете привязать самую внутреннюю видимость VerticalStackLayouts к
значение этого RadioButton.

---
Если вы просто хотите разрешить пользователю дополнительно включить настройку
в пользовательском интерфейсе вместо этого можно использовать элемент управления Switch. Я выбрал
RadioButton, так как это будет очень хорошо сочетаться с вашим дополнительным заданием.
в конце этой главы.
---

```xml
<вертикальный стекмакет
 IsVisible="{Binding IsChecked, Source={x:Reference
Фиксированная радиокнопка}}">
```

---
Крепления могут быстро начать выглядеть сложными, и это хорошо.
например, но если вы разберете его, вам будет намного легче следовать.
Вы привязываете свойство IsVisible к вашему VerticalStack.
Макет свойства IsChecked из источника, который является
Ссылка на RadioButton под названием FixedRadioButton.
---

# Применение оставшихся привязок

Применим оставшиеся привязки к вашей странице и модели представления, чтобы все
поля теперь обновляют вашу модель представления.
В вашем классе BoardDetailsPageViewModel вам нужно добавить
резервные поля и свойства для привязки

```Csharp
частное логическое значение isFixed = true;
частный интервал numberOfColumns = 3;
частный интервал numberOfRows = 2;
общественное логическое значение IsFixed
{
 получить => исправлено;
 set => SetProperty (ссылка isFixed, значение);
}
публичный интервал NumberOfColumns
{
 получить => количество столбцов;
 set => SetProperty (ссылка numberOfColumns, значение);
}

общедоступный интервал NumberOfRows
{
 получить => количество строк;
 set => SetProperty (ссылка numberOfRows, значение);
}

```
Затем в вашем файле BoardDetailsPage.xaml вам нужно привязаться к этим
новые свойства с полужирными разделами ниже, выделенными вашими дополнениями.
Измените первый RadioButton на


```xml
<РадиоКнопка
 Содержание = "Исправлено"
 x:Name="Фикседрадиобуттон"
 IsChecked="{Привязка исправлена}" />
```
Затем измените запись, следующую после RadioButton, на

```xml
<Запись
 Text="{Привязка NumberOfColumns}"
 Клавиатура = "Числовой" />
```
И, наконец, измените запись, следующую за ней, на

```xml
<Запись
 Text="{Привязка NumberOfRows}"
 Клавиатура = "Числовой" />
```
# Мультисвязывание

Могут быть случаи, когда вы хотите связать несколько исходных свойств.
к одному целевому свойству в представлении. Чтобы сделать небольшой крюк, давайте переработаем
ваш ClockWidgetViewModel должен иметь два свойства: одно с датой и
один со временем. Вы должны получить следующий код (жирный
выделяет новые части):

```Csharp
пространство имен WidgetBoard.ViewModels;
открытый класс ClockWidgetViewModel : ViewModelBase
{
 частный планировщик только для чтения scheduler = new();
 частное DateOnly дата;
 личное время только время;
 публичный ClockWidgetViewModel()
 {
 УстановитьВремя(ДатаВремя.Сейчас);
 }
 публичная дата только дата
 {
 получить => дата;
 set => SetProperty (дата ссылки, значение);
 }
 публичное время только время
 {
 получить => время;
 set => SetProperty (время ссылки, значение);
 }
 private void SetTime (DateTime dateTime)
 {
 Дата = DateOnly.FromDateTime (dateTime);
 Время = ВремяТолько.ОтДатыВремя(датаВремя);
 планировщик.ScheduleAction(
 TimeSpan.FromSeconds(1),
 () =>
 {
 УстановитьВремя(ДатаВремя.Сейчас);
 });
 }
}
```
Изменение модели представления фактически открывает ряд возможностей.
возможности для вас. Вы могли бы
• Добавляйте отдельные метки для отображения информации в
разные локации.
• Используйте MultiBinding и визуализируйте обе части
информация на одной этикетке.
Именно последний вы будете использовать здесь. Откройте ваш ClockWidgetView.
xaml и внесите изменения, выделенные жирным шрифтом.

```xml
<?xml версия="1.0" кодировка="utf-8" ?>
<Ярлык
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.Views.ClockWidgetView"
 Размер шрифта = "80"
 Вертикальные опции = "Центр"
 HorizontalOptions="Центр">
 <Label.BindingContext>
 <viewmodels: ClockWidgetViewModel />
 </Label.BindingContext>
 <Метка.Текст>
 <MultiBinding StringFormat="{}{0} {1}">
 <Путь привязки = "Дата" />
 <Путь привязки="Время" />
   </MultiBinding>
 </Ярлык.Текст>
</метка>
```
Чтобы перечислить, что вы сделали здесь, у вас есть
• Удалена строка Text="{Binding Time}".
• Вышеупомянутая функциональность перемещена в
Раздел MultiBinding
Вы должны заметить, что синтаксис немного отличается от одиночной привязки.
подход. На самом деле, вы можете написать одну привязку аналогичным образом, например:

```xml
<Метка.Текст>
 <Путь привязки="Время" />
</Ярлык.Текст>
```

Тем не менее, я уверен, что вы можете оценить, что оригинал
Text="{Binding Time}" намного лаконичнее и удобнее для чтения. Каждый из
свойства, описанные в разделе «Привязка», применяются к каждому
элементов Binding в MultiBinding

---
Вы должны предоставить либо StringFormat, либо Converter в
MultiBinding или исключение. Причина этого
заключается в том, чтобы разрешить сопоставление нескольких значений с одним
значение на цели.
---

# Команда

Очень часто вам потребуется, чтобы ваши приложения реагировали на взаимодействие с пользователем.
Это можно сделать, коснувшись или щелкнув кнопку или выбрав что-либо в
список. Это взаимодействие записывается в вашем представлении, но обычно требуется
чтобы логика для обработки этого взаимодействия выполнялась в представлении
модель. Это происходит в форме команды и необязательного связанного
Набор свойств CommandParameter. Само свойство Command может быть
привязывается от представления к модели представления и позволяет модели представления не
только обрабатывать взаимодействие, но и определять, является ли взаимодействие
можно выполнить в первую очередь. Вы уже добавили кнопку в свой
BoardDetailsPage.xaml, но вы его не подключили, так что давайте сделаем именно это!
Вам просто нужно изменить свою кнопку, чтобы она была (изменения выделены жирным шрифтом)

```xml
<Кнопка
 Текст = "Сохранить"
 Горизонтальные опции = "Конец"
 Command="{Привязка SaveCommand}" />
```

Основываясь на изученном вами содержании привязки, вы можете сказать, что
это свойство команды кнопок теперь привязано к свойству в вашем представлении
модель под названием SaveCommand. Вы на самом деле не создали это свойство
еще. Если вы думаете, что было бы здорово, если бы инструменты могли это знать
и сообщите об этом мне, тогда следующий раздел поможет вам. «Составлено
Bindings» покажет вам, как информировать инструментарий о том, как сообщить об этом
ты. Однако сначала откройте файл BoardDetailsPageViewModel.cs и добавьте
реализация вашей команды.
Ваша реализация состоит из нескольких частей.
1. Вы определяете само свойство:
общественная команда SaveCommand { получить; }
Обычно вы определяете команду как свойство только для чтения
поскольку вы редко хотите, чтобы он менялся. Вы, вероятно, встретите
команды, определяемые с использованием ICommand
интерфейс, а не класс Command. Причина, по которой вы
использование последнего заключается в том, чтобы вы могли использовать конкретный
метод (см. часть 3), чтобы обновить часть вашего представления.

2. Вы определяете, какое действие будет выполнено, когда
команда выполняется (в основном, когда кнопка
постучал/щелкнул в этом сценарии).

```xml
публичный BoardDetailsPageViewModel()
{
 SaveCommand = новая команда(
 () => Сохранить(),
 () => !string.IsNullOrWhiteSpace(BoardName));
}
частная пустота Сохранить ()
{
 var board = новая доска
 {
 Имя = Имя Доски,
 Макет = новый FixedLayout
 {
 КоличествоКолонок = КоличествоКолонок,
 Количество строк = Количество строк
 }
 };
}
```

Класс Command принимает два параметра. Первый
это действие, которое нужно выполнить, когда команда
выполняется, а второй, необязательный,
способ определить, может ли команда быть
казнен. Хороший вариант использования для этого, если вы хотите
убедитесь, что пользователь ввел все необходимые
информация. В вашем сценарии вы убедитесь,
что пользователь ввел имя для доски.

3. Вы уведомляете представление, когда статус того, является ли
команда может быть выполнена изменения. Чтобы было ясно, вы
не нужно знать, что статус изменился; ты
может просто сообщить представлению, что оно должно запросить
статус. Здесь класс Command и
его метод ChangeCanExecute. Для этого
вам нужно настроить свойство BoardName на
следующий:

```Csharp
общедоступная строка BoardName
{
 получить => имя_доски;
 набор
 {
 SetProperty (ссылка имя_доски, значение);
 СохранитьКоманду.ChangeCanExecute();
 }
}
```

Это изменение означает, что каждый раз при изменении свойства BoardName
(и это будет сделано через привязку из представления), кнопка, которая
привязанная к SaveCommand, запросит проверку того,
может быть казнен. Если это возможно, кнопка будет включена, и пользователь сможет
взаимодействовать с ним; если нет, он будет отключен.

# Скомпилированные привязки

Скомпилированные привязки — отличная функция, которую следует использовать практически во всех случаях.
включать! Они помогают ускорить ваши приложения, потому что они помогают
компилятор знает, какие привязки будут установлены, и уменьшит количество
отражение, которое требуется. Отражение, как известно, плохо влияет на производительность
поэтому по возможности настоятельно рекомендуется избегать его использования. Привязки
по умолчанию используйте количество отражений, чтобы обработать значение
изменения между источником и целью. Скомпилированные привязки, как только что обсуждалось,
помогите уменьшить это, поэтому давайте научимся их включать.
Скомпилированные привязки также обеспечивают проверку во время разработки. Если вы установите
привязка к несуществующему свойству вашей модели представления (представьте, что вы
допустил опечатку, чего делаю много!), без скомпилированных привязок приложение
все равно будет строиться, но ваша привязка ничего не сделает. С скомпилированным
привязка, приложение не будет собрано, и инструментарий сообщит, что
свойство, которое вы опечатали, не существует.

```xml
<страница содержимого
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.Pages.BoardDetailsPage"
 x: DataType = "viewmodels: BoardDetailsPageViewModel">

```
Теперь, когда вы настроили свою страницу BoardDetailsPage, чтобы разрешить вход пользователя
и даже выполнять действие, когда кнопка «Сохранить» взаимодействует с вами, вы
необходимо структурировать ваше приложение, чтобы вы могли видеть, как это происходит.

# Оболочка

Оболочка в .NET MAUI позволяет вам определить, каким будет ваше приложение.
изложены не с точки зрения реальных визуальных эффектов, а путем определения таких вещей, как
вы хотите, чтобы ваши страницы просматривались во вкладках или только по одной странице за раз. Это также
позволяет вам определить всплывающее меню, которое является боковым меню в вашем приложении.
Вы можете сделать так, чтобы он всегда был виден, или переключать его, чтобы он скользил вперед/назад, и это
также может варьироваться в зависимости от типа устройства, на котором вы работаете. Обычно
рабочий стол имеет больше визуального пространства, поэтому вы можете сохранить всплывающее окно
тогда всегда открыты.

Для вашего приложения вы собираетесь использовать всплывающее окно, позволяющее
вам определить несколько досок, которые вы можете настроить и загрузить. я действительно
нравится идея иметь одну доску, когда я работаю, а затем переключаться на
что-то еще при работе над побочным проектом или даже для игр.
Чтобы не возвращаться в эту область и менять биты, вы собираетесь
сразу переходите к более подробному варианту и многофункциональному результату.
Однако не волнуйтесь; открывая для себя каждую новую концепцию, вы будете погружаться
в некоторые подробности, чтобы рассказать, что это такое и почему вы используете вместе с
применяя эту концепцию к вашему приложению.

## Содержимое оболочки

Если вы посмотрите на свой файл AppShell.xaml, вы увидите очень мало
внутри. В настоящее время он имеет следующую строку:

```xml
<ShellContent
 Заголовок = "Главная"
 ContentTemplate="{DataTemplate local:MainPage}"
 Маршрут = «Главная страница» />

```
Этот код устанавливает основное содержимое приложения как экземпляр
главная страница. На самом деле, вы хотите удалить эту строку и заменить ее на

```xml
<ShellContent
 ContentTemplate="{Страницы DataTemplate:BoardDetailsPage}" />
```
Здесь нет большой разницы, но вы должны изучить, что
это значит.
Основное содержимое вашего приложения теперь будет экземпляром вашего
недавно созданный BoardDetailsPage. Вам не нужен заголовок или маршрут
вариантов больше, так как вы будете контролировать их по-разному.
Свойство Title будет установлено на основе отображаемой страницы, поэтому вы
узнаете об этом чуть позже.

Свойство Route, которым вы будете управлять в рамках следующего раздела,
«Навигация».
Наконец, вам нужно будет добавить ```xmlns:pages="clrnamespace:WidgetBoard.Pages"`` в начало файла.

# Навигация

Лично я сторонник упрощения кода, который я пишу, пока он продолжается.
чтобы было легко читать. Имея это в виду, я хотел бы предложить вам
улучшите уже регистрацию своих страниц и их модели просмотра.

## Регистрация страниц для навигации

Поэтому я предлагаю вам создать новый метод в вашей программе MauiProgram.
cs-файл.

```Csharp
частный статический IServiceCollection AddPage<TPage, TViewModel>(
 службы IServiceCollection,
 строковый маршрут)
 где TPage : Страница
 где TViewModel: BaseViewModel
{
 услуги
 .AddTransient (тип (TPage))
 .AddTransient (тип (TViewModel));
 Routing.RegisterRoute(route, typeof(TPage));
 услуги возврата;
}
```
Обратите внимание на строку Routing.RegisterRoute(route, typeof(TView));.
Это служит очень важной частью в этой теме навигации. Это значит
что когда вы указываете Shell перейти к определенному маршруту, он создаст новый

экземпляр типа TPage, который вы передали, и перейдите к нему. Конечно,
потому что вы зарегистрировали эти типы с внедрением зависимостей
слой, это означает, что любые зависимости, определенные как параметры для
конструктор будет создан и передан для вас.
Вышеприведенное означает, что вместо того, чтобы писать

```Csharp
services.AddTransient<BoardDetailsPage>()
services.AddTransient<BoardDetailsPageViewModel>()
Routing.RegisterRoute(route, typeof(TPage));

```
теперь ты можешь написать

```Csharp
AddPage<BoardDetailsPage, BoardDetailsViewModel>(builder.
Услуги, "доска деталей");
```
с добавленным изменением, которое вы теперь определяете для этого маршрута. Итак, пойдем и
удалите свои старые регистрации и замените на

```Csharp
AddPage<BoardDetailsPage, BoardDetailsPageViewModel>(builder.
Услуги, "доска деталей");
AddPage<FixedBoardPage, FixedBoardPageViewModel>(builder.
Услуги, "фиксированная доска");

```
Я также рекомендую где-то определять маршруты как постоянные строки.
в вашей кодовой базе, чтобы избежать опечаток при переходе к ним.
Это означает, что вы можете сохранить одну строку кода на странице и просмотреть модель.
пару, которую вы зарегистрировали, а также код для регистрации маршрута для
навигация.
Теперь, когда вы зарегистрировали свои страницы, давайте посмотрим, как вы
может выполнять навигацию.

# Выполнение навигации

Существует несколько способов указать маршрут для навигации, но все они используют
метод Shell.Current.GoToAsync.

Так, например, вы можете перейти на свою страницу FixedBoardPage с помощью
следующий:

```Csharp
await Shell.Current.GoToAsync («фиксированная доска»);
```

Это приведет к созданию FixedBoardPage и перемещению его на
стек навигации. Это именно то поведение, которое вам нужно в конце
ваше выполнение SaveCommand в вашем классе BoardDetailsPagesViewModel.

# Навигация назад

Вы также можете извлекать страницы из стека навигации, перемещаясь назад.
Этого можно достичь следующим образом:

```Csharp
ожидание Shell.Current.GoToAsync("..");
```
с компонентом .., сообщающим Shell, что ему нужно вернуться назад. Фактически,
Навигация назад и вперед может выполняться вместе:

```Csharp
await Shell.Current.GoToAsync("../board");
```

# Передача данных при навигации

Одна ключевая вещь, которую вам действительно нужно сделать при создании доски
и переход на страницу, которая будет отображать доску, должен передать контекст
на эту страницу, чтобы он знал, что отображать. Есть несколько способов
как отправлять данные, так и получать их.
Начнем с отправки.
• Вы можете передавать примитивные данные через строку запроса
себе, например
```Csharp
await Shell.Current.GoToAsync("fixedboard?boardid=1234");
```
Предоставляя boardid, вы возлагаете ответственность на
принимающая страница (или модель просмотра страницы) для получения
правая доска, используя указанный ID

• Более сложные данные могут быть отправлены в виде
IDictionary<string, object> в
Метод GoToAsync, например

```Csharp
ожидание Shell.Current.GoToAsync(
 "фиксированная доска",
 новый словарь<строка, объект>
 {
 { "Доска", доска}
 });
```
Вы также можете отправить сложный объект, как показано выше, что означает
исходная страница (или модель просмотра страницы) отвечает за получение или
строите доску, и вы отправляете все это на принимающую страницу.
Затем для получения данных можно реализовать IQueryAttributable
интерфейс, предоставляемый .NET MAUI. Shell либо вызовет это на
страница, на которую вы переходите, или если BindingContext (ваш вид
model) реализует интерфейс, он будет вызывать его там. Добавьте это в свой
класс FixedBoardPageViewModel, потому что вам нужно будет обработать
данные. Вы будете использовать вариант сложного объекта, потому что вы
уже загрузили Board в свой класс AppShellViewModel.

```Csharp
public void ApplyQueryAttributes(IDictionary<string,
объект > запрос)
{
 var board = query["Доска"] as Board;
}
```
Вы пока ничего не собираетесь делать с этими данными, но они уже готовы.
когда вы начнете строить вид макета платы в следующей главе.
А пока вы продолжите тему «Шелл» и определите свою
всплывающее меню.
Вам также нужно будет реализовать свою модель FixedBoardPageViewModel.
интерфейс IQueryAttributable. Измените определение класса с

```Csharp
открытый класс FixedBoardPageViewModel: BaseViewModel
к следующему (изменения выделены жирным шрифтом):
открытый класс FixedBoardPageViewModel: BaseViewModel,
IQueryAttributable
```

# Вылететь

Всплывающее меню — это меню для приложения Shell, доступное через
значок или проведя пальцем от края экрана. Всплывающее окно может состоять из
необязательный заголовок, всплывающие элементы, необязательные элементы меню и необязательный нижний колонтитул.
Для вашего приложения вы собираетесь предоставить базовый заголовок, а затем
основным контентом будет динамический список всех досок, которые создает ваш пользователь.
Это означает, что вам придется переопределить основной контент, но
К счастью, Shell упрощает эту задачу.
Первое, что мне нравится делать при работе с новым XAML-файлом, — это
на скомпилированных привязках, о которых я рассказывал ранее. Если вы помните, это по
указав атрибут x:DataType, чтобы сообщить компилятору тип, который
представление будет привязано к. Давайте сделаем это сейчас (выделено жирным шрифтом):

```xml
<?xml версия="1.0" кодировка="UTF-8" ?>
<Оболочка
 x:Class="WidgetBoard.AppShell"
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 x: DataType = "вьюмоделс: AppShellViewModel">
```

Это поможет вам, когда вы строите представление, видеть то, чего нет в вашем
просмотреть модель. Конечно, если вы предпочитаете сначала построить модель представления, то это
также помогает.
Наконец, вам нужно добавить xmlns:viewmodels="clrnamespace:WidgetBoard.ViewModels" в начало файла.

# Заголовок всплывающего окна

FlyoutHeader может иметь любой элемент управления или макет, и поэтому вы
может создать действительно красивый вариант заголовка. Для вашего приложения вы
просто добавим заголовок Label.
Ниже вашего элемента ShellContent вы хотите добавить следующее:

```xml
<Shell.FlyoutHeader>
 <Ярлык
 Текст="Мои доски"
 Размер шрифта = "20"
 HorizontalTextAlignment="По центру" />
</Shell.FlyoutHeader>

```

Надеюсь, вышеизложенное не требует пояснений, но чтобы охватить те части, которые я
еще не охвачены, у вас есть возможность указать другой макет
информацию в метке, чтобы вы могли сделать текст по центру. Это обычно
рекомендуется использовать свойство HorizontrolOptions поверх
свойство HorizontalTextAlignment; однако, если вы попробуете это здесь, вы
убедитесь, что он не центрирует метку.
Теперь давайте добавим в основную часть вашего меню.

# Выпадающее содержимое

Во-первых, если вы хотите использовать статический набор элементов в своем меню, вы можете просто
добавить FlyoutItems к содержимому. Это может хорошо работать, когда у вас есть фиксированный
набор страниц, таких как «Настройки», «Главная» и т. д. Вы будете показывать

доски, которые создает пользователь, поэтому вам понадобится что-то динамичное. Для этого
вам необходимо предоставить FlyoutContent. Что еще более важно, это ваш первый
введение в элемент управления CollectionView.
CollectionView позволяет определить, как элемент будет выглядеть и
затем повторите это для каждого элемента в коллекции, которая привязана к нему.
Кроме того, CollectionView предоставляет возможность разрешить пользователю
для выбора элементов в коллекции, и вы можете определить поведение, которое будет
выполняться, когда этот выбор происходит. Добавим в
ваша оболочка:

```xml
<Shell.FlyoutContent>
 <КоллекцияВид
 ItemsSource="{Доски для привязки}"
 Режим Выбора = "Одиночный"
 SelectedItem="{Привязка CurrentBoard}">
 <CollectionView.ItemTemplate>
 <DataTemplate x:DataType="models:Board">
 <Ярлык
 Text="{Имя привязки}"
 Размер шрифта = "20"
 Заполнение = "10,0,0,0" />
 </Шаблон Данных>
 </CollectionView.ItemTemplate>
 </ПросмотрКоллекции>
</Shell.FlyoutContent>
```
Вам также необходимо добавить xmlns:models="clr-namespace:WidgetBoard.
Модели" в начало файла.
Ваш FlyoutContent будет отображать метку, установленную для имени каждой доски.
экземпляр в коллекции досок в вашей модели представления. Кроме того,
Свойство CurrentBoard в вашей модели представления будет обновлено, когда пользователь
выбирает одну из меток в этой коллекции.

Если вы добавили все части, которые я обсуждал, вы, вероятно, заметите
что инструментарий сообщает, что вы не добавили ни одного из свойств
к которому вы привязываетесь в своей модели представления. Перейдем к твоему
AppShellViewModel.cs и добавьте следующее

# Коллекция досок

```Csharp
public ObservableCollection<Board> Boards { get; } = новый
ObservableCollection<Board>();
```

ObservableCollection — это особый тип коллекции,
реализует INotifyCollectionChanged. Это означает, что что-либо
привязанный к нему, будет отслеживать изменения в коллекции и обновлять ее содержимое
на экране.
Кроме того, сейчас вы добавите фиксированную запись в эти доски.
Коллекция, с которой можно взаимодействовать. Позже вы будете сохранять в
и загрузка из базы данных.

```Csharp
публичная модель AppShellViewModel()
{
 Доски.Добавить(
 новая доска
 {
 Имя = "Моя первая доска",
 Макет = новый FixedLayout
 {
 КоличествоКолонок = 3,
 Количество строк = 2
 }
 });
}
```

# Выбранная доска

Вы привязываете свойство SelectedItem из CollectionView к вашему
Свойство CurrentBoard. Когда ваше свойство изменится, вы можете перейти к
плата, которая была выбрана.

```Csharp
частная доска currentBoard;
общественная доска CurrentBoard
{
 получить => текущая доска;
 набор
 {
 если (SetProperty (ссылка currentBoard, значение))
 {
 BoardSelected(значение);
 }
 }
}
```
Вы, возможно, помните, что в главе 4 я обсуждал потенциальную ценность
SetProperty возвращает логическое значение. Вы наконец нашли применение
это! Вы хотите обрабатывать изменение выбора доски только в том случае, если CurrentBoard
свойство действительно изменилось.

# Переход к выбранной доске

Следуя предыдущему разделу «Навигация», вы перейдете к
route «fixedboard», на который настроена ваша FixedBoardPage. Вы будете
также передайте выбранную доску, чтобы ее можно было представить на экране.

```Csharp
private async void BoardSelected (доска)
{
 ожидание Shell.Current.GoToAsync(
   "фиксированная доска",
 новый словарь<строка, объект>
 {
 { "Доска", доска}
 });
}
   
```
Прежде чем ваши привязки заработают, вам нужно сделать еще несколько
изменения.

# Настройка BindingContext вашего AppShell

Давайте изменим конструктор вашего файла AppShell.xaml.cs, чтобы установить
Контекст привязки.

```Csharp
публичная оболочка AppShell (AppShellViewModel appShellViewModel)
{
 ИнициализироватьКомпонент();
 BindingContext = appShellViewModel;
}
```

Вы должны помнить, что вы добавили AppShellViewModel в качестве переходного
в файле MauiProgram.cs, что означает, что вам будет предоставлен новый
экземпляр, когда ваш класс AppShell создается для вас.

# Зарегистрируйте AppShell в MAUI App Builder

Давайте зарегистрируем AppShell в вашем файле MauiProgram.cs.
```builder.Services.AddTransient<AppShell>();```

# Разрешить AppShell вместо его создания

Измените конструктор в файле App.xaml.cs следующим образом:

```Csharp
общедоступное приложение (AppShell appShell)
{
 ИнициализироватьКомпонент();
 Главная страница = оболочка приложения;
}
```
Все вышеперечисленные изменения позволяют вам использовать AppShell так же, как и любой другой
страницу и не нужно создавать экземпляр вручную

# Вкладки

Стоит отметить, что Шелл предлагает вам больше функциональности, чем вы на самом деле
потребность в создании этого приложения.
Shell позволяет создавать панели вкладок в вашем приложении. Вы можете иметь
снизу, сверху или и то, и другое, чтобы дать гибкость в том, как вы размещаете свой контент. Ты
иметь контроль над стилем и навигацией внутри каждой из вкладок.
Я не буду прикрывать вкладки, но я настоятельно рекомендую проверить
документация предоставлена ​​корпорацией Майкрософт по адресу https://learn.microsoft.com/
dotnet/maui/основы/оболочка/вкладки.

# Поиск

Поиск — еще одна полезная функция, которая входит в состав Shell, но опять же
не то, что вам нужно в этом приложении. Shell позволяет создавать
свой собственный SearchHandler, что означает, что вы можете определить, как результаты
встречаются со значениями, введенными в поле поиска, которое автоматически
предоставил. Вы даже можете определить макет результатов поиска и
поведение при выборе элемента в результатах поиска.
Я не буду охватывать поиск, но я настоятельно рекомендую проверить
документацию, предоставленную Microsoft по адресу https://learn.microsoft.
com/dotnet/maui/fundamentals/shell/search.

# Принимаем ваше приложение на раскрутку

Если вы запустите приложение, вы увидите, что вам сначала представлен
экран, чтобы создать новую доску. Вы можете ввести данные и нажать Сохранить.
На рис. 5-7 показано, как выглядит ваше приложение при первой загрузке.

![изображение](https://user-images.githubusercontent.com/26972859/231130136-66d65bb4-ce9a-48fc-ac8a-ecc64796f8d8.png)
Рисунок 5-7. Домашняя страница приложения

Или вы можете выдвинуть меню с левой стороны. Рисунок 5-8
показывает всплывающее меню в вашем приложении.

![изображение](https://user-images.githubusercontent.com/26972859/231130290-4a976a6e-6a72-47da-89ef-2a669ed52266.png)
Рисунок 5-8. Выпадающее меню приложения

Выбрав доску или нажав «Сохранить», вы перейдете к
ваша страница FixedBoardPage. На рис. 5-9 показано, как отображается ваша страница FixedBoardPage.
с содержимым по умолчанию. Это потому, что вы не подключили плату
объект, который вы получаете, но это доказывает, что ваша навигация и Shell
установка работает

![изображение](https://user-images.githubusercontent.com/26972859/231130422-20a5c724-8453-47e0-8ae1-638ff6528c76.png)
Рисунок 5-9. Страница фиксированной доски после навигации


# Краткое содержание

В этой главе вы
• Создал и применил значок для вашего приложения
• Добавлено несколько страниц-заполнителей и моделей просмотра.
• Заполнили вашу первую страницу некоторыми привязками пользовательского интерфейса и настройки.
к модели представления
• Скрытая привязка данных и множество ее применений.
• Получил понимание XAML
• Узнали о возможных макетах, которые вы можете использовать для
сгруппировать другие элементы управления
• Приобрел понимание Shell и применил это к
построение структуры вашего приложения
• Применена навигация Shell, чтобы вы могли перейти к
Ваша следующая страница и следующая глава
• Создали свое всплывающее меню, используя все знания, полученные в
эта глава
В следующей главе вы будете
• Создайте свой собственный макет.
• Используйте различные параметры при добавлении
характеристики.
• Обеспечьте поддержку команд из вашего макета.
• Используйте свой макет в своем приложении.

# Исходный код

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introduction-MAUI/tree/
основной/ch05.

# Дополнительное задание

В качестве дополнительного задания я бы хотел, чтобы вы подумали, как бы вы могли добавить
второй тип макета, учитывая, что вы
• Иметь один тип макета на странице BoardDetailsPage.
• Отображать параметры при выборе этого типа
• Передать экземпляр FixedLayout в качестве данных вашему
FixedBoardPage
Я хотел бы видеть, какие концепции вы придумываете.
























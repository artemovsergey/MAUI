# ГЛАВА 6

# Создание собственного макета

В предыдущей главе вы узнали много об основах построения
и связывание ваших пользовательских интерфейсов. В этой главе вы создадите свой собственный
макет, используйте различные параметры при добавлении связываемых свойств,
обеспечить поддержку команд из вашего макета и использовать ваш макет
в вашем приложении. Это послужит основой для добавления гораздо большего
функциональность, так как мы рассмотрим различные темы в будущих главах.
Давайте вспомним, чего вы достигли в предыдущей главе: вы обеспечили
возможность для пользователя создать доску и указать количество столбцов и
ряды. Теперь вам нужно выложить доску с количеством столбцов.
и строки, настроенные пользователем, и заполните виджеты на доске.
На рис. 6.1 показан пример того, чего вы достигнете к концу этой главы.

![изображение](https://user-images.githubusercontent.com/26972859/231163936-8e925696-fdec-49e7-b357-8a514af45bc2.png)
Рисунок 6-1. Макет доски

В конце предыдущей главы я обсуждал идею создания второго
тип макета в разделе «Дополнительное задание». Чтобы продолжить это
теме, я структурировал архитектуру макета, чтобы помочь в этом.
путешествие. Я сторонник такого подхода, потому что он позволяет вам
потенциально заменить одну часть реализации, не затрагивая
другие.
BoardLayout будет отвечать за отображение виджетов. Это будет
назначена реализация ILayoutManager, которая будет решать, где
разместить виджеты. Вы будете добавлять FixedLayoutManager, чтобы решить
эта часть

# Заполнитель
Первый элемент, который вам нужно создать, — это заполнитель, показывающий, где
виджет будет размещен. В этом элементе управления не так уж много, но его создание
позволяет сгруппировать все связанные фрагменты вместе. Рисунок 6-2
показывает, как будет выглядеть ваш элемент управления Placeholder при отображении внутри
приложение.

![изображение](https://user-images.githubusercontent.com/26972859/231164282-09388fa3-3f7c-4816-bcd4-62c45345ca51.png)
Рисунок 6-2. Макет элемента управления Placeholder

Чтобы добиться вышеуказанного вида, вы собираетесь использовать
Пограничный контроль. Это действительно полезный элемент управления. Он позволяет вам предоставлять

границы, настраиваемый радиус угла, тени и другие параметры стиля. Это также
ведет себя так же, как ContentView в том, что он может содержать один дочерний элемент
контроль.
Создайте папку Controls в своем основном проекте. В нем будет размещаться
Контроль заполнителей и, возможно, больше, когда вы создаете свое приложение.
Затем добавьте в папку новый класс и назовите его Placeholder. Обратите внимание, что
вы решили создать элемент управления исключительно на C# без XAML; главный
причина в том, что это приводит к меньшему количеству кода. Я всегда нахожу, что никогда не бывает ни одного
способ создания вещей, и даже если вам нравится XAML, временами он ничего не добавляет.
значение, как и в этом сценарии. Конечно, если вы предпочитаете создавать свой пользовательский интерфейс с помощью
XAML, вы можете это сделать.

```Csharp
пространство имен WidgetBoard.Controls;
открытый класс Заполнитель: Граница
{
 общедоступный заполнитель ()
 {
 Контент = новый ярлык
 {
 Text = "Нажмите, чтобы добавить виджет",
 FontAttributes = FontAttributes.Italic,
 HorizontalOptions = LayoutOptions.Center,
 VerticalOptions = LayoutOptions.Центр
 };
 }
 публичная позиция {получить; набор; }
}
```
Как уже говорилось, в этой реализации не так уж много, но давайте все же
Сломай. Здесь у вас есть

- Создан элемент управления, наследуемый от Border
- Установите содержимое вашего элемента управления как метку, показывающую
фиксированный текст курсивом и текст выравнивается по центру
горизонтально и вертикально
- Добавлено свойство Position, чтобы знать, где в макете
он будет расположен

Теперь вы можете приступить к созданию макета, который будет отображать заполнители.
и, в конечном счете, ваши виджеты.

# ILayoutManager

Здесь у вас есть небольшой сценарий курицы и яйца. Вам необходимо создать
доска и менеджер компоновки, оба из которых должны знать друг о друге;
поэтому давайте сначала добавим части LayoutManager.
Цель интерфейса ILayoutManager — определить, как
BoardLayout будет взаимодействовать с реализацией менеджера компоновки.
Создайте папку под названием Layouts в вашем основном проекте. В нем будет размещаться
Интерфейс ILayoutManager и многое другое при создании приложения.
Затем добавьте в папку новый класс и назовите его ILayoutManager.

```Csharp
пространство имен WidgetBoard.Layouts;
открытый интерфейс ILayoutManager
{
 объект BindingContext { получить; набор; }
 Доска BoardLayout { получить; набор; }
 void SetPosition (BindableObject bindableObject, int
позиция);
}
```

Давайте разберем это, чтобы у вас было четкое определение того, что вы только что
созданный:
• Свойство BindingContext позволяет передавать
контекст из BoardLayout позже. Это
важно для разрешения привязок в менеджере компоновки.
• Свойство Board позволяет менеджеру взаимодействовать
непосредственно с доской он призван помочь.
• Метод SetPosition позволяет менеджеру использовать
параметр position и установите соответствующий макет
настройки виджета/заполнителя.

# Макет платы

Ваш BoardLayout будет родителем ваших виджетов. Создать макет
внутри папки «Макеты».
• Щелкните правой кнопкой мыши папку «Макеты».
• Выберите «Добавить» ➤ «Новый элемент».
• Выберите вкладку .NET MAUI.
• Выберите параметр .NET MAUI ContentView (XAML).
• Введите имя BoardLayout.
• Щелкните Добавить.
Это даст вам два файла. Вы будете изменять каждый по отдельности

# BoardLayout.xaml

Измените существующее содержимое на следующее:

```xml
<?xml версия="1.0" кодировка="utf-8" ?>
<Сетка
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 x:Class="WidgetBoard.Layouts.BoardLayout"
 х: имя = "я">
 <Сетка
 x:Name="PlaceholderGrid" />
 <Сетка
 х:Имя="Сетка Виджетов"
 ChildAdded="Виджеты_ChildAdded"
 BindableLayout.ItemsSource="{Источник элементов привязки,
Источник={x:Ссылка на себя}}"
 BindableLayout.ItemTemplateSelector="{Привязка
ItemTemplateSelector, Source={x:Reference self}}"
 ИнпутПрозрачный="Истина"
 CascadeInputTransparent="Ложь" />
</сетка>
```

Вы добавили к этому совсем немного, что может показаться незнакомым, так что еще раз
давайте сломать его.
Ваш основной макет представляет собой сетку, а внутри нее еще две сетки.
В первую внутреннюю сетку (PlaceholderGrid) вы добавляете
Элемент управления-заполнитель, который вы создали ранее в этой главе.
Во вторую внутреннюю сетку (WidgetGrid) вы добавляете виджеты. 
Причина, по которой вы построили элемент управления таким образом, в основном заключается в том, что вы можете использовать
действительно впечатляющая часть функциональности, которая резко уменьшает количество
кода, который вы должны написать: BindableLayout.

---
Вы не предоставили Grid.Row или Grid.Column ни одному из
ваши внутренние Решетки. Это приводит к тому, что оба элемента управления заполняют пространство
родительская сетка, а вторая перекрывает первую. Это поведение
может обеспечить реальную мощь при создании довольно сложных пользовательских интерфейсов.
---

# BindableLayout

BindableLayout позволяет превратить элемент управления макетом в элемент управления,
может быть заполнен набором данных. BindableLayout не является элементом управления
само по себе, но предоставляет возможность улучшить элементы управления макетом, добавив
Свойство ItemsSource для привязок. Это означает, что все макеты
о которых вы узнали в предыдущей главе (например, Grid, AbsoluteLayout,
FlexLayout, HorizontalStackLayout, VerticalStackLayout) могут быть
превратился в макет, который может отображать определенный набор элементов управления для каждого элемента
это предусмотрено. Для этого нужно установить два свойства:
• BindableLayout.ItemsSource: это коллекция
элементы, которые вы хотите представить в пользовательском интерфейсе.
• BindableLayout.ItemTemplate или BindableLayout.
ItemTemplateSelector: позволяет определить
как предмет будет представлен. В большинстве сценариев
ItemTemplate достаточно, но это работает только тогда, когда вы
иметь один тип элемента для отображения в вашей коллекции. Если
у вас есть несколько типов, каждый виджет будет отдельным
введите свое приложение, поэтому вам нужно использовать
Селектор шаблонов элементов.
На самом деле я пока не буду предоставлять исходный код для этих привязок; этот
будет сделано в Главе 8. Сейчас вам просто нужно сделать возможным
связать их.

# BoardLayout.xaml.cs

Теперь, когда вы создали XAML-представление, вам нужно добавить
код программной части, который будет работать с ним. Мы немного проследим
разный подход к этому и следующему разделу; у тебя много кода
добавить сейчас, поэтому вы будете добавлять его поэтапно, и мы поговорим о том, что вы
добавляют.
Исходный код должен выглядеть следующим образом:

```Csharp
пространство имен WidgetBoard.Layouts;
общедоступный частичный класс BoardLayout
{
 общедоступный BoardLayout ()
 {
 ИнициализироватьКомпонент();
 }
}
```

# Добавление свойства LayoutManager

Вы хотите, чтобы потребитель вашего элемента управления BoardLayout мог
предоставить LayoutManager, который будет контролировать размещение виджетов. Для
это, вам нужно добавить следующее:

```Csharp
частный ILayoutManager layoutManager;
общедоступный ILayoutManager
{
 получить => layoutManager;
 набор
 {
 layoutManager = значение;
 layoutManager.Board = это;
 }
}
```

Ключевой деталью этой реализации является то, как она назначает правление
свойство в LayoutManager для вашего элемента управления BoardLayout. Это для
разрешить менеджеру взаимодействовать с макетом.
Одна очень важная вещь, которую следует учитывать, заключается в том, что при создании
свойств, которые можно задать в XAML, их установщики можно вызывать перед вашим
элемент управления имеет установленное свойство BindingContext. Поэтому обычно требуется
для обработки обоих сценариев при использовании обеих частей функциональности. К
приведите конкретный пример этого, у вас есть свойство LayoutManager
что вы добавили. Это также позволит вам установить привязки к нему, но не
передать BindingContext. Для этого нужно переопределить
OnBindingContextChanged в вашем классе BoardLayout и назначьте
значение для вашего LayoutManager.

```Csharp
защищенное переопределение void OnBindingContextChanged()
{
 base.OnBindingContextChanged();
 layoutManager.BindingContext = this.BindingContext;
}
```
В прошлом я обнаружил, что при построении элементов управления таким образом, даже если
вам не нужно использовать этот метод для фактической реализации, он может
быть действительно удобным для отладки того, что происходит, когда что-то не так
ожидал. Например, вы можете поставить точку останова, чтобы убедиться, что вы
присваивается BindingContext и что он имеет правильный тип.

# Добавление свойства ItemsSource

Ваш BoardLayout также должен принимать набор виджетов, которые
в конечном итоге будет отображаться на экране. Для элементов управления, поддерживающих

```Csharp
использование System.Collections;
```
Это позволяет вам использовать тип IEnumerable.

```Csharp
public static readonly BindableProperty ItemsSourceProperty =
 BindableProperty.Создать(
 имя (Источник Элементов),
 тип (IEnumerable),
 typeof(BoardLayout));
 общедоступный IEnumerable ItemsSource
{
 получить => (IEnumerable) GetValue (ItemsSourceProperty);
 set => SetValue (ItemsSourceProperty, значение);
}
```
В большинстве сценариев вы привязываете ObservableCollection к
свойство ItemsSource, которое имеет тип, отличный от IEnumerable. К
решив использовать IEnumerable, он позволяет потребителям вашего макета
предоставить любой тип, который поддерживает хранение нескольких элементов. Это значит, что
вы можете предоставить ObservableCollection или список.
Наконец, вам нужно добавить оператор using в ваш BoardLayout.
файл xaml.cs вверху.

```Csharp
использование System.Collections;
```
# Добавление свойства ItemTemplateSelector

Теперь, когда у вас есть набор элементов для отображения на экране, вы
нужно уметь их отображать. Часто можно увидеть элементы управления
которые имеют свойство ItemsSource, также имеют ItemTemplate или
ItemTemplateSelector или даже оба свойства. ItemTemplate позволяет
разработчик, чтобы определить, как будет отображаться каждый элемент в ItemsSource
на экране. Причина, по которой вы не используете этот подход, заключается в том, что вы можете
определить только один шаблон для всех элементов. Вы будете привязывать свой виджет
просматривать модели в свойстве ItemsSource, что означает, что у вас будет
несколько разных представлений, которые вы хотите отобразить. Вот где
Появляется свойство ItemTemplateSelector.

```Csharp
public static только для чтения BindableProperty
ItemTemplateSelectorProperty =
 BindableProperty.Создать(
 nameof(ItemTemplateSelector),
 typeof(DataTemplateSelector),
 typeof(BoardLayout));
общедоступный DataTemplateSelector ItemTemplateSelector
{
 get => (DataTemplateSelector) GetValue (ItemTemplateSelector
Свойство);
 set => SetValue (ItemTemplateSelectorProperty, значение);
}
```

Вы используете тип DataTemplateSelector для своего свойства
здесь. Вы создадите реализацию немного позже в этой главе, но для
теперь он позволяет переопределить метод OnSelectTemplate и предоставить
подходящий шаблон для передаваемого элемента.

# Обработка события ChildAdded

Ранее я обсуждал, как функция BindableLayout позволяет вам заполнять
элемент управления с несколькими представлениями на основе привязок. Вам нужно подключиться к
событие ChildAdded, чтобы ваша реализация LayoutManager могла
определить, где должен располагаться новый ребенок.

```Csharp
private void Widgets_ChildAdded (отправитель объекта,
ElementEventArgs e)
{
 если (e.Element - это IWidgetView widgetView)
 {
 LayoutManager.SetPosition(e.Element, widgetView.
Позиция);
 }
}
```
Этот обработчик проверяет, относится ли новый добавляемый дочерний элемент к
IWidgetView, и если это так, он делегирует LayoutManager
реализация для установки позиции виджета.

# Добавляем оставшиеся биты

У вас есть несколько дополнительных методов и свойств для добавления, которые будут использоваться
с помощью FixedLayoutManager. Давайте добавим их и обсудим их назначение
как вы идете.
Добавьте оператор using в начало файла.

```Csharp
с помощью WidgetBoard.Controls;
```
Затем добавьте первый новый метод.

```Csharp
public void AddPlaceholder (заполнитель-заполнитель) =>
PlaceholderGrid.Children.Add(заполнитель);
```
Этот метод позволяет вызывающей стороне передать заполнитель, который будет добавлен
в PlaceholderGrid. Это полезно при первой загрузке доски или при
работа с виджетом, удаляемым из определенной позиции.

```Csharp
public void RemovePlaceholder (заполнитель-заполнитель) =>
PlaceholderGrid.Children.Remove (заполнитель);
```
Этот метод позволяет вызывающей стороне передать заполнитель, который будет
удален из PlaceholderGrid. Это полезно при работе с
виджет добавляется в определенную позицию.

```Csharp
public void AddColumn (ColumnDefinition columnDefinition)
{
 PlaceholderGrid.ColumnDefinitions.Add(columnDefinition);
 WidgetGrid.ColumnDefinitions.Add(columnDefinition);
}
```
Этот метод позволяет определить столбцы доски как на
PlaceholderGrid и WidgetGrid.

```Csharp
public void AddRow (RowDefinition rowDefinition)
{
 PlaceholderGrid.RowDefinitions.Add(rowDefinition);
 WidgetGrid.RowDefinitions.Add(rowDefinition);
}
```
Этот метод позволяет определить строки доски как на
PlaceholderGrid и WidgetGrid.

```Csharp
public IReadOnlyList<Placeholder> Заполнители =>
PlaceholderGrid.Children.OfType<Placeholder>().ToList();
```
Это свойство предоставляет все дочерние элементы из PlaceholderGrid, которые
типа Заполнитель. Это позволяет определить, какой заполнитель
необходимо удалить при добавлении виджета.

# Менеджер фиксированного макета

Последняя часть, которую вам нужно создать, — это класс FixedLayoutManager. Это будет
предоставить логику для
• Принять количество строк и столбцов для доски.
• Обеспечьте поддержку нажатия/щелчка с помощью команды.
• Создайте макет платы.
• Установите правильную позицию строки/столбца для каждого виджета.
Создайте файл, а затем вы можете добавить каждый из
вышеуказанные части функциональности. Давайте добавим новый файл класса и назовем его
ФиксированныйLayoutManager.cs. Добавьте следующее содержимое:

```Csharp
пространство имен WidgetBoard.Layouts;
открытый класс FixedLayoutManager
{
}
```
Для начала вам нужно добавить следующие операторы using:

```Csharp
используя System.Windows.Input;
с помощью WidgetBoard.Controls;
```
А также сделайте так, чтобы ваш класс наследовался от BindableObject и реализовывал
ваш интерфейс ILayoutManager. Теперь ваш класс должен выглядеть следующим образом:

```Csharp
используя System.Windows.Input;
с помощью WidgetBoard.Controls;

пространство имен WidgetBoard.Layouts;
открытый класс FixedLayoutManager: BindableObject,
ILayoutManager
{
}
```
Причина наследования от BindableObject заключается в том, что
что вам нужно добавить некоторые связываемые свойства в этот класс, чтобы
разработчики, использующие эту реализацию, могут привязывать значения к свойствам.

# Принятие количества строк и столбцов для доски

Вам нужно добавить возможность установить количество строк и столбцов, которые будут
отображается на вашей доске с фиксированным макетом. Для этого вы добавите два
привязываемые свойства к вашему классу FixedLayoutManager.

# Добавление свойства NumberOfColumns

```Csharp
public static только для чтения BindableProperty
ЧислоКолонокСвойство =
 BindableProperty.Создать(
 имя (количество столбцов),
 тип (целое число),
 тип (FixedLayoutManager),
 defaultBindingMode: BindingMode.OneWay,
 свойство изменено: OnNumberOfColumnsChanged);
публичный интервал NumberOfColumns
{
 получить => (int) GetValue (NumberOfColumnsProperty);
 set => SetValue (NumberOfColumnsProperty, значение);
}
static void OnNumberOfColumnsChanged (привязываемый объект BindableObject,
объект oldValue, объект newValue)
{
 var manager = (FixedLayoutManager) привязываемый;
 менеджер.ИнициализироватьGrid();
}
```
Ключевое отличие этой реализации от предыдущей привязываемой
Созданные вами свойства — это использование параметра propertyChanged. Это
позволяет определить метод (см. OnNumberOfColumnsChanged), который будет
вызывается всякий раз, когда изменяется значение свойства.

---
Метод изменения свойства будет вызываться только тогда, когда значение
изменения. Это означает, что он может не вызываться изначально, если значение
не отличается от значения по умолчанию.
---

# Добавление свойства NumberOfRows

```Csharp
public static readonly BindableProperty NumberOfRowsProperty =
 BindableProperty.Создать(
 имя (количество строк),
 тип (целое число),
 тип (FixedLayoutManager),
 defaultBindingMode: BindingMode.OneWay,
 свойство изменено: OnNumberOfRowsChanged);
общедоступный интервал NumberOfRows
{
 get => (int) GetValue (NumberOfRowsProperty);
 set => SetValue (NumberOfRowsProperty, значение);
}
static void OnNumberOfRowsChanged (привязываемый объект BindableObject,
объект oldValue, объект newValue)
{
 var manager = (FixedLayoutManager) привязываемый;
 менеджер.ИнициализироватьGrid();
}
```
Это практически идентично свойству NumberOfColumns, которое вы только что
добавлено, за исключением значения NumberOfRows.

# Предоставление поддержки Tap/Click с помощью команды

Следующим пунктом в вашем списке является предоставление возможности обработки нажатия/щелчка.
поддерживать. Вы впервые оказываете командную поддержку; ты использовал
команды в ваших привязках, но это было на стороне источника, а не
целевая сторона, как здесь.
Во-первых, вам нужно добавить свойство bindable, которое должно начать ощущаться
довольно знакомо.

```Csharp
public static только для чтения BindableProperty
PlaceholderTappedCommandProperty =
 BindableProperty.Создать(
 имя (PlaceholderTappedCommand),
 тип(ICommand),
 typeof(FixedLayoutManager));
публичный ICommand PlaceholderTappedCommand
{
 get => (ICommand)GetValue(PlaceholderTappedCommand
Свойство);
 set => SetValue (PlaceholderTappedCommandProperty, значение);
}
```
Далее нужно добавить код, который будет выполнять команду. Ты
будет полагаться на использование TapGestureRecognizer, добавив его в
ваш элемент управления Placeholder внутри вашего метода InitialiseGrid, который вы
будет добавлено в следующем разделе. На данный момент вы можете добавить метод, который
будет использоваться, чтобы вы могли сосредоточиться на том, как выполнить команду. Давайте
добавьте код, а затем просмотрите детали.

```Csharp
private void TapGestureRecognizer_Tapped (отправитель объекта,
EventArgs e)
{
 если (отправитель является заполнителем-заполнителем)
 {
 если (PlaceholderTappedCommand?.CanExecute(placeholder.
Позиция) == правда)
 {
 PlaceholderTappedCommand.Execute(placeholder.
Позиция);
 }
 }
}
```
Вы можете видеть из реализации, что есть три основные части для
логика выполнения команды:
• Во-первых, убедитесь, что эта команда имеет значение.
• Во-вторых, вы проверяете, можете ли вы выполнить команду.
Если вы помните, в главе 5 вы предоставили метод
предотвратить выполнение команды, если пользователь
не ввел BoardName.
• Наконец, вы выполняете команду и передаете
параметр команды. Для этого сценария вы будете
переходя в текущую позицию заполнителя, поэтому
при добавлении виджета его можно поместить в тот же
позиция.

# Создание макета платы

Теперь вы можете сосредоточиться на компоновке базовых сеток, чтобы они отображались
в соответствии с введенными пользователем значениями для строк и столбцов.

Во-первых, добавьте свойство для хранения текущей доски, потому что вам нужно использовать
это при построении макета. Вам также необходимо записать, построили ли вы
макет, чтобы предотвратить любые ненужные обновления, перестраивающие пользовательский интерфейс.

```Csharp
частная доска BoardLayout;
частное логическое значение инициализировано;
общедоступная доскаМакетная доска
{
 получить => доска;
 набор
 {
 доска = стоимость;
 Инициализировать сетку();
 }
}
```
Ваш метод построения макета сетки состоит из нескольких частей, поэтому давайте добавим
их, как вы идете и обсудить их ценность. Сначала нужно убедиться, что
у вас есть допустимые значения для Board, NumberOfRows и NumberOfColumns
properties плюс вы еще не создали пользовательский интерфейс.

```Csharp
частная пустота InitialiseGrid()
{
 если (Доска равна нулю ||
 КоличествоКолонок == 0 ||
 Количество строк == 0 ||
 isInitialized == true)
 {
 возвращаться;
 }
 Инициализирован = Истина;
}
```
Следующим шагом будет использование значения NumberOfColumns и добавление его в
ваш Совет. Давайте добавим это в конец метода InitialiseGrid.

```Csharp
for (int i = 0; i <NumberOfColumns; i++)
{
 Board.AddColumn (новый ColumnDefinition (новый GridLength (1,
GridUnitType.Star)));
}
```
Значение GridUnitType.Star означает, что каждый столбец будет иметь
четная доля ширины сетки. Итак, если сетка имеет ширину 300 пикселей и
у вас есть 3 столбца, тогда каждый столбец имеет результирующую ширину 100 пикселей.
Следующим шагом будет использование значения NumberOfRows и добавление их в ваш
Доска. Давайте добавим это в конец метода InitialiseGrid.

```Csharp
for (int i = 0; i <NumberOfRows; i++)
{
 Board.AddRow(новая строкаDefinition(новая длина сетки(1,
GridUnitType.Star)));
}
```
Последним шагом в вашем методе InitialiseGrid является заполнение каждой ячейки
(строка и столбец) в сочетании с элементом управления Placeholder.

```Csharp
for (столбец int = 0; столбец < NumberOfColumns; столбец ++)
{
 for (int row = 0; row < NumberOfRows; row++)
 {
 var placeholder = новый Placeholder();
 placeholder.Position = row * NumberOfColumns + column;
 var tapGestureRecognizer = new TapGestureRecognizer();
tapGestureRecognizer.Tapped += TapGestureRecognizer_Tapped;
 placeholder.GestureRecognizers.Add(tapGesture
Распознаватель);
 Board.AddPlaceholder (заполнитель);
 Grid.SetColumn (заполнитель, столбец);
 Grid.SetRow(заполнитель, строка);
 }
}
```
В приведенном выше коде вы
• Перебор комбинаций строк/столбцов
• Создан элемент управления Placeholder
• Установите его положение для использования позже
• Добавлен TapGestureRecognizer для обработки пользователя.
взаимодействие
• Добавлен заполнитель на доску
• Поместил заполнитель в правильный столбец и
положение строки

# Установка правильной позиции строки/столбца для каждого виджета

Заключительная часть построения макета платы — предоставление метода
требуется интерфейсом ILayoutManager, чтобы ваш FixedLayoutManager
реализует. Этот метод будет

• Рассчитать значение столбца/строки на основе позиции
переданный параметр.
• Поместите параметр bindableObject, переданный в
рассчитанное положение столбца и строки.
• Удалите любой существующий заполнитель в позиции.

```Csharp
public void SetPosition (BindableObject bindableObject, int
позиция)
{
 если (количество столбцов == 0)
 {
 возвращаться;
 }
 столбец int = позиция % NumberOfColumns;
 int row = position / NumberOfColumns;
 Grid.SetColumn(bindableObject, столбец);
 Grid.SetRow(bindableObject, строка);
 var placeholder = Board.Placeholders.Where(p => p.Position
== позиция).FirstOrDefault();
 если (заполнитель не равен нулю)
 {
 Board.RemovePlaceholder (заполнитель);
 }
}
```
Теперь, когда вы завершили работу по предоставлению BoardLayout
и управлять его макетом с помощью класса FixedLayoutManager, вы должны
идите вперед и используйте его в своем приложении.

# Использование вашего макета

Прежде чем вы сможете начать использовать созданный вами макет BoardLayout,
есть еще немного работы, которую нужно сделать. Вам нужно
• Добавьте фабрику, которая будет создавать экземпляры ваших виджетов.
• Добавьте в DataTemplateSelector, о котором я говорил.
ранее.
• Обновите модель FixedBoardPageViewModel, чтобы
привязки будут работать.

# Добавление фабрики, которая будет создавать экземпляры ваших виджетов

Для этого вы создадите новый класс под названием WidgetFactory в
корень вашего проекта.

```Csharp
используя WidgetBoard.ViewModels;
с помощью WidgetBoard.Views;
пространство имен WidgetBoard;
открытый класс WidgetFactory
{
}
```
У этой фабрики три основных цели:
• Позволяет регистрировать виды виджетов и
просмотреть модели
• Создание виджета
• Создание модели представления виджета
Итак, давайте поддержим эти три требования.

# Разрешение регистрации представлений виджетов и моделей представлений

Вам необходимо добавить следующий код:

```Csharp
private static IDictionary<Type, Type> widgetRegistrations =
новый Словарь<Тип, Тип>();
частный статический IDictionary<string, Type>
widgetNameRegistrations = новый словарь<строка, тип>();
public static void RegisterWidget<TWidgetView,
TWidgetViewModel>(string displayName), где TWidgetView:
IWidgetView, где TWidgetViewModel: IWidgetViewModel
{
 widgetRegistrations.Add(typeof(TWidgetViewModel),
тип(TWidgetView));
 widgetNameRegistrations.Add (отображаемое имя,
typeof(TWidgetViewModel));
}
общедоступный IList<string> AvailableWidgets =>
имявиджетаRegistrations.Keys.ToList();
```
Вышеизложенное может показаться немного сложным, но если вы разберете его,
надеюсь, должно стать ясно. Вы добавили два поля, которые будут хранить
информация о типе и имени, необходимые для создания
экземпляры виджетов.
Метод RegisterWidget принимает параметр отображаемого имени и
Два типа:
• TWidgetView: должен реализовать ваш IWidgetView.
интерфейс.
• TWidgetViewModel: должен реализовать ваш
Интерфейс IWidgetViewModel.

Затем вы сохраняете сопоставление между типом модели представления и представлением
тип (виджетрегистрации). Это позволяет вам создавать представление, когда вы
перейти в модель представления. Это действительно поможет вам сохранить четкое разделение
между вашим представлением и моделью представления.
Вы также сохраняете сопоставление между отображаемым именем и представлением.
тип модели (widgetNameRegistrations). Это позволит вам представить
вариант на экране для пользователя. Как только они выбирают название виджета, они
хотел бы добавить, фабрика создаст его экземпляр.

# Создание виджета

Сначала вам нужно добавить зависимость к вашему конструктору.

```Csharp
частный IServiceProvider serviceProvider только для чтения;
публичный WidgetFactory (сервисный провайдер IServiceProvider)
{
 this.serviceProvider = поставщик услуг;
}
```
IServiceProvider позволит вам создать новый экземпляр
ваших виджетов и убедитесь, что они снабжены всеми
их зависимости. Не беспокойтесь о необходимости регистрации
Реализация IServiceProvider с вашим MauiAppBuilder, как вы
сделали с другими зависимостями, которые вам нужны. Это автоматически
предоставлено .NET MAUI.
Теперь давайте добавим возможность создания представления виджета.

```Csharp
общедоступный IWidgetView CreateWidget (IWidgetViewModel
виджетвиевмодель)
{
 если (widgetRegistrations.TryGetValue(widgetViewModel.
GetType(), из var widgetViewType))
 {
   var widgetView = (IWidgetView)serviceProvider.GetRequir
edService (тип виджета);
 widgetView.WidgetViewModel = widgetViewModel;
 вернуть виджетВидео;
 }
 вернуть ноль;
}
```
Разрушая это,
• Вы проверяете, поддерживает ли поставляемый виджетViewModels
Тип зарегистрирован на заводе.
• Если это так, вы используете IServiceProvider, чтобы получить
экземпляр связанного вида виджета.
• Вы присваиваете значение параметра widgetViewModel объекту
WidgetViewModel в представлении виджета. Это
чтобы разрешить настройку виджетов BindingContext
свойство.

# Создание модели представления виджета

Также необходимо предоставить возможность создания модели представления виджета
потому что это требуется в вашей модели представления.

```Csharp
публичный IWidgetViewModel CreateWidgetViewModel (строка
отображаемое имя)
{
 if (widgetNameRegistrations.TryGetValue(отображаемое имя,
вар виджетвиевмоделтип))
 {
   вернуть (IWidgetViewModel) serviceProvider.GetRequiredSer
вице (виджетвиевмоделтипе);
 }
 вернуть ноль;
}
```
Разрушая это,
• Вы проверяете, было ли предоставленное отображаемое имя
зарегистрирован на заводе.
• Если это так, вы используете IServiceProvider, чтобы получить
экземпляр связанной модели представления виджета.

# Регистрация фабрики с помощью MauiAppBuilder

Внутри файла MauiProgram.cs вам необходимо зарегистрировать свой WidgetFactory.
с MauiAppBuilder, чтобы убедиться, что любые зависимости могут решить эту проблему.
Откройте этот файл и добавьте следующую строку в метод CreateMauiApp:

```Csharp
builder.Services.AddSingleton<WidgetFactory>();
```
# Регистрация вашего ClockWidget на заводе

Теперь, когда у вас есть WidgetFactory, вам нужно изменить его так, чтобы
factory может создать виджет для вас. Это требует ряда шагов, поэтому
давайте пройдемся по нему.
Сначала откройте файл ClockWidgetView.xaml.cs и измените его на
следующий:

```Csharp
используя WidgetBoard.ViewModels;
пространство имен WidgetBoard.Views;
общедоступный частичный класс ClockWidgetView: Label, IWidgetView
{
публичный ClockWidgetView (ClockWidgetViewModel
ClockWidgetViewModel)
 {
 ИнициализироватьКомпонент();
 WidgetViewModel = часыWidgetViewModel;
 BindingContext = clockWidgetViewModel;
 }
 общественность IWidgetViewModel WidgetViewModel { получить; набор; }
}
```
Это приводит к тому, что ваш ClockWidgetView зависит от
ClockWidgetViewModel.
Далее вам необходимо зарегистрировать свой виджет на фабрике. Открыть
ваш файл MauiProgram.cs и добавьте следующие строки в
Метод CreateMauiApp:

```Csharp
WidgetFactory.RegisterWidget<ClockWidgetView, ClockWidgetView
Модель>("Часы");
builder.Services.AddTransient<ClockWidgetView>();
builder.Services.AddTransient<ClockWidgetViewModel>();
```
Это позволит WidgetFactory возвращать виджет часов как
вариант, когда он представлен в вашем оверлее.

# Выбор шаблона виджета

Основная цель этой реализации - обеспечить преобразование
между моделями представления виджетов, которые вы будете хранить на своем
FixedBoardPageViewModel и что-то, что действительно можно отрендерить
на экране. Вы будете зависеть от имеющейся у вас WidgetFactory.
только что созданный. Создайте класс в корневой папке проекта.

```Csharp
используя WidgetBoard.ViewModels;
пространство имен WidgetBoard.Views;
открытый класс WidgetTemplateSelector: DataTemplateSelector
{
 частный только для чтения WidgetFactory widgetFactory;
 общедоступный WidgetTemplateSelector (WidgetFactory widgetFactory)
 {
 this.widgetFactory = widgetFactory;
 }
 защищенное переопределение DataTemplate OnSelectTemplate (объект
элемент, контейнер BindableObject)
 {
 если (элемент IWidgetViewModel widgetViewModel)
 {
 вернуть новый DataTemplate(() => widgetFactory.Create
Виджет (Модель Виджета));
 }
 вернуть ноль;
 }
}
```
Основная часть, на которой вам нужно сосредоточиться, это OnSelectTemplate.
метод. Ранее я кратко обсуждал назначение этого метода; Давайте
взгляните глубже сейчас. Его основная цель — предоставить DataTemplate и
то, что можно отобразить на экране. Это отличный способ сохранить
разделение между представлением и моделью представления.
В вашей реализации вы можете видеть, что
• Вы проверяете, реализует ли переданный элемент ваши
Интерфейс IWidgetViewModel.
• Если да, то вы создаете новый DataTemplate и полагаетесь на
WidgetFactory, чтобы вернуть представление виджета, которое
сопоставляется с типом моделей представлений.

# Регистрация селектора шаблонов в MauiAppBuilder

Внутри вашего файла MauiProgram.cs вам необходимо зарегистрировать
WidgetTemplateSelector с MauiAppBuilder, чтобы убедиться, что
зависимости могут решить эту проблему. Откройте этот файл и добавьте следующую строку в
метод CreateMauiApp:

```Csharp
builder.Services.AddSingleton<WidgetTemplateSelector>();
```
# Обновление модели FixedBoardPageViewModel

Вам нужно добавить свойства, к которым вы можете привязаться в своем представлении.

```Csharp
частная строка boardName;
частный интервал numberOfColumns;
частный интервал numberOfRows;
общедоступная строка BoardName
{
 получить => имя_доски;
 set => SetProperty (ref boardName, значение);
}
публичный интервал NumberOfColumns
{
 получить => количество столбцов;
 set => SetProperty (ссылка numberOfColumns, значение);
}
общедоступный интервал NumberOfRows
{
 получить => количество строк;
 set => SetProperty (ссылка numberOfRows, значение);
}
public ObservableCollection<IWidgetViewModel> Widgets { get; }
общественность WidgetTemplateSelector WidgetTemplateSelector { получить; }
```
Обратите внимание, что свойства Widgets и WidgetTemplateSelector
не вызывайте метод SetProperty для уведомления пользовательского интерфейса об изменениях. Этот
вполне допустимый сценарий. Вы знаете, что значение будет установлено в
конструктор, и поэтому значение будет установлено до того, как привязка будет
применяемый.
Вам также необходимо добавить оставшийся код в ваш
ApplyQueryAttributes, который вы добавили в предыдущей главе. Это
теперь должно выглядеть следующим образом:

```Csharp
public void ApplyQueryAttributes(IDictionary<string,
объект > запрос)
{
 var board = query["Доска"] as Board;
 BoardName = доска.Имя;
 NumberOfColumns = ((FixedLayout)board.Layout).
Число столбцов;
 NumberOfRows = ((FixedLayout)board.Layout).NumberOfRows;
}
```
Наконец, вам нужно добавить WidgetTemplateSelector в качестве
зависимость в вашем конструкторе. Теперь это должно выглядеть следующим образом:

```Csharp
общедоступная FixedBoardPageViewModel (
 WidgetTemplateSelector
)
{
 WidgetTemplateSelector = виджетTemplateSelector;
 Виджеты = новая ObservableCollection<IWidgetViewModel>();
}
```
Теперь вы готовы добавить макет на свою страницу.

# Наконец, использование макета

Теперь, когда вы создали свой макет, вы должны использовать его. Ты
ранее добавил FixedBoardPage, чтобы вы могли изменить его
к следующему:

```xml
<?xml версия="1.0" кодировка="utf-8" ?>
<страница содержимого
 xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
 xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
 xmlns:layouts="clr-namespace:WidgetBoard.Layouts"
 xmlns:viewmodels="clr-namespace:WidgetBoard.ViewModels"
 x:Class="WidgetBoard.Pages.FixedBoardPage"
 Заголовок = "Фикседбордпаже"
 x: DataType = "видмоделс: FixedBoardPageViewModel">
  <layouts:BoardLayout
 ItemsSource="{Привязка виджетов}"
 ItemTemplateSelector="{Привязка виджета
Выбор шаблонов}">
 <layouts:BoardLayout.LayoutManager>
 <макеты:FixedLayoutManager
 NumberOfColumns="{Привязка NumberOfColumns}"
 NumberOfRows="{Привязка NumberOfRows}" />
 </layouts:BoardLayout.LayoutManager>
 </layouts:BoardLayout>
</ContentPage>
```
Теперь это включает в себя ваш новый блестящий BoardLayout со всеми
привязки, которые вы создали, чтобы сделать его функциональным.

# Краткое содержание

В этой главе вы
• Создал свой собственный макет
• Использованы различные параметры при добавлении привязываемых
характеристики
• Обеспечена поддержка команд из вашего макета
• Использовали ваш макет в приложении
В следующей главе вы будете
• Получите представление о том, что такое доступность
• Узнайте, почему важно создавать инклюзивные
Приложения
• Посмотрите, как можно использовать .NET MAUI.
функциональность
• Рассмотрите другие сценарии и способы их поддержки
• Рассмотрите несколько вариантов тестирования, которые помогут вам в вашем путешествии.
для создания доступных приложений

# Исходный код

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introduction-MAUI/tree/
основной/ch06.

# Дополнительное задание

Вы могли заметить, что во многих названиях присутствует слово Fixed.
Продолжим дополнительное задание из предыдущей главы и построим
доска, которая является вариацией этого подхода. Мне очень нравится идея
доска произвольной формы, на которой пользователь может размещать свои виджеты в любом месте.
нравиться. Это немного сложнее, но если учесть, как BoardLayout
может использовать AbsoluteLayouts, а не Grids, тогда новый ILayoutManager
реализация, надеюсь, должна быть там, где потребуется альтернативная логика
применяться. Если вы отправитесь в это путешествие, пожалуйста, не стесняйтесь поделиться
ваш опыт и выводы.













































# ГЛАВА 8

# Расширенные концепции пользовательского интерфейса

В этой главе вы предоставите пользователю вашего приложения возможность
чтобы добавить виджет на доски, которые они создают с помощью наложения. Ты
еще больше улучшит это наложение, определив общие методы стиля
и обработка различий между светлыми и темными устройствами.
Затем вы отправитесь в путешествие, чтобы узнать, как вы можете построить
приложение, которое кажется естественным и органичным для вашей пользовательской базы. Окончательно,
вы увидите, как вы можете сохранить анимацию, управляющую органичным видом
и чувствовать себя полностью отделенным от вашего кода бизнес-логики.

# Добавление возможности добавления виджета на доску

В Главе 6 вы создали свой собственный BoardLayout и связанный с ним
FixedLayoutManager, который позволял отображать доску и добавлял в
возможность обработки событий взаимодействия пользователем. В этом разделе вы
мы собираемся расширить это, чтобы обрабатывать пользователя, нажимающего на виджет
Заполнитель и предоставление пользователю возможности выбрать виджет для добавления на доску.

# Возможные способы достижения цели

Есть несколько способов добавить этот фрагмент
функциональность. Некоторые лучше подходят для различных сценариев, а некоторые
просто сводится к личным предпочтениям. Я призываю вас
поймите свою цель, прежде чем отправиться в это путешествие по тренировкам
какой вариант лучше всего удовлетворит ваши потребности. Если вы хотите только сообщить о сообщении
пользователю или захватить выбор или даже один вход, то вы можете
использовать некоторые базовые функции, предоставляемые .NET MAUI. Страница
класс предоставляет возможность выполнить каждый из трех рассмотренных пунктов; это не
решить ваши потребности, но это действительно имеет значение во многих приложениях. 
Документация Microsoft содержит хороший набор справочных примеров по
как использовать эти параметры на https://learn.microsoft.com/dotnet/maui/
пользовательский интерфейс/всплывающие окна.
Давайте обсудим некоторые из этих вариантов, которые решают ваши потребности и
затем примите решение, которое, по вашему мнению, является лучшим кандидатом для вашего
приложение.

# Отображение модальной страницы

До сих пор в этой книге вы рассматривали только то, как «Шелл» предлагает
возможность навигации между ContentPages. Это значение по умолчанию и наиболее
распространенный сценарий. Могут быть случаи, когда вы хотите показать страницу
который блокирует и потребует от пользователя взаимодействия с ним, чтобы вернуться к
Предыдущая страница. Этот тип страницы или отображения называется модальным. 
сценарий показа чего-либо пользователю и требования его участия
с этим может быть идеальный сценарий.
Чтобы включить эту функцию в .NET MAUI, вам необходимо установить
Свойство Shell.PresentationMode на ContentPage, которое вы хотите
отображать. Например,

```xml
<КонтентСтраница...
 Shell.PresentationMode="Модальный">
 ...
</ContentPage>
```
Затем вы можете вызвать метод Shell.Current.GoToAsync с
параметры маршрутизации настроены для этой страницы, и она будет представлена ​​модально
вместо перехода к.

Про
• Сохраняет определенный код
Против
• Усложняет поток кода при обработке возвращаемого результата.

# Наложение представления

Иногда самый простой способ реализовать этот подход — добавить
другое представление вашей страницы и программно изменить его видимость на
создайте впечатление, что у вас отображается модальная страница.
Про
• Сокращает усилия по созданию страницы
Против
• Требуется специальный код для вызова представления/модели представления.

# Отображение всплывающего окна

В настоящее время в .NET MAUI нет явной поддержки отображения всплывающих окон;
однако эта функциональность существует на каждой из платформ, на которых работает .NET.
МАУИ работает. Вы можете пойти на все, чтобы реализовать свои собственные способности
для отображения всплывающего окна, но это было бы довольно сложно. Вместо этого .NET MAUI
Community Toolkit предоставляет класс Popup, который упрощает
вам отображать всплывающее окно в вашем приложении.

Плюсы
• Сохраняет определенный код
• Обеспечивает простую обработку возвращаемых результатов
Для получения дополнительной информации о том, как использовать инструментарий и его класс Popup, пожалуйста,
обратитесь к документации по адресу https://learn.microsoft.com/dotnet/
communitytoolkit/maui/views/popup.

# Выбранный подход

Учитывая плюсы и минусы, изложенные выше, вы можете догадаться, что вы будете
с помощью класса Popup. Неа. Давайте воспользуемся подходом с наложением представления. Этот
главным образом потому, что это поможет вам узнать больше о .NET MAUI.
концепции, которые, я считаю, будут чрезвычайно ценными при создании приложений.
Однако для своей работы используйте подход, который лучше всего соответствует вашему сценарию.
Я хотел бы подчеркнуть, что каждый из вышеперечисленных вариантов позволит достичь
нужны результаты. На самом деле, может быть больше вариантов, которых у меня нет.
покрыты, и если вы найдете один, я хотел бы услышать об этом.

# Добавление вашего вида наложения

Вам необходимо добавить в файл FixedBoardPage.xaml представление, которое будет представлять
возможность пользователю добавить новый виджет на доску. Давайте откроем этот файл
и добавьте следующий код внутри сетки и ниже
</layouts:BoardLayout> строка:

```xml
<БоксВиев
 ФонЦвет="Черный"
 Непрозрачность = "0,5"
 IsVisible="{Привязка IsAddingWidget}" />
<Граница
 IsVisible="{Привязка IsAddingWidget}"
        HorizontalOptions="Центр"
 Вертикальные опции = "Центр"
 Заполнение = "10">
 <вертикальный стекмакет>
 <Ярлык
 Текст = "Добавить виджет"
 Размер шрифта = "20" />
 <Ярлык
 Текст = "Виджет" />
 <Выборщик
 ItemsSource="{Привязка доступных виджетов}"
 SelectedItem="{Привязка SelectedWidget}"
 SemanticProperties.Description="{Текст привязки,
Источник={x:Ссылка SelectTheWidgetLabel}}"
 SemanticProperties.Hint="Picker, содержащий
возможные типы виджетов, которые можно добавить в
доска. Это обязательное поле." />
 <Ярлык
 Текст = "Предварительный просмотр" />
 <КонтентВью
 Запрос ширины = "250"
 Запрос высоты = "250" />
 <Кнопка
 Текст = "Добавить виджет"
 Command="{Привязка AddWidgetCommand}"
 SemanticProperties.Hint="Добавляет выбранный виджет
к доске. Требуется «Выбрать виджет»
поле для установки." />
 </вертикальный стекмакет>
</Граница>
```
Добавление кода приводит к добавлению двух новых элементов управления к родительскому элементу.
Дочерняя коллекция Grids: BoxView и Border. BoxView добавляется в
обеспечить полупрозрачное наложение поверх остальной части приложения и
Граница представляет содержимое для выбора нового виджета. Добавление их
после того, как BoardLayout означает, что он будет отображаться поверх BoardLayout.
Этот порядок называется Z-индексом и в большинстве .NET MAUI.
приложения, макеты определяются порядком, в котором дети
добавляются к их родителю. Это означает, что чем позже будут добавлены элементы управления,
тем выше они будут казаться визуально. Вы можете изменить это поведение по умолчанию
с помощью свойства ZIndex, где чем выше значение, тем выше они
появится визуально. Обладая этими знаниями, вы можете добавить привязку между
свойство IsVisible ваших новых элементов управления и свойство в вашем представлении
модель, поэтому ваша модель представления может контролировать, добавляете ли вы виджет в
доска.
Давайте обновим вашу модель представления.

# Обновление вашей модели представления

Поскольку вы включили скомпилированные привязки в предыдущей главе, вы
теперь видите, что ваш код не будет компилироваться, потому что вы не определили
свойства, к которым вы привязаны. Итак, откройте FixedBoardPageViewModel.cs
файл и внесите следующие дополнения.
Добавьте новые свойства и связанные вспомогательные поля в свой
Класс FixedBoardPageViewModel.

```Csharp
частное intAddingPosition;
приватная строка selectedWidget;
частное логическое значение isAddingWidget;
частный только для чтения WidgetFactory widgetFactory;
public IList<string> AvailableWidgets => widgetFactory.AvailableWidgets;

публичный ICommand AddWidgetCommand { получить; }
публичный ICommand AddNewWidgetCommand { получить; }
общедоступный логический объект IsAddingWidget
{
 получить => isAddingWidget;
 set => SetProperty (ref isAddingWidget, значение);
}
общедоступная строка SelectedWidget
{
 получить => выбранный виджет;
 set => SetProperty (ссылка selectedWidget, значение);
}

```

Обновите конструктор новой зависимостью WidgetFactory и
установите новые команды, которые вы добавили; изменения выделены жирным шрифтом.

```Csharp
общедоступная FixedBoardPageViewModel (
 WidgetTemplateSelector виджетTemplateSelector,
 фабрика виджетов (фабрика виджетов)
{
 WidgetTemplateSelector = виджетTemplateSelector;
 this.widgetFactory = widgetFactory;
 Виджеты = новая ObservableCollection<IWidgetViewModel>();
 AddWidgetCommand = новая команда (OnAddWidget);
 AddNewWidgetCommand = новая команда<int>(индекс =>
 {
 Исаддингвиджет = истина;
 добавлениеПозиция = индекс;
 });
}
```
В предыдущем разделе кода вы задали для свойства IsAddingWidget значение
true, чтобы отобразить вид наложения, а также сохранить запись
переменная index, которая является свойством Position из заполнителя,
постучали.
Предоставьте реализацию метода для AddWidgetCommand.

```Csharp
частная пустота OnAddWidget()
{
 если (SelectedWidget имеет значение null)
 {
 возвращаться;
 }
 var widgetViewModel = widgetFactory.CreateWidgetViewModel
(Выбранный виджет);
 widgetViewModel.Position = addPosition;
 Виджеты. Добавить (Модель Виджета);
 Исаддингвиджет = ложь;
}
```
Надеемся, что большая часть того, что вы только что добавили, покажется вам знакомой. 
часть, которая, скорее всего, не является последним методом OnAddWidget. давайте возьмем
более глубокий взгляд на эту реализацию.
Свойство SelectedWidget привязано к средству выбора в представлении. Ты
сделать некоторую начальную проверку ввода, чтобы убедиться, что пользователь выбрал
тип добавляемого виджета; в противном случае вы вернетесь из метода.
Затем вы используете новую зависимость (widgetFactory) для создания представления.
модель для вас.
Затем вы устанавливаете его позицию в зависимости от того, какой заполнитель был нажат.
изначально.

Затем вы добавляете только что созданный виджетViewModel в коллекцию
Виджеты, чтобы он мог обновлять пользовательский интерфейс.
Наконец, вы устанавливаете для свойства IsAddingWidget значение false, чтобы скрыть
вид наложения снова.

# Отображение вида наложения

Теперь можно добавить возможность программно показывать границу, которая
позволяет вашим пользователям выбирать виджет и добавлять его на доску. Вы уже
предоставил большое количество этой функциональности внутри вашего заполнителя и
Классы FixedLayoutManager, поэтому вам просто нужно подключить свою модель представления
к этой функциональности. Вы также только что заложили основу в своем представлении
модель, так что давайте подключим компоненты. Откройте файл FixedBoardPage.xaml.
файл еще раз и добавьте следующую жирную строку:

```xml
<layouts:BoardLayout
 ItemsSource="{Привязка виджетов}"
 ItemTemplateSelector="{Привязка WidgetTemplateSelector}">
 <layouts:BoardLayout.LayoutManager>
 <макеты:FixedLayoutManager
 NumberOfColumns="{Привязка NumberOfColumns}"
 NumberOfRows="{Привязка NumberOfRows}"
 PlaceholderTappedCommand="{Привязка
ДобавитьКомандуНовогоВиджета}" />
 </layouts:BoardLayout.LayoutManager>
</layouts:BoardLayout>
```
Если вы создадите и запустите свое приложение, вы увидите, что после
создал доску, теперь вы можете коснуться или щелкнуть заполнитель и наблюдать
который отображается на вашем оверлее. Вы заметите, что нет фона
к вашему оверлею, поэтому пользователю действительно трудно понять
что делать. Вы можете просто установить BackgroundColor вашего элемента управления Border;
однако это может привести к ряду проблем. Например, если вы исправили

BackgroundColor на белый, и пользователь включает темный режим на своем
устройство, у них будет довольно неприятный опыт. Рисунок 8-1 показывает
как приложение выглядит в настоящее время и выделяет проблему.

![изображение](https://user-images.githubusercontent.com/26972859/231236048-1bbf7374-65ff-4646-82d5-6c2071843bd1.png)
Рисунок 8-1. Приложение, показывающее наложение с плохим пользовательским интерфейсом

Давайте посмотрим, как .NET MAUI предоставляет возможность стилизации вашего
приложений, включая поддержку светлых и темных режимов.

# Стиль

.NET MAUI предоставляет возможность стилизовать ваши приложения. Стилизация в .NET
MAUI предлагает множество преимуществ:
• Центральное определение внешнего вида
• Меньше многословия в XAML/коде.
• Наследование стилей
Стили в .NET MAUI могут быть определены во множестве различных
уровни и где они определены, чрезвычайно важно
при понимании того, какое влияние они окажут. Два
ключевые различия между тем, где они определены, могут быть
рассматривается как

• Глобально: эти стили добавляются в
Ресурсы. Вы можете увидеть пример этого, если откроете
файл App.xaml. Строка, выделенная жирным шрифтом, показывает, что другой
файл (Styles.xaml), содержащий стили, загружается в
свойство Application.Resources. Эти стили
применяются ко всем элементам управления в приложении, если не указано иное
явно переопределен.

```xml
<Приложение xmlns="http://schemas.microsoft.com/
точка/2021/мауи"
 xmlns:x="http://schemas.microsoft.com/
winfx/2009/xaml"
 xmlns:local="clr-namespace:WidgetBoard"
 x:Class="WidgetBoard.App">
 <Приложение.Ресурсы>
 <Ресурсный словарь>
 <ResourceDictionary.MergedDictionaries>
 <Ресурсный словарь
Source="Ресурсы/Стили/Цвета.
ксэмл" />
 <ResourceDictionary Source="Ресурсы/
Стили/Styles.xaml" />
 </ResourceDictionary.Объединенные словари>
 </Словарь ресурсов>
 </Приложение.Ресурсы>
</Приложение>
```

Локально: эти стили добавляются к представлению или странице.
собственность ресурсов. Определенные таким образом стили будут применяться
ко всем элементам управления, которые являются дочерними элементами представления или страницы, которые они
определяются в.

Ваш глобальный пример относится к файлу Styles.xaml. Это файл, который
поставляется с новым проектом .NET MAUI.

# Проверка стилей по умолчанию

Вы можете просмотреть этот файл в Resources/styles.xaml. Давайте посмотрим на
стиль границы в этом файле:

```xml
<Стиль TargetType="Граница">
 <Setter Property="Stroke" Value="{AppThemeBinding
Светлый = {StaticResource Gray200}, Темный = {StaticResource
Серый500}}" />
 <Setter Property="StrokeShape" Value="Прямоугольник"/>
 <Setter Property="StrokeThickness" Value="1"/>
</Стиль>
```
Синтаксис XAML, используемый для определения стиля, выглядит иначе, чем
XAML, который вы уже написали. Давайте сломаем его, чтобы получить лучшее
понимания, что все это значит.

# Тип цели

Для начала при определении стиля вы должны определить TargetType. Этот
свойство определяет, какой тип элемента управления предназначен для определения стиля и
поэтому относится к. Определение стиля только с помощью свойства TargetType
set будет применяться ко всем элементам управления этого типа в пределах области, в которой он определен. Этот
называется неявным стилем.

Если вы хотите явно стилизовать элемент управления, вы также можете добавить x:Key
свойство. Это называется явным стилем. Затем вам необходимо установить
свойство Style любого элемента управления, который хочет использовать этот явный стиль, который
вы создали. Вы будете создавать явный стиль в разделе «Создание
style» вскоре последует.

# Применить к производным типам

По умолчанию стили, созданные явно, применяются к типу, определенному в
Свойство TargetType, о котором я только что рассказал. Если вы хотите разрешить производным классам
также наследовать этот стиль, необходимо установить свойство ApplyToDerivedTypes
к истине.

# Сеттер

Это часть, которая выглядит и ощущается немного иначе, чем предыдущая.
XAML, который вы написали. Поскольку вы не создаете элементы управления, а определяете
как они будут выглядеть, вы должны следовать этому синтаксису. Давайте посмотрим на следующее
пример:

```xml
<Стиль TargetType="Ярлык">
 <Setter Property="TextColor" Value="Черный" />
</Стиль>
```
Вышеупомянутый стиль не является стилем, который вы бы включили в приложение; однако,
в качестве примера это позволяет вам сказать
Элементы управления Style for Label устанавливают для свойства TextColor значение Black.
Теперь, когда вы ознакомились с некоторыми ключевыми понятиями, из которых состоит
стиль в .NET MAUI, давайте создадим собственный стиль для вашего оверлея.

# Создание стиля

Давайте посмотрим на это в действии, добавив следующее в файл Styles.xaml.
Добавьте это чуть ниже существующей записи ```<Style TargetType=="Border">```.

```xml
<Style TargetType="Border" x:Key="OverlayBorderStyle">
 <Setter Property="BackgroundColor" Value="Белый"
/> <Setter Property="Stroke" Value="{AppThemeBinding
Светлый = {StaticResource Gray200}, Темный = {StaticResource
Серый500}}" />
 <Setter Property="StrokeShape" Value="Прямоугольник"/>
 <Setter Property="StrokeThickness" Value="1"/>
</Стиль>
```
Приведенное выше выглядит очень похоже на уже определенный стиль границы по умолчанию.
с добавлением установщика BackgroundColor.
Также стоит отметить, что вам нужно установить только те значения, которые вы
хотите изменить неявный стиль. Таким образом, ваш явный стиль может быть
уменьшен до

```xml
<Style TargetType="Border" x:Key="OverlayBorderStyle">
 <Setter Property="BackgroundColor" Value="Белый" />
</Стиль>
```
Все свойства Stroke, StrokeShape и StrokeThickness будут
унаследован от неявного глобального стиля. Это дает еще один отличный способ
чтобы уменьшить количество кода, который вам нужно написать.
Теперь вы можете использовать этот стиль в своем приложении. Открой
файл FixedBoardPage.xaml и добавьте следующую строку к границе
элемент (выделено жирным шрифтом):

```xml
<Граница
 IsVisible="{Привязка IsAddingWidget}"
 HorizontalOptions="Центр"
 Вертикальные опции = "Центр"
 Заполнение = "10"
 Style="{StaticResource OverlayBorderStyle}">     
```
Это приведет к тому, что ваш оверлей будет выглядеть намного лучше для пользователя.
теперь, потому что он больше не прозрачен. Также рассмотрите возможность перемещения
свойства HorizontalOptions, VerticalOptions и Padding на
определение стиля. Рисунок 8-2 показывает, насколько лучше теперь выглядит наложение.

![изображение](https://user-images.githubusercontent.com/26972859/231237147-c32df356-9fe8-48c0-b0f8-d54eb77c3e83.png)
Рисунок 8-2. Наложение с более четким фоном

Однако то, что вы сделали здесь, считается плохой практикой! Ты
жестко запрограммировали BackgroundColor вашего элемента управления Border в стиле
определение, поэтому ваше приложение будет отлично смотреться на устройстве, работающем в свете
режим. Однако, как только пользователь переключится в темный режим, у него появится
показывает яркую белую рамку.

---
Последствия использования фиксированных значений могут включать текст или контент.
полностью исчезает из приложения. Представьте, что цвет текста
переключается на белый в темном режиме, при этом вы жестко закодировали
белый фон наложения, чтобы пользователь не видел текста
на экране. Это приведет к ужасному пользовательскому опыту.
---

.NET MAUI обеспечивает возможность обработки различных режимов, которые
устройство может работать под.

# AppThemeBinding

Это чрезвычайно ценное понятие. Он позволяет определить различные
значения в зависимости от того, установлено ли устройство, на котором работает ваше приложение.
в светлый или темный режим. На примере OverlayBorderStyle вы
ранее созданный, вы можете изменить Setter для BackgroundColor на

```xml
<Setter Property="BackgroundColor" Value="{AppThemeBinding
Светлый = {StaticResource White}, Темный = {StaticResource Black}}" />
```
Теперь, если пользователь работает в темном режиме, наложение границы будет черным.
и текст будет виден.
Вам нужно только применить AppThemeBinding к свойствам, которые требуют
визуальное различие между светлым и темным режимом. Обычно это относится ко всем
свойства кисти/цвета; тем не менее, вы могли бы принять решение изменить
например, StrokeThickness вашего элемента управления Border.

# Дальнейшее чтение

Стоит отметить, что эта книга ограничена описанием вариантов укладки.
в XAML. Однако .NET MAUI обеспечивает поддержку основанных на CSS
таблицы стилей. Перейдите по адресу https://docs.microsoft.com/dotnet/maui/userinterface/styles/css.

# Триггеры

.NET MAUI предоставляет концепцию, называемую триггерами. Они позволяют вам в дальнейшем
улучшите реакцию ваших представлений на изменения в модели представления. Тебе дали
возможность определять действия, которые могут изменить внешний вид пользовательского интерфейса
на основе событий или изменений данных. Триггеры предоставляют нам еще один способ
изменение видимости нашего наложения границы для добавления нового виджета. 
первоначальная работа будет казаться более многословной в краткосрочной перспективе, но не терпите
меня - это приведет к гораздо лучшему результату!
Существует несколько различных типов триггеров, которые можно прикрепить
к элементу управления, каждый из которых имеет разный уровень функциональности. Вы возьмете краткое
посмотрите на них, а затем покопайтесь в том, что вам нужно для вашего сценария.

• Триггер: Триггер представляет собой триггер, который применяется
значения свойств или выполняет действия, когда
указанное свойство соответствует заданному условию.

• DataTrigger: DataTrigger представляет триггер,
применяет значения свойств или выполняет действия, когда
связанные данные удовлетворяют заданному условию. Связывание
расширение разметки используется для отслеживания указанного
состояние.

• EventTrigger: EventTrigger представляет собой триггер.
который применяет набор действий в ответ на событие.
В отличие от Trigger, EventTrigger не имеет концепции
прекращения состояния, поэтому действия не будут
отменено, как только условие, вызвавшее событие, не
правда дольше.

• MultiTrigger: MultiTrigger представляет триггер,
применяет значения свойств или выполняет действия, когда набор
условий удовлетворены. Все условия должны быть
true до применения объектов Setter.

# Создание триггера данных

В этой главе вы добавили свой оверлей Border control и теперь
в настоящее время меняет свою видимость через привязку непосредственно к IsVisible
свойство. Вы можете написать это по-другому с помощью DataTrigger. Давайте откроем
файл FixedBoardPage.xaml и измените элемент управления Border на следующее:

```xml
<Граница
 Видимый = "Ложь"
 HorizontalOptions="Центр"
 Вертикальные опции = "Центр"
 Заполнение = "10"
 Style="{StaticResource OverlayBorderStyle}">
 <Граница.Триггеры>
 <триггер данных
 TargetType="Граница"
 Binding="{Привязка IsAddingWidget}"
 Значение="Истина">
 <Сеттер
 Свойство = "Видимо"
 Значение = "Истина" />
 </Триггер Данных>
 </Граница.Триггеры>
```

Обратите внимание, что синтаксис триггера очень похож на стиль. Ты
также заметит, что он выглядит намного более подробным, чем исходный простой
обязывающий подход. Если вы просто хотите управлять свойством IsVisible объекта
контроль, триггер - это перебор, на мой взгляд. Ты не закончишь здесь,
хотя, так что терпите меня. Во-первых, давайте разберем то, что вы добавили, и
затем посмотрите, как вы можете улучшить его.

Во-первых, вы изменяете привязку свойства IsVisible к false. Это
начальное состояние видимости вашего представления.

```xml
Видимый = "Ложь"
```
Затем вы добавляете DataTrigger в свойство Border.Triggers.

```xml
<триггер данных
 TargetType="Граница"
 Binding="{Привязка IsAddingWidget}"
 Значение="Истина">
```
Как и в случае со стилями, вы определяете тип элемента управления DataTrigger.
относится к. Вы также устанавливаете свойство Binding для привязки к IsAddingWidget.
свойство на вашей модели представления. Наконец, вы устанавливаете для свойства Value значение true.
Все это означает, что когда для свойства IsAddingWidget установлено значение true,
содержимое DataTrigger будет применено.
Это приводит вас к последнему изменению, которое является установщиком

```xml
<Сеттер
 Свойство = "Видимо"
 Значение = "Истина" />
```
Повторюсь, все это довольно многословно, пока вы не посчитаете
что вы можете определить действия, которые могут быть выполнены, когда ваше состояние
вошел/вышел.

# EnterActions и ExitActions

В качестве альтернативы простому определению значений свойств, которые будут установлены при
значение свойства IsAddingWidget становится истинным, как и в предыдущем
Например, вы можете определить действия, которые будут выполняться, когда значение
входит или выходит из определенного состояния. Что именно это значит? давайте возьмем
посмотрите на пример. Вы можете переписать использование триггера из предыдущего
пример как

```xml
<триггер данных
 TargetType="Граница"
 Binding="{Привязка IsAddingWidget}"
 Значение="Истина">
 <DataTrigger.EnterActions>
 <!—-действие для выполнения-->
 </DataTrigger.EnterActions>
 <DataTrigger.ExitActions>
 <!—-действие для выполнения-->
 </DataTrigger.ExitActions>
</Триггер Данных>
```
Учитывая вышеизложенное, можно констатировать следующее:
Когда свойство (IsAddingWidget) в Binding переходит в состояние
определено в Value (True), будут выполнены действия EnterActions.
Когда свойство (IsAddingWidget) в Binding выходит из состояния
определено в Value (False), ExitActions будут выполнены.
Теперь вам нужно определить действие, которое будет выполняться для этих сценариев.

# Создание действия триггера

.NET MAUI предоставляет базовый класс TriggerAction<T>, который позволяет
определить действие, которое будет выполняться в сценарии входа или выхода. Этот
позволяет вам построить более сложное поведение, которое может быть выполнено, когда
изменяется значение. При создании действия триггера вы можете использовать базовый класс
TriggerAction<T>, предоставленный .NET MAUI, а затем вам нужно переопределить
Метод вызова. Именно этот метод определяет, какое действие будет выполнено
при изменении значения. Давайте создадим собственное действие, которое вы сможете использовать.

# Создание действия ShowOverlayTriggerAction

  Во-первых, вам нужно найти место для размещения этого действия. Создать новую папку
в корневом проекте с именем Triggers, а затем добавьте новый файл класса с именем
```ShowOverlayTriggerAction.cs```. Затем вы можете добавить следующий код:

```Csharp
открытый класс ShowOverlayTriggerAction:
TriggerAction<визуальный элемент>
{
 общественное логическое значение ShowOverlay { получить; набор; }
 защищенное переопределение void Invoke (отправитель VisualElement)
 {
 sender.IsVisible = ПоказатьОверлей;
 }
}  
```
Этот код сейчас мало что делает. Это просто изменит
IsVisible элемента управления, к которому он прикреплен, когда значение изменяется.
Теперь вам нужно прикрепить его к элементу управления AddWidgetFrame.

# Использование ShowOverlayTriggerAction

Теперь вы можете добавить действие для выполнения разделов, которые вы оставили, когда
сначала добавьте DataTrigger к вашему элементу управления. Измените свой код в
Файл FixedBoardPage.xaml, изменения выделены жирным шрифтом.

```xml
<триггер данных
 TargetType="Граница"
 Binding="{Привязка IsAddingWidget}"
 Значение="Истина">
 <DataTrigger.EnterActions>
 <triggers:ShowOverlayTriggerAction ShowOverlay="Истина" />
 </DataTrigger.EnterActions>
  <DataTrigger.ExitActions>
 <triggers:ShowOverlayTriggerAction ShowOverlay="False" />
 </DataTrigger.ExitActions>
</Триггер Данных>
```
 Теперь это можно интерпретировать как, когда свойство IsAddingWidget
изменится на true, действие ShowOverlayTriggerAction будет вызвано с
ShowOverlay имеет значение true. Это приведет к тому, что элемент управления AddWidgetFrame
становится видимым. Затем, когда значение свойства IsAddingWidget изменится на
false, действие ShowOverlayTriggerAction будет вызываться с параметром ShowOverlay, равным
ЛОЖЬ. Это приведет к тому, что элемент управления AddWidgetFrame станет невидимым.
Также стоит отметить, что вы можете определить триггеры в стилях, т.е.
этот тип функциональности может быть повторно использован несколько раз без необходимости
продублируйте код.
Давайте пока отвлечемся от триггеров, чтобы посмотреть, как вы можете
анимировать элементы управления в .NET MAUI. Затем вы вернетесь и объедините триггеры и
анимации вместе, чтобы по-настоящему продемонстрировать силу действия, которое вы только что создали.
  
# Дальнейшее чтение
  
Вы только коснулись функциональности, которая
может быть достигнуто с помощью триггеров. рекомендую ознакомиться с
Документация Microsoft, чтобы узнать больше о том, как могут быть полезны триггеры:
https://learn.microsoft.com/dotnet/maui/fundamentals/triggers.  

# Анимации

Кажется, это может быть сложной темой, чтобы показать ее в печатной форме.
учитывая динамичный характер анимации, но это одна из моих любимых тем
поэтому я собираюсь показать это как можно лучше. Анимации предоставляют вам
строительные блоки, чтобы ваши приложения выглядели намного более естественными и
органический.
  
.NET MAUI предоставляет два основных способа выполнения анимации для
любой визуальный элемент. Вы рассмотрите каждый подход и то, как некоторые
с их помощью можно создавать анимации.
  
# Основные анимации

  .NET MAUI поставляется с набором готовых анимаций, доступных через расширение.
методы. Эти методы обеспечивают возможность поворота, перемещения, масштабирования и
исчезать VisualElement в течение определенного периода времени. Каждый из этих методов имеет
Для суффикса, например ScaleTo. Стоит отметить, что каждый из методов
для анимации являются асинхронными, и поэтому их нужно ожидать
если вы хотите знать, когда они закончились. Полный список анимации
методы следующие:
  
|Метод |Описание|
|:--------|:----------|
|FadeTo |Анимирует свойство Opacity элемента VisualElement|  
|RelScaleTo|Применяет анимированное пошаговое увеличение или уменьшение к свойству Scale объекта VisualElement|  
|RotateTo|Анимирует свойство Rotation объекта VisualElement|
|RelRotateTo|Применяет анимированное пошаговое увеличение или уменьшение к свойству Rotation объекта VisualElement|
|RotateXTo|Анимирует свойство RotationX объекта VisualElement|
|RotateYTo|Анимирует свойство RotationY объекта VisualElement|
|ScaleTo|Анимирует свойство Scale объекта VisualElement|
|ScaleXTo|Анимирует свойство ScaleX объекта VisualElement|
|ScaleYTo|Анимирует свойство ScaleY объекта VisualElement|
|TranslateTo|Анимирует свойства TranslationX и TranslationY объекта VisualElement|
  
Представление наложения, которое вы добавили в предыдущем разделе, просто показывает
немедленно и немедленно исчезает на основе привязки IsVisible
вы создали. Что, если вы анимируете оверлей так, чтобы он рос с нуля до
нужный размер? Не беспокойтесь о добавлении этого кода в ваше приложение.
только пока. Вы просмотрите несколько примеров, а затем добавите их в Visual Studio.
в разделе «Сочетание триггеров и анимаций». Основная причина
не добавляя его немедленно, потому что API анимации полагается на прямое
доступ к информации, связанной с представлением, и это нарушает шаблон MVVM.
Однако, как только вы изучите, как анимировать, вы сможете воспользоваться этим обучением.
и добавьте его в свою реализацию ShowOverlayTriggerAction.
Код для анимации VisualElement на удивление мал, как вы можете
см. в следующем примере:
  
AddWidgetFrame.Масштаб = 0;
ожидание AddWidgetFrame.ScaleTo(1, 500);
  
Во-первых, убедитесь, что AddWidgetFrame имеет масштаб 0, а затем
вы вызываете ScaleTo, говоря ему, чтобы он увеличивался до масштаба 1 (что составляет 100%) в течение
продолжительность 500 миллисекунд.
 
---
Все готовые методы анимации, кроме тех, которые запускаются
с помощью Rel выполните анимацию против VisualElements
существующее значение (например, для ScaleTo оно изменится с существующего
значение свойства Масштаб). Это означает, что вполне возможно, что нет
анимация произойдет, если и существующее свойство, и значение
предоставляемые методу одинаковы.
---
  
# Объединение базовых анимаций
  
Вполне возможно комбинировать базовые анимации, чтобы получить больше возможностей.
более сложные анимации. Есть два основных способа добиться этого.
  
# Цепочка анимаций
  
Вы можете объединить анимации в последовательность. Типичный пример
здесь, чтобы создать впечатление, что плитка переворачивается и дает
3D-эффект для пользователя. Ключевая деталь при цепочке анимаций заключается в том, что вы
ожидайте каждый вызов метода анимации, чтобы убедиться, что одна анимация
закончена до того, как начнется следующая.  
  
```Csharp
ожидание кадра.RotateXTo(90, 100);
frame.Content.IsVisible = tileViewModel.IsSelected;
ожидание кадра.RotateXTo(0, 100);  
```
  
# Параллельные анимации  
  
Подобно цепочке, вы можете выполнять несколько анимаций.
одновременно, просто не ожидая вызова каждого метода или альтернативно
жду всех звонков.  
  
```Csharp
AddWidgetFrame.Масштаб = 0;
AddWidgetFrame.IsVisible = истина;
AddWidgetFrame.Непрозрачность = 0;
ожидайте Task.WhenAll(
AddWidgetFrame.FadeTo(1),
AddWidgetFrame.ScaleTo(1, 500));  
```
На самом деле, эта анимация выглядит очень хорошим претендентом на ваше настоящее
реализация в реализации ShowOverlayTriggerAction.  
  
# Отмена анимации
  
Предоставление возможности отменить анимацию может быть чрезвычайно ценным.
особенность для пользователя. Довольно часто в приложениях, а преимущественно играх,
анимация будет отображаться, когда действие завершится. Такая анимация, если
блокировка может стать утомительной для пользователей, особенно если одна и та же анимация
часто повторяется. Таким образом, общий шаблон для подражания, когда пользователь
нажимает на анимируемый элемент управления, анимация отменяется.
Если вы хотите отменить анимацию, вы можете вызвать метод CancelAnimations.
метод расширения для VisualElement, который вы анимируете.  
  
```AddWidgetFrame.CancelAnimations();```  
  
# смягчения  
  
Анимации в целом будут двигаться механически, когда компьютер изменяет
ценность с течением времени. Сглаживания позволяют уйти от линейного обновления
эти значения, чтобы обеспечить гораздо более органичное и естественное движение.
.NET MAUI предлагает целый ряд готовых easings, а также есть даже
возможность построить свой собственный, если вы действительно хотите это сделать. Давайте посмотрим на
параметры, которые .NET MAUI предоставляет по умолчанию:  
  
|Функция ослабления |Описание|
|:--------|:----------|
|BounceIn |Отбрасывает анимацию в начале|    
|BounceOut |Отскакивает анимацию в конце|    
|CubicIn |Медленно ускоряет анимацию|    
|CubicInOut |Ускоряет анимацию в начале и замедляет в конце|  
|CubicOut |Быстро замедляет анимацию|  
|Линейный |Использует постоянную скорость и является функцией плавности по умолчанию|  
|SinIn |Плавно ускоряет анимацию|    
|SinInOut |Плавно ускоряет анимацию в начале и плавно замедляет анимацию в конце|    
|SinOut |Плавно замедляет анимацию|    
|SpringIn |Заставляет анимацию очень быстро ускоряться ближе к концу|    
|SpringOut |Заставляет анимацию быстро замедляться ближе к концу|    
  
Как общее правило, плавность, оканчивающаяся суффиксом In, запустит
анимация медленно и ускоряется, когда дело доходит до конца. Ослабление окончания
с суффиксом Out начнется быстро и замедлится к концу.
  
# Сложные анимации
  
NET MAUI предоставляет класс Animation. Это позволяет определить
сложные анимационные последовательности. На самом деле, готовые анимации, которые вы
описанные в разделе «Основные анимации», построены с использованием этого класса внутри
код .NET MAUI. С помощью этого класса можно анимировать любой визуальный элемент.
свойство VisualElement; например, вы можете анимировать изменение
Цвет фона или Цвет текста.
Класс Animation предоставляет возможность определять простые анимации.
вплоть до действительно довольно сложных анимаций. Взгляните на то, как
анимация ScaleTo может быть реализована, чтобы понять, что
классные предложения.  
  
 # Воссоздание анимации ScaleTo
  
 Вы также можете анимировать масштаб вашего элемента управления AddWidgetFrame с помощью
следующий:
  
```Csharp
публичная пустота ScaleTo()
{
 var анимация = новая анимация (v => AddWidgetFrame.Scale =
v, 0, 1);
 анимация.Commit(AddWidgetFrame, "ScaleTo");
}
```
При создании экземпляра класса Animation вы предоставляете
следующий параметр:  
  
```v => AddWidgetFrame.Scale = v```  
  
Это параметр обратного вызова, и он позволяет вам определить, что
свойство устанавливается во время анимации.
Следующий параметр — start. Это начальное значение, которое будет
передается в лямбду обратного вызова, которую вы определили в первом параметре. В вашей
Например, вы устанавливаете его равным 0, что означает, что элемент управления AddWidgetFrame не будет
виден, потому что он имеет масштаб 0.
Последний параметр, который вы передаете, это конец. Это результирующее значение, которое
будет передано в лямбду обратного вызова.
Анимация начнется только при вызове метода Commit. Этот
метод также позволяет определить, сколько времени это займет, а также как
часто для вызова определенного вами параметра обратного вызова.  
  
```animation.Commit(AddWidgetFrame, "ScaleTo", длина: 2000);```  

Этот код показывает простейший тип анимации, который вы можете создать.
в .NET MAUI. Вполне возможно создать гораздо более сложные
анимации. Для этого вам нужно создать анимацию, а затем
добавить дочерние анимации, чтобы определить изменения для каждого свойства и
различные последовательности в анимации.
  
# Создание анимации с резинкой

В качестве примера того, как построить сложную анимацию, я хотел бы показать
ты одна из моих любимых анимаций, анимация с резинкой. Этот
анимация имитирует перемещение визуального элемента по горизонтали, позволяя
пойти, а затем вернуться к своей первоначальной форме, как резиновая лента
бы. На рис. 8-3 показано, как это будет выглядеть, хотя и в движении.
  
![изображение](https://user-images.githubusercontent.com/26972859/231241929-f63ccb12-3b27-4901-9b15-b6b14f1d9eeb.png)
Рисунок 8-3. Отличительные кадры из анимации вы
строить  
  
Давайте создадим анимацию с помощью класса Animation, используя
понимание, которое вы получили в предыдущем разделе.
  
```Csharp
public void Rubberband (представление VisualElement)
{
 переменная анимация = новая анимация();
 анимация.Добавить(0.00, 0.30, новая анимация(v =>
view.ScaleX = v, 1.00, 1.25));
 анимация.Добавить(0.00, 0.30, новая анимация(v =>
view.ScaleY = v, 1,00, 0,75));
анимация.Добавить(0.30, 0.40, новая анимация(v =>
view.ScaleX = v, 1,25, 0,75));
 анимация.Добавить(0.30, 0.40, новая анимация(v =>
view.ScaleY = v, 0,75, 1,25));
 анимация.Добавить(0.40, 0.50, новая анимация(v =>
view.ScaleX = v, 0,75, 1,15));
 анимация.Добавить(0.40, 0.50, новая анимация(v =>
view.ScaleY = v, 1,25, 0,85));
 анимация.Добавить(0.50, 0.65, новая анимация(v =>
view.ScaleX = v, 1,15, 0,95));
 анимация.Добавить(0.50, 0.65, новая анимация(v =>
view.ScaleY = v, 0,85, 1,05));
 анимация.Добавить(0,65, 0,75, новая анимация(v =>
view.ScaleX = v, 0,95, 1,05));
 анимация.Добавить(0,65, 0,75, новая анимация(v =>
view.ScaleY = v, 1,05, 0,95));
 анимация.Добавить(0.75, 1.00, новая анимация(v =>
view.ScaleX = v, 1,05, 1,00));
 анимация.Добавить(0.75, 1.00, новая анимация(v =>
view.ScaleY = v, 0,95, 1,00));
 анимация.Commit(представление, "RubberbandAnimation",
длина: 2000 г.);
}
```
Да, я знаю, что это выглядит совсем иначе, чем предыдущая анимация, которую вы
построен. Давайте разберем части, которые кажутся незнакомыми.  
  
```  
анимация.Добавить(0.00, 0.30, новая анимация(v => view.ScaleX = v,
1,00, 1,25));
анимация.Добавить(0.00, 0.30, новая анимация(v => view.ScaleY = v,
1,00, 0,75));  
```  
Две строки выше определяют первый переход в вашей анимации. Ты
увидите, что свойство ScaleX изменится с 1,00 (100%) на 1,25 (125%)
а свойство ScaleY изменится с 1,00 (100%) на 0,75% (75%) от
текущий размер элемента управления. Это создает видимость того, что вид
растягивается. Ключевой новой частью для вас является использование метода Add и
первые два параметра. Это позволяет вам добавить анимацию, определенную
в качестве третьего параметра в качестве дочернего элемента анимации, к которой он добавляется.
В результате, когда вы фиксируете основную анимацию, все дочерние
анимация будет выполняться на основе последовательности, которую вы определили в этих
два первых параметра. Давайте рассмотрим, что означают эти параметры.
Первый параметр — это параметр beginAt. Это определяет, когда
добавляемая дочерняя анимация начнется во время общей анимации
последовательность. Итак, в примере вашей первой строки вы определяете 0,00, то есть
начнется, как только начнется анимация.
Второй параметр — это параметр FinishAt. Это определяет
когда добавляемый ребенок завершится во время общей анимации
последовательность. Итак, в примере с первой строкой вы определяете 0,30, то есть
закончится на 30% в последовательности анимации.  
  
---
Оба параметра beginAt и FinishAt должны быть указаны как
значение от 0 до 1 и считается процентом от общего
последовательность анимации. Вы также заметите, что я обычно включаю
десятичные разряды, даже если они равны 0; это действительно облегчает
прочитайте последовательность анимации, так как она гарантирует, что весь код
отступ таким же образом.
---

Наконец, вы вызываете метод Commit, как и раньше, чтобы начать анимацию.
последовательность.  
  
Теперь, когда вы рассмотрели анимацию зданий и некоторые возможные
примеры их использования, давайте объединим их с вашими знаниями о триггерах
чтобы ваш AddWidgetFrame действительно выглядел великолепно, когда он становится видимым.  
  
# Объединение триггеров и анимаций
  
Анимации — действительно мощный инструмент, но они требуют знания представления.
Именно здесь возможность запускать их из триггера позволяет вам
чтобы придерживаться подхода MVVM и сохранить свое представление и модель представления
чисто разделены.
Теперь, когда вы рассмотрели, как применить анимацию к вашему оверлею
представление и посмотрел на отделение представления от модели представления с помощью
триггеры, вы можете комбинировать их вместе, чтобы запускать анимацию и
сохранить разлуку.
Вернемся к файлу ShowOverlayTriggerAction.cs и добавим в него
анимация из раздела «Конкурентные анимации» (изменения
жирным шрифтом).  
  
```Csharp
пространство имен WidgetBoard.Triggers;
открытый класс ShowOverlayTriggerAction:
TriggerAction<визуальный элемент>
{
 общественное логическое значение ShowOverlay { получить; набор; }
 защищенное асинхронное переопределение void Invoke (отправитель VisualElement)
 {
 если (Шоуверлей)
 {
 отправитель.Масштаб = 0;
 sender.IsVisible = истина;
 отправитель.Непрозрачность = 0;
 ожидайте Task.WhenAll(
 отправитель.FadeTo(1),
 sender.ScaleTo(1, 500, Easing.SpringOut));
 }
 еще
 {
 ожидайте отправителя.ScaleTo(0, 500, Easing.SpringIn);
 отправитель.Непрозрачность = 0;
 sender.IsVisible = ложь;
 }
 }
}
```
  
Действие триггера теперь обеспечивает два ключевых визуальных изменения, когда
Значение свойства ShowOverlay изменяется. Когда свойство становится истинным,
элемент управления AddWidgetFrame будет исчезать в течение 250 мс и увеличиваться с
от 0 до 1 за 500 мс. Вы также можете использовать параметр Easing.SpringOut для
придайте немного более плавный вид изменениям в анимации.
Когда ShowOverlay становится ложным, вы просто меняете масштаб
анимация, чтобы показать, как он сжимается. Когда анимация завершится, вы
убедитесь, что элемент управления больше не виден.
На этом мы завершаем разделы о триггерах и анимации. Вы видели
как они могут помочь упростить представления и модели представлений, которые вы создаете
и в то же время предоставить некоторые действительно отличные функции, чтобы сделать
ваши приложения кажутся живыми. Я бы порекомендовал принять заявку на
вращение и наблюдение за анимацией в действии, к сожалению, мы не можем показать это
функционал выключен в печатном виде.  
  
# Краткое содержание  
  
В этой главе у вас есть

  • Предусмотрена возможность добавления виджета на доску

  • Рассмотрены различные параметры, доступные при отображении
наложение

  • Изучили, как можно определить информацию о стилях для
ваше приложение

  • Научился обращаться с устройствами, работающими в режиме Light and
темные режимы

  • Узнали, как применять триггеры для улучшения пользовательского интерфейса.

  • Рассмотрено, как анимировать части вашего приложения.

  • Изучили, что происходит, когда вы комбинируете триггеры.
и анимации

  В следующей главе вы будете

  • Узнайте о различных типах локальных данных.

  • Узнайте, что предлагает .NET MAUI с точки зрения локального файла.
места хранения и когда использовать каждое из них.

  • Получить представление о технологиях баз данных и
применить два разных варианта.

  • Измените свое приложение, чтобы сохранить и загрузить доски
создают ваши пользователи.

  • Получить представление о вариантах хранения небольших
биты данных или предпочтения.

  • Добавить возможность записи последней открытой доски.

  • Получить представление о вариантах хранения небольших
биты данных безопасно или SecureStorage.  
  
# Исходный код  

Полученный исходный код для этой главы можно найти на GitHub.
репозиторий на https://github.com/Apress/Introduction-MAUI/tree/
основной/ch08.  
  
# Дополнительное задание  
  
Я думаю, что вы можете поднять эти анимации на другой уровень и действительно сделать свой
приложение чувствовать себя живым! Попробуйте следующие возможные расширения!  
  
# Анимируем оверлей BoxView  
  
Вы добавили анимацию для представления границы с виджетом.
детали выбора внутри. Хорошим дальнейшим улучшением этого было бы
чтобы также анимировать BoxView, который вы используете в качестве полупрозрачного
наложение. Я лично думаю, что хорошая анимация FadeTo будет работать хорошо, но я
хотел бы услышать, что лучше всего подходит для вас.  
  
# Анимируйте новый виджет  
  
Чтобы действительно оживить приложение, вы можете рассмотреть возможность анимации
каждый виджет по мере его добавления на доску. У вас есть виджеты_
Метод ChildAdded внутри вашего файла BoardLayout.xaml.cs, где вы установили
Положение. Вы можете рассмотреть возможность расширения реализации этого метода
также анимировать новый виджет. Возможно, вы могли бы сделать новый виджет
масштабируйте аналогично тому, как представлена ​​​​ваша граница.  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

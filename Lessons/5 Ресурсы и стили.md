# Ресурсы и стили

## Ресурсы

Для совместного использования различными элементами общих компонентов в .NET MAUI применяются ресурсы. В данном случае под ресурсами понимаются не вспомогательные файлы - изображений и т.д., которые используются в приложении, а логические ресурсы, которые определяются в коде C# или XAML.

## Определение ресурсов

В качестве ресурса можно определить любой объект. Все ресурсы помещаются в объект ResourceDictionary. У каждого визуального объекта, например, ContentPage или Button, имеется свойство Resources, которое как раз хранит объект ResourceDictionary. Например, определим несколько ресурсов:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <ContentPage.Resources>
        <ResourceDictionary>
            <Color x:Key="textColor">#004D40</Color>
            <Color x:Key="backColor">#80CBC4</Color>
            <x:Double x:Key="margin">10</x:Double>
        </ResourceDictionary>
    </ContentPage.Resources>
    <StackLayout Padding="10">
        <Button Text="iOS" TextColor="{StaticResource Key=textColor}"
      BackgroundColor="{StaticResource Key=backColor}" Margin="{StaticResource Key=margin}" />
        <Button Text="Android" TextColor="{StaticResource textColor}"
      BackgroundColor="{StaticResource backColor}" Margin="{StaticResource margin}" />
    </StackLayout>
</ContentPage>
```
Каждый ресурс должен иметь ключ, задаваемый с помощью атрибута x:Key. Это своего рода уникальный идентификатор ресурса. Например:

```xml
<Color x:Key="textColor">#004D40</Color>
```
Здесь в качестве ресурса определяется объект Color. Этот объект имеет ключ textColor и значение #004D40.

Чтобы обратиться к этому ресурсу в коде, надо использовать расширение StaticResource:

```xml
TextColor="{StaticResource Key=textColor}"
```
Свойство Key через ключ ресурса будет ссылаться на данный ресурс. Стоит отметить, что само слово Key можно не указывать:

```xml
TextColor="{StaticResource textColor}"
```

Таким образом, здесь определяется и применяется три ресурса: textColor (для цвета текста), backColor (для цвета фона) и margin (для размера внешних отступов). То есть в итоге получится следующая страница:

!(https://metanit.com/sharp/maui/pics/6.1.png)

При этом важно, что на данный ресурс могут ссылаться сразу несколько элементов. Например, мы захотели создать общий для всех кнопок цвет фона. И в этом случае проще определить цветовой ресурс, чем присваивать свойству BackgroundColor у каждой кнопки конкретный цвет. А в случае, если мы захотим изметь цвет кнопок на другой, то не надо будет менять свойство BackgroundColor у всех кнопок. Достаточно будет поменять значение ресурса.

## Уровни ресурсов

Ресурсы могут определяться на трех уровнях:

На уровне отдельного элемента управления. Такие ресурсы могут применяться ко всем вложенным элементам, которые определены внутри этого элемента

На уровне всей страницы. Такие ресурсы могут применяться ко всем элементам на странице

На уровне всего приложения. Эти ресурсы доступны из любого места и из любой страницы приложения.

На уровне всего приложения (глобальные ресурсы)

Когда парсер XAML встречает в разметке расширения StaticResource или DynamicResource, он сначала ищет соответствующий ресурс по ключу в словаре ресурсов текущего элемента. Если в ресурсах элемента отсутствует ресурс с указанным ключом, то парсер поднимается выше по дереву элементов и ищет ресурс в ресурсах элементов-контейнеров, затем в ресурсах текущей страницы и в конце в ресурсах приложения. Поиск прекращается, когда когда найден первый попавшийся ресурс, который соответствует ключу. Если парсер нигде не смог найти ресурс, то он генерирует исключение XamlParseException.

## Ресурсы на уровне элемента

Выше в примере ресурсы определялись а уровне страницы. Теперь опустимся на уровень ниже и определим их на уровне элемента StackLayout:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="10">
        <StackLayout.Resources>
            <ResourceDictionary>
                <Color x:Key="textColor">#004D40</Color>
                <Color x:Key="backColor">#80CBC4</Color>
                <x:Double x:Key="margin">10</x:Double>
            </ResourceDictionary>
        </StackLayout.Resources>
        <Button Text="iOS" TextColor="{StaticResource Key=textColor}"
      BackgroundColor="{StaticResource Key=backColor}" Margin="{StaticResource Key=margin}" />
        <Button Text="Android" TextColor="{StaticResource Key=textColor}"
      BackgroundColor="{StaticResource Key=backColor}" Margin="{StaticResource Key=margin}" />
    </StackLayout>
</ContentPage>
```

По сути результат в данном случае будет от же самый, так как все элементы все равно определены внутри StackLayout. Ресурсы элемента будут доступны данному элементу и всем вложенным в него элементам. Подобным образом можно определять ресурсы и для других элементов, например, для отдельной кнопки.

# Ресурсы приложения

Для определения общих для всего приложения ресурсов в проекте присутствует файл App.xaml, который связан с основным файлом приложения App.xaml.cs. По умолчанию файл App.xaml уже содержит некоторые ресурсы:

```xml
<?xml version = "1.0" encoding = "UTF-8" ?>
<Application xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:local="clr-namespace:HelloApp"
             x:Class="HelloApp.App">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Resources/Styles/Colors.xaml" />
                <ResourceDictionary Source="Resources/Styles/Styles.xaml" />
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
</Application>
```
!(https://metanit.com/sharp/maui/pics/6.2.png)

Здесь словарь ресурсов ResourceDictionary содержит элемент ```<ResourceDictionary.MergedDictionaries>``` с помощью которого объединяются другие словари в один. В данном случае определяются внешние словари, которые расположены в проектах во внешних файлах по пути "Resources/Styles/Colors.xaml" и "Resources/Styles/Styles.xaml".

Добавим наши собственные глобальные ресурсы и для этого изменим файл App.xaml следующим образом:

```xml
<?xml version = "1.0" encoding = "UTF-8" ?>
<Application xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             xmlns:local="clr-namespace:HelloApp"
             x:Class="HelloApp.App">
    <Application.Resources>
        <ResourceDictionary>
            <ResourceDictionary.MergedDictionaries>
                <ResourceDictionary Source="Resources/Styles/Colors.xaml" />
                <ResourceDictionary Source="Resources/Styles/Styles.xaml" />
                <ResourceDictionary>
                    <Color x:Key="textColor">#C0392B</Color>
                    <Color x:Key="backColor">#fab1a0</Color>
                    <x:Double x:Key="margin">10</x:Double>
                </ResourceDictionary>
            </ResourceDictionary.MergedDictionaries>
        </ResourceDictionary>
    </Application.Resources>
</Application>
```

Для объединения нашего словаря с другими он добавляется в виде объекта ResourceDictionary в элемент <ResourceDictionary.MergedDictionaries>. То есть здесь определены все те же ресурсы, что и ранее, только теперь они будут доступны для любого элемента на любой стрнице внутри приложения.

И в этом случае мы просто можем их использовать:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="10">
        <Button Text="iOS" TextColor="{StaticResource Key=textColor}"
      BackgroundColor="{StaticResource Key=backColor}" Margin="{StaticResource Key=margin}" />
        <Button Text="Android" TextColor="{StaticResource Key=textColor}"
      BackgroundColor="{StaticResource Key=backColor}" Margin="{StaticResource Key=margin}" />
    </StackLayout>
</ContentPage>
```

!(https://metanit.com/sharp/maui/pics/6.3.png)

## Управление ресурсами в коде C#

Аналогичный пример использования ресурсов выглядел бы следующим образом:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            Color textColor = Color.FromArgb("#004D40");
            Color backColor = Color.FromArgb("#80CBC4");
            int margin = 10;
 
            // определяем словарь ресурсов
            ResourceDictionary resDict = new ResourceDictionary();
            // добавляем ресурсы в словарь
            resDict.Add("textColor", textColor);
            resDict.Add("backColor", backColor);
            resDict.Add("margin", margin);
            // устанавливаем словарь ресурсов для текущей страницы
            this.Resources = resDict;
 
            Button iosButton = new Button { Text = "iOS" };
            // получаем ресурс из словаря
            iosButton.TextColor = (Color)Resources["textColor"];
            iosButton.BackgroundColor = (Color)Resources["backColor"];
            iosButton.Margin = (int)Resources["margin"];
 
            Button androidButton = new Button { Text = "Android" };
            androidButton.TextColor = (Color)Resources["textColor"];
            androidButton.BackgroundColor = (Color)Resources["backColor"];
            androidButton.Margin = (int)Resources["margin"];
 
            Content = new StackLayout
            {
                Padding = 10,
                Children = { iosButton, androidButton }
            };
        }
    }
}
```

В данном случае опреляется словаоь ресурсов уровня страницы. Для управления ресурсами применяются методы и свойства ResourceDictionary:

Add(string key, object resource): добавляет объект с ключом key в словарь, причем в словарь можно добавить любой объект, главное ему сопоставить ключ

Remove(string key): удаляет из словаря ресурс с ключом key

Чтобы найти ресурс в словаре, достаточно обратиться по ключу:

```Csharp
androidButton.TextColor = (Color)Resources["textColor"];
```

Так как словарь ресурсов хранит объекты типа object, то при получении ресурса его надо привести к нужному типу.

## Динамические ресурсы

Ресурсы могут быть статическими и динамическими. Рассмотрим разницу на примере:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <ContentPage.Resources>
        <ResourceDictionary>
            <Color x:Key="textColor">#1976D2</Color>
        </ResourceDictionary>
    </ContentPage.Resources>
    <StackLayout>
        <Button Text="Изменить" BackgroundColor="white"
                WidthRequest="120"
                TextColor="{StaticResource textColor}"
                Clicked="ColorChange" />
    </StackLayout>
</ContentPage>
```

В файле кода C# добавим обработчик для кнопки:

```Csharp
namespace HelloApp;
 
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
    }
    private void ColorChange(object sender, EventArgs e)
    {
        Color textColor = (Color)Resources["textColor"];
        Resources["textColor"] = textColor.ToHex() == "#1976D2" ? 
            Color.FromArgb("#00838F") : Color.FromArgb("#1976D2");
    }
}
```

То есть здесь у кнопки цвет текста привязан к ресурсу "textColor". В обработчике кнопки мы пытаемся поменять значение ресурса - если цвет "#1976D2", то меняем на "#00838F" и наоборот. Однако после запуска приложения и нажатия на кнопку кнопка не поменяет цвет текста, так как ресурс "textColor" установлен как статический. То есть после установки он уже не изменяется.

И чтобы изменение срабатывало, данный ресурс надо установить как динамический. Для этого вместо StaticResource используется расширение DynamicResource. Изменим определение кнопки следующим образом:

```xml
<Button Text="Изменить" BackgroundColor="white"
    WidthRequest="120"
    TextColor="{DynamicResource textColor}"
    Clicked="ColorChange" />
```

Весь остальной код остается без изменений.

!(https://metanit.com/sharp/maui/pics/6.4.png)

Стоит отметить, что если DynamicResource не найдет нужного ресурса по ключу, то никакой ошибки не возникнет, и приложение также будет работать.

## Установка динамических ресурсов в коде C#

Для установки динамического ресурса в коде C# применяется метод SetDynamicResource():

```Csharp
button1.SetDynamicResource(Button.TextColorProperty, "resourceKey");
```
Первый параметр - свойство элемента, а второй - ключ ресурса. Например:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            ResourceDictionary resDict = new ResourceDictionary();
            // добавляем ресурсы в словарь
            resDict.Add("textColor", Color.FromArgb("#1976D2"));
 
            // устанавливаем словарь ресурсов
            this.Resources = resDict;
 
            Button androidButton = new Button 
            { 
                Text = "Android", 
                WidthRequest=120,
                BackgroundColor = Colors.White
            };
            // устанавливаем динамический ресурс
            androidButton.SetDynamicResource(Button.TextColorProperty, "textColor");
            androidButton.Clicked += ColorChange;
 
            Content = new StackLayout
            {
                Padding = 20,
                Children = { androidButton }
            };
        }
        private void ColorChange(object sender, EventArgs e)
        {
            Color textColor = (Color)Resources["textColor"];
            Resources["textColor"] = textColor.ToHex() == "#1976D2" ?
                Color.FromArgb("#00838F") : Color.FromArgb("#1976D2");
        }
    }
}
```

## Стили

Стили представляют набор свойств и их значений, которые могут применяться к элементам. Основная задача стилей - создать стилевое единообразие для элементов интерфейса. Стили хранятся в ресурсах и отделяют стилизацию элементов от пользовательского интерфейса.

Чтобы понять, как стили упрощают нам работу, рассмотрим простой пример:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="20">
        <Button Text="iOS" TextColor="#004D40" BackgroundColor="#80CBC4" Margin="10" />
        <Button Text="Android" TextColor="#004D40" BackgroundColor="#80CBC4" Margin="10" />
    </StackLayout>
</ContentPage>
```
Здесь определены две кнопки, которые фактически имеют один и тот же стиль: одни и те же цвет фона и текста, а также размер внешних отступов. Единственное отличие состоит в тексте кнопки.

Однако в данном случае мы вынуждены повторяться и повторно определять один и те же свойства и одни и те же значения для каждого из элементов.

!(https://metanit.com/sharp/maui/pics/6.5.png)

Теперь применим стили:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <ContentPage.Resources>
        <ResourceDictionary>
            <Style x:Key="buttonStyle" TargetType="Button">
                <Setter Property="TextColor" Value="#004D40" />
                <Setter Property="BackgroundColor" Value="#80CBC4" />
                <Setter Property="Margin" Value="10" />
            </Style>
        </ResourceDictionary>
    </ContentPage.Resources>
    <StackLayout Padding="20">
        <Button Text="iOS" Style="{StaticResource buttonStyle}" />
        <Button Text="Android" Style="{StaticResource buttonStyle}" />
    </StackLayout>
</ContentPage>
```

Стиль создается как ресурс с помощью объекта Style и, как любой другой ресурс, он обязательно должен иметь ключ. Атрибут TargetType указывает, к какому типу оносится стиль. В данном случае это тип Button.

С помощью коллекции Setters определяется группа свойств, входящих в стиль. В нее входят объекты Setter, которые имеют следующие свойства:

- Property: указывает на свойство, к которому будет применять данный сеттер. При этом свойство должно представлять тип BindableProperty

- Value: собственно значение свойства

Поскольку стиль определяется как ресурс, то для его установки используются расширения StaticResource или DynamicResource (если стиль динамический):

```xml
<Button Text="iOS" Style="{StaticResource buttonStyle}" />
<Button Text="Android" Style="{DynamicResource buttonStyle}" />
```

Иногда свойство может представлять сложный объект, либо же значение формируется сложным способом. Например, у класса Color есть конструктор, который принимет три значения int для трех составляющих цвет: красной, зеленой и синей компоненты. В этом случае мы можем расписать формирование объекта:

```xml
<Style x:Key="buttonStyle" TargetType="Button">
    <Setter Property="TextColor">
        <Setter.Value>
            <Color>
                <x:Arguments>
                    <x:Int32>0</x:Int32>
                    <x:Int32>75</x:Int32>
                    <x:Int32>25</x:Int32>
                </x:Arguments>
            </Color>
        </Setter.Value>
    </Setter>
    <Setter Property="BackgroundColor" Value="#80CBC4" />
    <Setter Property="Margin" Value="10" />
</Style>
```

Также в качестве значения можно устанавливать ссылку на другой ресурс:

```xml
<ContentPage.Resources>
    <ResourceDictionary>
      <Color x:Key="greenColor">#004D40</Color>
      <Style x:Key="buttonStyle" TargetType="Button">
        <Setter Property="TextColor" Value="{StaticResource Key=greenColor}" />
        <Setter Property="BackgroundColor" Value="#80CBC4" />
        <Setter Property="Margin" Value="10" />
      </Style>
    </ResourceDictionary>
</ContentPage.Resources>
```

## TargetType

Если нам надо создать общий стиль для элементов определенного типа, то можно не задавать ключ ресурса, а достаточно установить у стиля атрибут TargetType, в который передается тип элементов:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <ContentPage.Resources>
        <Style TargetType="Button">
            <Setter Property="TextColor" Value="#004D40" />
            <Setter Property="BackgroundColor" Value="#80CBC4" />
            <Setter Property="Margin" Value="10" />
        </Style>
    </ContentPage.Resources>
    <StackLayout Padding="20">
        <Button Text="iOS" />
        <Button Text="Android" />
    </StackLayout>
</ContentPage>
```

Теперь у кнопок не надо будет указывать ресурс стиля, так как стиль будет автоматически применяться ко всем объектам типа, который указан в атрибуте TargetType.

## Переопределение стилей

Стиль позволяет задать некоторые начальные значения. Однако элемент может переопределить отдельные значения из стиля:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <ContentPage.Resources>
        <Style x:Key="buttonStyle" TargetType="Button">
            <Setter Property="TextColor" Value="#004D40" />
            <Setter Property="BackgroundColor" Value="#80CBC4" />
            <Setter Property="Margin" Value="10" />
        </Style>
    </ContentPage.Resources>
    <StackLayout Padding="20">
        <Button Text="iOS" Style="{StaticResource buttonStyle}" />
        <Button Text="Android" Style="{StaticResource buttonStyle}" BackgroundColor="#B2EBF2" />
    </StackLayout>
</ContentPage>
```

В данном случае кнопка получает все значения из стиля buttonStyle, однако переопределяет цвет текста, так как прямое использование атрибутов элемента имеет приоритет над применяемым стилем.

!(https://metanit.com/sharp/maui/pics/6.6.png)

## Установка стилей в коде

Для создания стиля в коде используется объект Style:

```Csharp
namespace HelloApp
{
    class StartPage : ContentPage
    {
        public StartPage()
        {
            Style buttonStyle = new Style(typeof(Button))
            {
                Setters =
                {
                    new Setter
                    {
                        Property = Button.TextColorProperty,
                        Value = Color.FromArgb("#004D40")
                    },
                    new Setter
                    {
                        Property = Button.BackgroundColorProperty,
                        Value = Color.FromArgb("#80CBC4")
                    },
                    new Setter
                    {
                        Property = Button.MarginProperty,
                        Value = 10
                    }
                }
            };
 
            Button button1 = new Button { Text = "iOS", Style = buttonStyle };
            Button button2 = new Button { Text = "Android", Style = buttonStyle };
 
            Content = new StackLayout
            {
                Padding = 20,
                Children = { button1, button2 }
            };
        }
    }
}
```

В конструктор объекта Style передается тип, для которого предназначен данный стиль - аналогично использованию атрибута TargetType в XAML.

При создании стиля в коде следует учитывать, что в качестве свойств указываются именно BindableProperty (как правило называется по имени обычного свойства с суффиксом Property). Например:

```Csharp
Property = Button.TextColorProperty
```
А не просто TextColor. Причем в начале идет тип (в данном случае Button), а потом идет название свойства (здесь TextColorProperty).

## Наследование стилей

С помощью свойства BasedOn можно наследовать один стиль от другого. Например:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <ContentPage.Resources>
        <ResourceDictionary>
            <Style x:Key="baseButtonStyle" TargetType="Button">
                <Setter Property="Margin" Value="10" />
                <Setter Property="WidthRequest" Value="120" />
                <Setter Property="TextColor" Value="#01579B" />
                <Setter Property="BackgroundColor" Value="#fff" />
            </Style>
            <Style x:Key="greenButtonStyle" TargetType="Button" BasedOn="{StaticResource baseButtonStyle}">
                <Setter Property="TextColor" Value="#004D40" />
                <Setter Property="BackgroundColor" Value="#80CBC4" />
            </Style>
        </ResourceDictionary>
    </ContentPage.Resources>
    <StackLayout Padding="20">
        <Button Text="iOS" Style="{StaticResource baseButtonStyle}" />
        <Button Text="Android" Style="{StaticResource greenButtonStyle}" />
    </StackLayout>
</ContentPage>
```

Здесь у стиля greenButtonStyle атрибут BasedOn указывает на другой стиль baseButtonStyle. И таким образом, стиль greenButtonStyle будет перенимать все установки от baseButtonStyle. При этом наследующий стиль может переопределить значения из наследуемого. В частости, здесь переопределяется значение свойства TextColor и BackgroundColor.

При наследовании стилей важно, чтобы тип элементов, указанный в качестве значения атрибута TargetType, совпадал. Например, в данном случае оба стиля применяется к элементам типа Button.

Наследование в коде C# осуществляется с помощью установки у стиля свойства BasedOn:

```Csharp
Style basedStyle = new Style(typeof(Button));
Style childStyle = new Style(typeof(Button))
{
    BasedOn = basedStyle
};
```

## Встроенные стили

По умолчанию проект .NET MAUI уже содержит ряд встроенных стилей. Их можно найти в файле Styles.xaml в папке Resources/Styles:

!(https://metanit.com/sharp/maui/pics/6.7.png)

Эти стили подключаются в качестве глобальных ресурсов в файле App.xaml и предоставляют базую стилизацию для некоторых элементов.

# Подключение внешних ресурсов

Чтобы не захламлять разметку xaml определением ресурсов, особенно когда этих ресурсов много, их можно выносить в отдельные файлы и при необходимости подключать. Если подобные ресурсы представляют стили, то по умолчанию в проекте .NET MAUI уже имеется для хранения таких файлов каталог Resources/Styles. Можно использовать эту папку, можно создать другую, учитывая, что ресурсы не сводятся только к стилям. Но в данном случае для примера для хранения своих ресурсов создадим в проекте новую папку, которую назовем MyResources. Добавим в нее два xaml-файла, которые назовем GreenButtonStyle.xaml и BlueButtonStyle.xaml

Для создания словарей ресурсов Visual Studio предоставляет встроенный шаблон .NET MAUI ResourceDictionary (XAML):

!(https://metanit.com/sharp/maui/pics/6.8.png)

Но в реальности можно просто добавить текстовые файлы с расширением .xaml.

Если мы воспользовались шаблоном .NET MAUI ResourceDictionary (XAML) для добавления файлов, то по умолчанию вместе с файлами xaml Visual Studio добавляет связанные с этими файлами файлы с кодом C#, которые в данном случае называются GreenButtonStyle.xaml.cs и BlueButtonStyle.xaml.cs и которые призваны содержать некоторую связанную с инициализацией словарей логику. Они в данном случае не нужны, поэтому удалим их.

!(https://metanit.com/sharp/maui/pics/6.9.png)

В файле GreenButtonStyle.xaml определим стиль зеленой кнопки:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ResourceDictionary xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml">
    <Style x:Key="greenButtonStyle" TargetType="Button">
        <Setter Property="TextColor" Value="#004D40" />
        <Setter Property="BackgroundColor" Value="#80CBC4" />
        <Setter Property="Margin" Value="10" />
    </Style>
</ResourceDictionary>
```

Здесь в словаре ресурсов определен один ресурс - стиль с ключом "greenButtonStyle", но естественно при необходимости мы можем определить и другие ресурсы.

В файле BlueButtonStyle.xaml определим стиль синей кнопки:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ResourceDictionary xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml">
    <Style x:Key="blueButtonStyle" TargetType="Button">
        <Setter Property="TextColor" Value="#01579B" />
        <Setter Property="BackgroundColor" Value="#81D4FA" />
        <Setter Property="Margin" Value="10" />
    </Style>
</ResourceDictionary>
```

Здесь в словаре ресурсов определен ресурс с ключом "blueButtonStyle". Теперь подключим эти ресурсы на страницу в коде xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <ContentPage.Resources>
        <ResourceDictionary Source="MyResources/GreenButtonStyle.xaml" />
        <ResourceDictionary Source="MyResources/BlueButtonStyle.xaml" />
    </ContentPage.Resources>
    <StackLayout Padding="20">
        <Button Text="iOS" Style="{StaticResource blueButtonStyle}" />
        <Button Text="Android" Style="{StaticResource greenButtonStyle}" />
    </StackLayout>
</ContentPage>
```

Для подключения внешних ресурсов в коллекцию ресурсов страницы добавляются словари ресурсов - элементы ResourceDictionary. У каждого словаря устанавливается атрибут Source, который указывает на расположение файла ресурсов.

Для теста на странице определены две кнопки, которые используют подключенные ресурсы

!(https://metanit.com/sharp/maui/pics/6.10.png)

Подобным образом можно подключать словари ресурсов не только на страницу, но и в другие элементы.

# Стилизация с помощью CSS

.NET MAUI поддерживает стилизацию элементов с помощью стилей CSS (почти так же, как в HTML). Правда, при использовании CSS в .NET MAUI есть ряд особенностей и ограничений.

Итак, для хранения файлов css создадим в проекте папке styles и добавим в нее текстовый файл, который переименуем в mystyles.css. После добавления файла убедимся, что для в окне свойств в поле Build Action задано значение MauiCss (хотя при добавлении файла css такая установка должна происходить по умолчанию):

!(https://metanit.com/sharp/maui/pics/6.13.png)

Определим в файле mystyles.css следующее содержимое:

```css
^contentpage {
    background-color: #fefefe;
}
 
stacklayout {
    padding: 20;
}
 
stacklayout label {
    font-family: Verdana;
    margin: 5;
}
 
#header {
    font-size: 18;
    font-weight: bold;
    text-decoration:underline;
}
 
.english {
    font-weight: bold;
    font-size: 14;
    color: darkblue;
}
 
.russian {
    font-size: 12;
}
```

Как и в обычном файле css, здесь стили задаются с помощью селекторов. В то же время было бы некорректным распространять свой опыт работы с css на .NET MAUI, поскольку в данном случае есть ряд особенностей. Так, вначале идет селектор ^contentpage. Он задает стили для элементов, которые находятся в элементе ContentPage. В стандартном CSS подобные селекторы не применяется, это является особенностью .NET MAUI.

Затем последовательно устанавливаются стили для элементов StackLayout и Label, а также для элементов с идентификатором header и классами english и russian.

Для тестирования css определим в файле страницы MainPage.xaml следующий интерфейс:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <ContentPage.Resources>
        <StyleSheet Source="/styles/mystyles.css" />
    </ContentPage.Resources>
 
    <StackLayout>
        <Label x:Name="header" StyleId="header" Text="Words"/>
        <Label Text="apple" StyleClass="english" />
        <Label Text="яблоко" StyleClass="russian" />
        <Label Text="house" StyleClass="english" />
        <Label Text="дом" StyleClass="russian" />
        <Label Text="bread" StyleClass="english" />
        <Label Text="хлеб" StyleClass="russian" />
    </StackLayout>
</ContentPage>
```

Файл стилей css подключается на страницу как обычный ресурс с помощью элемента StyleSheet. У этого элемента устанавливается атрибут Source, который указывается на путь к файлу css. В данном случае файл css расположен в корневой папке главного проекта, поэтому прописываем путь "/styles/mystyles.css".

Для установки стилей в CSS могут использоваться различные селекторы, в том числе классы и идентификаторы. Для этого для каждого визуального элемента были добавлены два атрибута. Свойство StyleId позволяет задать идентификатор для элемента (в html это атрибут id), а свойство StyleClass задает название класса элемента (в html ему соответствует атрибут class). При этом не стоит путать свойства Style и StyleClass: к css относится только последнее.

В итоге страница будет выглядеть следующим образом:

!(https://metanit.com/sharp/maui/pics/6.14.png)

Таким образом, подобно HTML в .NET MAUI можно подключать стили CSS, однако в то же время в .NET MAUI и C# есть немало ограничений на этот счет, о которых речь пойдет далее.

## Подключение файла стилей

Подключать файл стилей CSS можно в XAML, либо через код C#.

В XAML файл CSS подключается как ресурс через элемент StyleSheet, у которого атрибут Source принимает путь к файлу относительно корня главного проекта:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <ContentPage.Resources>
        <StyleSheet Source="/styles/mystyles.css" />
    </ContentPage.Resources>
 
    <!-- содержимое страницы -->
 
</ContentPage>
```

Загрузка файла стилей коде C#:

```Csharp
using Microsoft.Maui.Controls.StyleSheets;
using System.Reflection;
 
namespace HelloApp;
 
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
        this.Resources.Add(StyleSheet.FromResource
                    ("styles/mystyles.css", IntrospectionExtensions.GetTypeInfo(typeof(MainPage)).Assembly));
    }
}
```

Поскольку файл стилей используется как ресурс, он добавляется в коллекцию ресурсов страницы с помощью метода Resources.Add(). Для загрузки самих стилей применяется метод StyleSheet.FromResource(). Первый аргумент этого метода - путь к файлу стилй внутри проекта - в данном случае название файла, так как он располагается в корне проекта. А второй аргумент - сборка, которая содержит файл стилей.

## Определение стилей в XAML и коде C#

В HTML с помощью тега style можно определять стили напрямую на странице, не используя сторонних файлов с расширением *.css. Также можно поступать и в .NET MAUI и C#. Определение стилей в XAML:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
 
    <ContentPage.Resources>
        <StyleSheet>
            <![CDATA[
            ^contentpage {
                background-color: lightcyan
            }
 
            stacklayout {
                margin: 15;
                padding: 10;
            }
            ]]>
        </StyleSheet>
    </ContentPage.Resources>
 
    <!-- содержимое страницы -->
     
</ContentPage>
```
Определение стилей в коде C#:

```Csharp
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
 
        using (var reader = new System.IO.StringReader("^contentpage { background-color: lightgray; }"))
        {
            this.Resources.Add(StyleSheet.FromReader(reader));
        }
    }
}
```

# Определение селекторов

При определении стилей в .NET MAUI в целом мы можем использовать большинство селекторов, которые принимаются в стандартном CSS. В тоже время есть некоторые отличия.

Список применяемых в .NET MAUI селекторов:

- *

Устанавливает стили для всех элементов

- element

```css
stacklayout {
    margin: 20;
}
```

Используя название типа элемента, мы можем применить к нему стили:

- ^корневой_элемент

С помощью селектора ^корневой_элемент можно определить стили для всех элементов, который расположены в данном элементе:

```css
^contentpage {
    background-color: green;
}
^stacklayout {
    color:red;
}
```

В данном случае для всех элементов в ContentPage устанавливается в качестве фона зеленый цвет, а для элементов в StackLayout - красный цвет для шрифта.

- #id

Идентификатор элемента задается с помощью свойства StyleId. Например, стили для идентификатора header:

```css
#header {
    color:red;
}
```

- class

Класс элемента задается с помощью свойства StyleClass. Например, стили для класса "english":

```css
.english {
    font-weight: bold;
    font-size: large;
    color: darkblue;
}
```

- element element

С помощью селектора типа родительский_элемент дочерний_элемент можно задать стили для дочернего элемента, который располагается в определенном родительском элементе:

```css
stacklayout label {
    font-family:Verdana;
}
```

В данном случае задан стиль для элементов Label, которые располагаются в элементе StackLayout.

При этом дочерний элемент не обязательно должен располагаться напрямую в родительском элементе, например:

```xml
<StackLayout>
    <Frame OutlineColor="Accent">
        <Label Text=".NET MAUI и C#" />
    </Frame>
</StackLayout>
```

- element>element

Если необходимо определим стиль только для прямых дочерних элементов, корый располагаются непосредственно в родительском элементе, то применяется конструкция родительский_элемент>дочерний_элемент:

```css
stacklayout > label {
    font-family:Verdana;
}
```

- element, element

Устанавливает стили для ряда элементов:

```css
label, button {
    background-color: green;
}
```
Устанавливает фон для кнопок и меток

- element+element

Устанавливает стили для элемента, который идет сразу за определенным элементом (оба элемента являются сестринскими):

```css
label+button {
    background-color: green;
}
```

Устанавливает фон для кнопки, которая располагается сразу после метки

- element~element

Устанавливает стили для элемента, который идет непосредственно перед определенным элементом (оба элемента являются сестринскими):

```css
label~button {
    background-color: green;
}
```

Устанавливает фон для кнопки, которая располагается перед элементами Label

В то же время не поддерживаются следующие селекторы:

- [attribute] (выбора по атрибуту)

- @media и @supports

- : и ::

### Margin и padding

Ряд свойств: margin (а также margin-left, margin-right, margin-top, margin-bottom) и padding (padding-bottom, padding-left, padding-right, padding-top) принимают значение thickness. В реальности мы можем присвоить одно, два, три или четыре числовых значения:

- Одно значение задает отступ для всех сторон

- Два значения задают отступы соответственно по вертикали и по горизонтали

- Три значения задают соответственно верхний отступ, отступ по горизонтали (как справа, так и слева) и отступ снизу

- Четыре значения задают соответственно отступ сверху, справа, снизу и слева

Примеры:

```css
margin: 10;
margin: 20 10;
margin: 15 20 10;
margin: 45 15 20 10;
```

### Установка цвета

Стилевые свойства background-color, border-color и color принимают значение цвета, которое можно задать различными способами:

- Предустановленные значения, например, green, red и т.д.

- Шестнадцатеричные значения в форматах: #rgb, #argb, #rrggbb, #aarrggbb

- Значения rgb, например, rgb(255,0,0), rgb(100%,0%,0%). Значения находятся в диапазонах 0-255 или 0%-100%.

- Значения rgba, например, rgba(255, 0, 0, 0.8),rgba(100%, 0%, 0%, 0.8). Четвертое значение - прозрачность находится в диапазоне 0.0-1.0.

- Значения hsl, например, hsl(120, 100%, 50%). Значение h в диапазоне 0-360, а значения s и l в диапазоне 0%-100%.

- Значения hsla, например, hsla(120, 100%, 50%, .8). Последнее значение находится в диапазонах 0.0-1.0.

## Visual State Manager и визуальные состояния

Visual State Manager (менеджер визуальных состояний) позволяет организовать изменения визуального интерфейса. По умолчанию Visual State Manager прикрепляет к элементам управления группу из трех состояний:

- Disabled: элемент отключен для использования

- Focused: элемент получил фокус и используется в текущий момент

- Normal: стандартное состояние элемента

- PointerOver: указатель мыши находится над элементом

Состояния Normal, Disabled, Focused и PointerOver поддерживается для объектов всех классов, которые унаследованы от VisualElement (в том числе классов View и Page). Кроме того, при необходимости можно определять свои визуальные состояния.

Опреждение визуальных состояний в XAMLИтак, применим визуальные состояния к текстовому полю Entry:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage"> 
    <StackLayout>
        <Entry x:Name="entry" Text="Hello METANIT.COM!">
            <VisualStateManager.VisualStateGroups>
                <VisualStateGroup x:Name="CustomStates">
 
                    <VisualState x:Name="Focused">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="#004D40" />
                            <Setter Property="BackgroundColor" Value="#B2DFDB" />
                        </VisualState.Setters>
                    </VisualState>
 
                    <VisualState x:Name="PointerOver">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="#004D40" />
                            <Setter Property="FontAttributes" Value="Bold" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateManager.VisualStateGroups>
        </Entry>
    </StackLayout>
</ContentPage>
```

Визуальные состояния определяются с помощью прикрепляемого свойства VisualStateManager.VisualStateGroups. Оно имеет тип VisualStateGroupList и представляет коллекцию объектов VisualStateGroup, то есть группу визуальных состояний. В данном случае добавлена только одна группа состояний, которая называется CustomStates:

```xml
<VisualStateGroup Name="CustomStates">
```

Каждая группа VisualStateGroup определяет набор состояний. Каждое состояние определяется с помощью объекта VisualState. Этот объект принимает ряд объектов Setter, с помощью которых устанавливаются значения свойств визуального элемента, когда он принимает данное состояние. Например, когда поле Entry находится в состоянии "Focused" (то есть получило фокус), срабатывает следующее состояние:

```xml
<VisualState x:Name="Focused">
    <VisualState.Setters>
        <Setter Property="TextColor" Value="#004D40" />
        <Setter Property="BackgroundColor" Value="#B2DFDB" />
    </VisualState.Setters>
</VisualState>
```
То есть в данном случае, при получении фокуса текст окрашивается в темнозеленый цвет, а фон - в светлозеленый.

Когда поле Entry находится в состоянии "PointerOver" (то есть указатель мыши находится над элементом), срабатывает следующее состояние:

```xml
<VisualState x:Name="PointerOver">
    <VisualState.Setters>
        <Setter Property="TextColor" Value="#004D40" />
        <Setter Property="FontAttributes" Value="Bold" />
    </VisualState.Setters>
</VisualState>
```

Таким образом при наведении указателя мыши на элемент текст окрашивается в темнозеленый цвет и получает выделение жирным.

Стоит учитывать, что имена состояний в данном случае должны быть именно "Normal", "Disabled", "Focused", "PointerOver", так как это встроенные по умолчанию состояния. Название группы необязательно должно быть "CustomStates", оно может быть произвольным. Но следует учитывать, что и название состояний и название групп должны быть уникальными ( то есть нельзя определить для элемента Entry для состояния "Disabled" или две группы состояний "CustomStates").

!(https://metanit.com/sharp/maui/pics/6.15.png)

## Визуальные состояния в ресурсах

При прикреплении группы визуальных состояний к элементам код элемента может сильно разбухать. Хотя визуальные состояния не относятся к структуре элемента, а только к его стилизации. Кроме того, возможно, мы захотим использовать одни и те же визуальные состояния для разных элементов. В этом случае удобнее выносить визуальные состояния в ресурсы. Например, изменим выше определение страницы xaml:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <ContentPage.Resources>
        <Style TargetType="Entry">
            <Setter Property="VisualStateManager.VisualStateGroups">
                <VisualStateGroupList>
                    <VisualStateGroup x:Name="CustomStates">
 
                        <VisualState x:Name="Focused">
                            <VisualState.Setters>
                                <Setter Property="TextColor" Value="#004D40" />
                                <Setter Property="BackgroundColor" Value="#B2DFDB" />
                            </VisualState.Setters>
                        </VisualState>
 
                        <VisualState x:Name="PointerOver">
                            <VisualState.Setters>
                                <Setter Property="TextColor" Value="#004D40" />
                                <Setter Property="FontAttributes" Value="Bold" />
                            </VisualState.Setters>
                        </VisualState>
                    </VisualStateGroup>
                </VisualStateGroupList>
            </Setter>
        </Style>
    </ContentPage.Resources>
    <StackLayout Padding="20">
        <Entry Text="Hello METANIT.COM!" />
    </StackLayout>
</ContentPage>
```

## Визуальные состояния по умолчанию

Проект .NET MAUI по умолчанию содержит стили для элемента Entry в файле Resources/Styles/Styles.xaml, в которых определены эти состояния:

!(https://metanit.com/sharp/maui/pics/6.16.png)

Но если мы определяем визуальные состояния через стили, то мы можем переопределить эти визуальные состояния по умолчанию:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <ContentPage.Resources>
        <Style TargetType="Entry">
            <Setter Property="Margin" Value="10" />
            <Setter Property="VisualStateManager.VisualStateGroups">
                <VisualStateGroupList>
                    <VisualStateGroup x:Name="CustomStates">
                        <VisualState x:Name="Normal">
                            <VisualState.Setters>
                                <Setter Property="TextColor" Value="#004D40" />
                            </VisualState.Setters>
                        </VisualState>
 
                        <VisualState x:Name="Focused">
                            <VisualState.Setters>
                                <Setter Property="TextColor" Value="#004D40" />
                                <Setter Property="BackgroundColor" Value="#B2DFDB" />
                            </VisualState.Setters>
                        </VisualState>
 
                        <VisualState x:Name="Disabled">
                            <VisualState.Setters>
                                <Setter Property="TextColor" Value="Gray" />
                                <Setter Property="BackgroundColor" Value="LightGray" />
                            </VisualState.Setters>
                        </VisualState>
 
                        <VisualState x:Name="PointerOver">
                            <VisualState.Setters>
                                <Setter Property="TextColor" Value="#004D40" />
                                <Setter Property="FontAttributes" Value="Bold" />
                            </VisualState.Setters>
                        </VisualState>
                    </VisualStateGroup>
                </VisualStateGroupList>
            </Setter>
        </Style>
    </ContentPage.Resources>
    <StackLayout Padding="10">
        <Entry Text="Hello METANIT.COM!" />
        <Entry Text="Hello World!" />
        <Entry Text="Hello Work!" IsEnabled="False" />
    </StackLayout>
</ContentPage>
```

!(https://metanit.com/sharp/maui/pics/6.17.png)

Доступные визуальные состояния
В .NET MAUI для ряда элементов есть дополнительные состояния:

- VisualElement определяет общие для всех элементов состояния Normal, Disabled, Focused и PointerOver

- Button определяет состояние Pressed (нажатие кнопки)

- CarouselView определяет состояния DefaultItem, CurrentItem, PreviousItem и NextItem

- CheckBox определяет состояние IsChecked (флажок отмечен)

- CollectionView определяет состояние Selected (элемент выделен)

- ImageButton определяет состояние Pressed (нажатие кнопки)

- RadioButton определяет состояния Checked (элемент выбран) и Unchecked (элемент не выбран)

- Switch определяет состояния On (включено) и Off(выключено)

### Определение своих визуальных состояний

По умолчанию Visual State Manager предоставляет нам пять встроенных состояния: Normal, Focused, PointerOver и Disabled. Однако мы можем определять свои состояния. Суть встроенных состояний состоит в том, что элемент отлеживает некоторое изменения. Например, он отслеживает получение фокуса и после этого вызывает метод VisualStateManager.GoToState(), в который передается название состояния:

```xml
VisualStateManager.GoToState(visualElement, "Focused");
```

В качестве первого параметра передается элемент, для которого вызываюся состояния. Это должен быть элемент типа, который унаследован от VisualElement.

Соответственно при создании своих состояний мы должны сами отслеживать переход в эти состояния и вызывать данный метод.

Например, определим визуальные состояния для валидации данных в текстовом поле. Для этого определим следующую страницу:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<ContentPage xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
             x:Class="HelloApp.MainPage">
    <StackLayout Padding="20">
        <Entry x:Name="myEntry" TextChanged="entry_TextChanged">
            <VisualStateManager.VisualStateGroups>
                <VisualStateGroup x:Name="ValidStates">
                    <VisualState x:Name="Valid">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="Green" />
                        </VisualState.Setters>
                    </VisualState>
 
                    <VisualState x:Name="Invalid">
                        <VisualState.Setters>
                            <Setter Property="TextColor" Value="Red" />
                        </VisualState.Setters>
                    </VisualState>
                </VisualStateGroup>
            </VisualStateManager.VisualStateGroups>
        </Entry>
    </StackLayout>
</ContentPage>
```

Здесь к полю Entry прикреплена групаа состояний ValidStates (название группы может быть произвольным). Группа содержит два визуальных состояния: "Valid" и "Invalid". Каждое из состояний предусматривает определенные цвет и высоту шрифта.

Но по умолчанию Entry не отслеживает подобные состояния, и нам надо самостоятельно вызывать их. Для этого изменим код c# у страницы:

```Csharp
using System.Text.RegularExpressions;
 
namespace HelloApp;
 
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        InitializeComponent();
        SetState(false);    // изначально невалидное состояние
    }
 
    private void entry_TextChanged(object sender, TextChangedEventArgs e)
    {
        // проверяем введенное значение на соответствие регулярному выражению
        bool isValid = Regex.IsMatch(e.NewTextValue, @"^\+[1-9]-\d{3}-\d{3}-\d{4}$");
        SetState(isValid);
    }
    // установка состояния Valid или Invalid
    void SetState(bool isValid)
    {
        string visualState = isValid ? "Valid" : "Invalid";
        VisualStateManager.GoToState(myEntry, visualState);
    }
}
```

Допустим, нам надо вввести в текстовое поле номер телефона в формате +1-234-567-8901. Для этого прикрепляем к текстовому полю обработчик изменения ввода entry_TextChanged, в котоом проверяем новый введенный текст. Если он соответствует регулярному выражению, то вызывается метод

```Csharp
VisualStateManager.GoToState(myEntry, "Valid");
```

То есть для элемента myEntry вызывается событие Valid, иначе вызывается событие Invalid. И для упрощения вызов данного метода инкапсулирован в методе SetState.

Поскольку при запуске приложения текстовое поле уже должно быть в определенном состоянии, то в конструкторе также вызывается метод VisualStateManager.GoToState.

Результат работы приложения:

!(https://metanit.com/sharp/maui/pics/6.18.png)